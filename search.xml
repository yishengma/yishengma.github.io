<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM----自动内存管理机制]]></title>
    <url>%2F2018%2F08%2F08%2FJVM-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.简介Java 虚拟机，简称 JVM, 是一个虚构的计算机，可模拟实际计算机操作系统上的功能并运行在不同的操作系统上，因此只要 Java 语言编译生成在 JVM 运行的字节码，JVM 就可以根据运行的对应的系统将字节码解释成具体系统平台的机器指令，从而实现跨平台运行。 二.内存区域当执行一个 Java 程序的时候，首先会将 Java 文件编译成 class 文件， 这就是一个字节码文件，然后通过类加载器将 Class 文件加载到虚拟机中运行。 JVM 将运行时的内存区域划分为几个部分： 1.程序计数器程序计数器是线程执行字节码的指示器，每个线程有一个独立的程序计数器，是一块较小的内存空间，存放着正在执行的字节码指令或者下一条需要执行的字节码指令。如果是一个 Java 方法，则记录正在执行的虚拟机字节码指令的地址，如果是一个 Native 则这个计数器的值就为空。 程序计数器是唯一一个没有规定任何 OutOfMemoryError (内存溢出) 的区域。 2.虚拟机栈虚拟机栈是 Java 方法执行时的内存模型，与线程的生命周期相同，同样是线程独有的，在执行一个一个方法的时候就会创建一个栈帧，这个栈帧包含了局部变量表，操作数栈，方法出口等信息，方法调用和执行完成就是一个栈帧在虚拟机栈中的入栈和出栈过程。 虚拟机栈中规定的异常状况有两种： 线程请求的栈深度大于虚拟机允许的深度就抛出 StackOverflowError 虚拟机栈内存可以动态扩展，如果扩展的时候不能申请到足够的内存就抛出 OutOfMemoryError 3.本地方法栈本地方法栈的作用和虚拟机栈类似，只不过本地方法栈是 Native 方法执行的内存模型，而虚拟机栈是 Java 方法的内存模型。 4.方法区方法区市一个线程共享的内存区域，用于存储被虚拟机加载后的类的信息，常量，静态变量等数据，通常定义在 Class 文件中 运行时常量池这个方法区的一部分，用于存放编译期生成的符号引用，字面量，运行时常量具有动态性，运行期间可以将新的常量放入常量池，而 Class 文件不具备这个特性。 方法区中的异常：当方法区，包括常量池，无法申请到足够的内存的时候就会抛出 OutMemoryError 异常。 5.堆Java 堆是也是所有线程的共享的一块区域，，用于存放对象的实例，即几乎所有的对象都在这里分配内存。同时 Java 堆也是垃圾收集器管理的主要的区域，因此也叫 GC 堆（Garbage Collected Heap ）,由于垃圾收集器可以采用不同的方式，对 Java 堆还进行了进一步的划分。可分为新生代/老年代，或者划分为 Eden 空间/From Survivor空间/To Survivor 空间。 Java 堆在物理上可以不连续，只要逻辑连续，同时可以设置固定大小，也可以设置为可扩展 设置 Xmx 最大值 设置 Xms 最小值 如果一个实例在堆中没有完成分配，且堆也没有办法进行扩展，就抛出 OutOfMemoryError 异常。 二.对象的创建1.对象的内存布局前面说过实例对象是存储在 java 堆中的，而在具体的内存区域中，一个对象的存储又可以划分 3 个区域：对象头，实例数据，对齐填充。 对象头，包含了两个部分的内容，一个是对象自身的运行数据，包括哈希码，GC 分代，锁状态等，这部分称为 Mark Word。另一个部分是类型指针，指向类元数据，可以确定对象是哪个类的实例。 实例数据，这是一个对象存储的真正的信息，包括继承父类的和自己本身的。 对齐填充，起着占位符的作用，为了对象的起始地址是 8 个字节的整数倍。 2.对象的创建过程一个对象的创建通常是由 new 开始的，具体的过程可分为下面几个部分： 1.首先，会检查 new 指令的参数能否在方法区的常量池中找到对应类的符号引用，并检查这个符号引用的类是否被加载，解析和初始化过，没有就进行这三个步骤。 2.一个类加载后需要的内存大小就可以确定，接着会为这个对象分配内存，内存分配完成后会首先初始化为 0 .根据 Java 堆中内存是不是规整的有两种不同的内存划分方式： 堆内存是规整的，使用指针碰撞的方式。即用过内存放在一边，没有通过的放在一边，中间使用一个指针作为分界点，分配时通过指针移动一段合适的距离划分新的内存空间。 堆内存不是规整的，使用空闲列表。即通过一个列表记录哪些内存是可以用的，从表中找到一块区域直接划分并更新列表。 3.设置对象信息，主要是对象头中的信息，包括这个对象属于哪个类的实例，类的元数据的信息，对象的哈希码，GC 分代年龄，锁信息等。 4.执行数据的初始化，即 init 方法。 3.对象的访问对象在内存分配完成后就可以使用在 栈中的引用类型 （reference 数据）来操作具体的对象，这种访问方式可以分为来个两种方式，使用句柄和使用直接指针。 使用句柄，会在 Java 堆中划分一份区域为句柄池，作为 reference 数据和真正的对象的一个桥梁。使用句柄的优势是即使对象的内存地址被移动，只会改变句柄中的实例数据的指针，而reference 不会改变。 使用直接指针，就是指reference 直接指向对象的地址，它的优势是可以减少开销，速度比较快。 三.垃圾收集1.简介在 Java 语言中，不需要直接控制内存的回收，Java 程序的内存分配和回收都是由 JRE 在后台自动进行的 JRE 会负责回收那些不再使用的内存，这种机制称为垃圾回收（Garbage Collection ,GC ）通常在CPU 空闲或者内存不足的时候就会进行回收。垃圾回收机制能自动释放内存空间，减轻了编写 Java 程序的负担，（C/C++ 需要显示进行垃圾回收），同时垃圾回收保证了程序的完成性，垃圾回收是 java 语言安全性策略的一个重要的部分。 2.回收的对象在进行一次垃圾回收的时候首先就是要找到所有的对象，并判断对象是否可进行回收。通常由两种算法; (1).引用计数算法这种算法是通过给对象增加一个引用的计数器，只要有一个指针指向这个对象，这个计数器就加 1 ，这个引用失效就减 1.如果一个对象的计数为 0 的时候就可以进行回收。 这个算法存在的问题就是当两个对象互相含有对方的引用，但是又没有被其他对象引用的时候，计数器就不为 0 ，又不能被垃圾回收 123graph LRA--&gt;BB--&gt; A (2)可达性算法这个算法首先会记录一系列 GC Root 对象，这些对象通常就是还有被使用的对象，然后以这些对象为起点向下搜索，搜索的对象的路径称为引用链，如果一些对象到 GC Root 之间没有任何引用链，那么这个对象就可以回收。 (3)对象的引用对象被定义为两种状态：没有引用可回收，有引用不可回收，会显得内存回收不够灵活，因此希望对象如果在内存足够的时候在 GC 时 继续保留在内存中，如果进行 GC 后内存还是不足就直接回收。针对这种情况，对对象的引用进行了扩充。将一个引用划分为强引用，软引用，弱引用，虚引用。 强引用，只要强引用存在就不会回收掉引用的对象 软引用：在系统将发生内存溢出前会将这些对象列入第二次回收的范围 弱引用：无论内存是否足够都会回收 虚引用：虚引用不会对对象回收产生影响，它的作用是在回收时受到一个系统通知。 (4).对象的死亡一个对象的死亡是经过两次标记过程的，即在进行可达性算法的时候会即使不可达也不一定就立即回收。 3.垃圾收集算法JVM 并没有明确指定使用哪种算法，但是任何一种算法的作用都是发现无用的对象，回收被无用对对象占用的内存空间，使得空间能够再次被使用。 1.对象的划分在 Java 堆中通常根据对象的使用频率将对象划分为不同的区域。每一个对象有一个年龄计数器，发生一次 GC 且存活就将计数器加 1 .对于长期存活的对象就可从新生代进入老年代。对于新生代和老年代就可以采取不同的垃圾回收 Minor GC ，新生代的垃圾回收，执行比较频繁，速度比较快 Major GC/ Full GC,老年代的垃圾回收，通常老年代的会伴随着新生代回收。 2.垃圾收集算法(1)标记-清除算法对对象的内存进行标记，然后清除。这种算法有两个明显的问题： 标记和清除的效率比较低 清除后产生大量的不连续的碎片空间，在分配一些需要大内存的对像的时候可能会因为内存不够导致再一次的 GC. (2)复制算法在新生代的对象很多都有着较低的生命期，因此将内存按 8 ：1： 1 划分为 一个Eden 和两个 Survivor ，回收时将Eden 和 Survivor 存活的复制到另一个 Survivor 。如果另一个Survivor 的空间不够就需要向老年代进行分配担保，处于From Survivor 的新生代可进入老年代。 (3)标记整理存活的对象向一方移动，然后清理掉端边界的内容。 (4)分代-收集分代收集也就是对新生代和老年代采用不同的垃圾收集算法。 3.查找 GC RootJava 虚拟机中使用 Oopmap 的数据结构记录对象的引用，通过 Oopmap 就可以找到所有的 GC Root 。JVM 只在指令中产生 Safepoint（安全点） 的地方进行一次记录，可避免对每条指令进行记录导致 Oopmap 多次变化。对于执行的线程中的到达安全点，主要有抢先式和主动式两种，而对于没有运行的不代码，就设置为安全区域，Safe Region ，其中的引用关系不会变化，所以可以直接GC 可以不用响应JVM 的中断。 4.垃圾收集器垃圾收集器是对收集算法的具体实现，在JVM 中包含的收集器有下面几种： 1.Serial 收集器 单线程收集器，进行垃圾收集的时候会暂停所有的工作线程 简单高效，在内存较少的场景中，线程停顿时间是可以接受的 采取复制算法 2.ParNew 收集器 多线程版本的Serial ,在进行垃圾回收的时候是通过多个线程进行的 采取复制算法 3.Parallel Scavenge 收集器 多线程的收集器，可达到一个可控的吞吐量，高效的利用 CPU 时间，适用在后台运算而不需要太多交互的任务 采取复制算法 4.Parallel Old 收集器 Parallel Scavenge 的老年代版本，使用多线程和“标记-整理”算法 适用于注重吞吐量以及 CPU 资源敏感的场合 5.Serial Old 收集器 Serial 的老年代版本 6.CMS 收集器 是一种以获取最短回收停顿时间为目标的收集器，适用于响应速度快，系统停顿时间最短。 运作过程： 初始标记，标记 GC 能直接关联到的对象，需要停止其他线程。 并发标记，根节点枚举的过程。 重新标记，修正并发标记期间用户程序继续运作而导致标记产生变动的那个部分对象的标记，需要停止其他线程。 并发清除 缺点： 在并发阶段需要暂用一部分 CPU 资源，从而导致应用程序变慢，总吞吐量会降低。 在并发清理阶段，用户线程产生的新的垃圾不会被回收，且需要留一部分的空间给用户空间运行。 使用标记-清除算法，且通过内存碎片整理的方式，合并内存碎片，这个过程不能并发，会延长停顿时间。 7.G1 收集器特点： 并行与并发，充分利用多 CPU多核环境 。 分代收集，管理整个 GC 堆但是可以采用不同的方式去处理不同的对象 空间整合，在整体上 使用 标记整理，在局部采用复制，不会产生内存空间碎片。 可预测的停顿，可指定在一个时间片段内 GC 消耗的时间。 高效，将内存划分为几个区域，跟踪区域垃圾堆积的价值大小，维护一张优先表，优先回收。 过程： 初始标记，GC 关联对象。 并发标记，找出存活对象。 最终标记，修正并发标记期间用户程序继续运作而导致标记产生变动的那个部分对象的标记。 筛选标记，对区域进行筛选，并回收。 4.内存分配与回收策略 优先在新生代 Eden 区分配，当 Eden 没有足够的空间的时候就会发起一次 Minor GC 数组或者长字符串等大对象直接进入老年代 长期存活的对象根据对象年龄计数器的数值动态晋升到老年代。 空间分配担保：]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Context]]></title>
    <url>%2F2018%2F08%2F02%2FAndroid-Context%2F</url>
    <content type="text"><![CDATA[一.简介 Context 翻译为上下文环境，是一个应用程序环境信息的接口。 如果以 Android 系统角度来看可以理解为某一与操作系统的交互的具体场景，比如 Activity 的具体功能，Service 的后台运行等。如果以程序的角度看，Context 是一个抽象类，维持 Android 程序中各组件能够正常工作的一个核心功能类。通过 Context 可以获取应用程序的资源和类，也可以进行一些应用程序的操作。 Context 的设计采用了代理模式，它的功能的具体实现类是 ContextImpl ，而间接的实现类是 Activity ，Service 和 Application。因此一个应用程序 Context 的实例的对象的个数就是 Activity ， Service 和一个 Application 这三者的总数。它们的具体关系如图: 可以看到在代理模式中 ContextWrapper 的变量 mBase 是一个 ContextImpl 类型，通常Activity ， Service 和 Application 中的操作最终都会通过 mBase 交给 ContextImpl 去实现，最后在通过 mOuterContext 对结果进行放回，显然这个变量实际上就是Context 的三个具体的实现。下面就看这三种 Context 是如何创建并与 ContextImpl 关联的。 二.创建 Context1.Application Context一个应用程序启动时候总是会创建 Application，具体是由 LoadedApk 实现。 123456789101112131415Application app = r.loadedApk.makeApplication(false, mInstrumentation);// LoadedApk 中public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; ... Application app = null; ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); 在这里可以看到一个大致的框架，这里可以分为三个步骤去看; 首先会去创建 Application 的 ContextImpl 然后把这个 ContextImpl 作为一个参数传到 newApplcation 方法中去创建 Application 最后将 ContextImpl 和 Application 关联。 第一步想看 ContextImpl 的静态方法 createAppContext1234567static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk loadedApk) &#123; ... ContextImpl context = new ContextImpl(null, mainThread, loadedApk, null, null, null, 0, null); context.setResources(loadedApk.getResources()); return context; &#125; 很明显就是创建 ContextImp,并设置应用的资源。接着看第二步，创建 Application。 1234567891011121314151617181920 //在 Instrumentation 类中 static public Application newApplication(Class&lt;?&gt; clazz, Context context) ... Application app = (Application)clazz.newInstance(); app.attach(context);//这里的Context 就是ContextImpl return app; &#125; // 在 Application 中/* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mLoadedApk; &#125; // 在 ContextWrapper 类中protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; 可以看到首先就是通过类加载去创建 Application，然后就将 ContextImpl 赋值给 mBase ，这样 Application 和 ContextImpl 的关联就建立。最后看第三步。12345 appContext.setOuterContext(app); //在 ContextImpl 中final void setOuterContext(Context context) &#123; mOuterContext = context; &#125; 将返回的 Application 赋值给 ContextImpl 的变量 mOuterContext，这样 Context 的代理模式完成关联，Application Context 也创建完毕。 流程如图： 2.Activity ContextActivity Context 的创建可以定位到 Activity 启动过程，在 ActivityThread 中。123456789101112131415161718 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... ContextImpl appContext = ContextImpl 作为参数关联ContextImpl(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); ... appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config,r.referrer, r.voiceInteractor, window, r.configCallback); &#125; 整个过程和 Application 比较相似，不过有一点不同，这里分为 4 步来看: 创建 ContextImpl 对象 创建 Activity 实例 ContextImpl 关联 Activity Activity 关联 ContextImpl 先看第一步过程123456789101112private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123; ... ContextImpl appContext = ContextImpl.createActivityContext( this, r.loadedApk, r.activityInfo, r.token, displayId, r.overrideConfig); ... static ContextImpl createActivityContext(ActivityThread mainThread, ... ContextImpl context = new ContextImpl(null, mainThread, loadedApk, activityInfo.splitName, activityToken, null, 0, classLoader); ... 与 application 不同的是，这里创建的是对应的 Activity 的 ContextImpl ，具有不一样的功能实现。接着实例化 Activity 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 同样也是通过类加载创建 Activity。在第三四步中12345678910111213141516171819202122232425262728293031//第三步，在ContextImpl 中final void setOuterContext(Context context) &#123; mOuterContext = context;&#125;//第四步，在 Activity中 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; ... attachBaseContext(context); ... &#125;@Overrideprotected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase); ...&#125;//在 ContextWrapper 中 protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base;&#125; 通过 ContextImpl 和 Activity 的相互关联，Activity Context 的创建也就完成了，以后 Activity 的任务大多就是通过 ContextImpl 实现。 流程如图： 3.Service ContextService 的Context 的创建和 Activity 的十分相似.123456789101112131415161718private void handleCreateService(CreateServiceData data) &#123; LoadedApk loadedApk = getLoadedApkNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = loadedApk.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; ... &#125; ContextImpl context = ContextImpl.createAppContext(this, loadedApk); context.setOuterContext(service); ... service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); 整个流程没有大的变化，只是 Service 会先实例在去创建 ContextImpl ，而且这里的 ContextImpl 和 Activity 是不一样的。 流程如图： 三.Context 的使用前面说过 Context 的实现就是 Activity ，Service 和 Application ,因此如果对 Context 使用不当的话很容易发生内存泄漏，比如下面这两段代码 123456789public class A&#123; private static Context mContext; public static void setContext(Context context)&#123; mContext = context; &#125;&#125; 123456789101112131415161718192021public class B&#123; private static B sInstance; private Context mContext; private B(Context context) &#123; this.mContext = context; &#125; public static synchronized B getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new B(context); &#125; return sInstance; &#125; &#125; 在第一段代码中有一个静态的 Context ,在第二段是一个单例模式，一个静态实例拥有一个 Context 变量。在这两种情况下，Context 的周期就和应用程序一样，这是如果赋值时 Activity 或者 Service 就会使得 Activity 和 Service 在退出后不能正常被回收，因为还有 Context 引用。因此建议尽量 Application Context ，因为 Application Context 的周期就是整个应用程序，所以不用担心内存泄漏。但是在某些情况比如创建 Dialog, 或者启动组建的时候就只能使用 Activity Context 或者 Service Context ,这个时候就要注意内存泄漏问题了。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----IPC机制（Binder）]]></title>
    <url>%2F2018%2F07%2F25%2FAndroid-IPC%E6%9C%BA%E5%88%B6%EF%BC%88Binder%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一.简介IPC (Inter-Process Communication),意为进程间的通信。一个操作系统不同的进程，有自己的进程内存空间，其中的数据不共享，因此进程间的通信就需要采用一定的机制，传统的进程通信的方式有 Socket，管道，内存共享，消息队列等，在 Linux 系统中同样存在这些方式。Android 系统是基于 Linux 系统的，但是 Android 系统却采用了另一种进程通信机制 Binder ，主要有以下两点原因： 性能，传统的通信的方式，要么开销大且效率里，比如 Socket ,或者数据需要进行多次拷贝，性能较低。 安全，在 Android 系统中，获取系统操作很简单比如连接无线网络，访问文件等，如果不对进程进行标识，一些程序就很容易进行频繁地进行底层操作。传统 IPC 没有任何安全措施，不能识别用户进程，比如 Socket ，用户完全可以指定自己的端口。 而使用 Binder 可以做到只对数据进行一次拷贝，并在每次通信的时候问每个用户进程添加标识。因此相对传统的 IPC 机制性能和安全性都相对较高。 二.基础概念1.Parcel/Serializable/Parcelable Serializable ：[sɪərɪrlaɪ’zəbl] 1.Parcel 是一个容器，可以包含数据或者是对象引用，支持序列化以及跨进程之后进行反序列化，里面有很多 native 方法，在底层实现中都是用于将数据写入内存，和从内存中。 2.Serializable 和 Parcelable 都是实现序列化的接口，Parcelable 是在内存中直接进行读写,中间结合需要 Parcel 类去做一些低层的工作 （C/C++ 实现）而 Serializable 是通过使用 IO 流的形式将数据读写入在硬盘上， Parcelable 的性能要强于 Serializable, 但是 Parcelable 无法将数据进行持久化。 2.IBinder/Binder1.IBinder 是 Binder 的接口，。这个接口定义了与远程对象交互的协议。不仅用于远程调用，也用于进程内调用 2.Binder 实现了 Binder 接口，这是 Binder 机制的通信的媒介，进程 A 调用进程 B 的方法，具体就是由这个 Binder 实现。 3.Binder 驱动(1).运行空间（内核空间/用户空间）在 Android 系统中负责调用系统一切资源的是 Linux 的内核空间，而用户程序运行的空间是用户空间，每个进程有属于自己的用户空间，当用户空间需要调用系统资源的时候，只能通过内核空间提供的 System call ,系统调用，去访问内核空间。 (2).Binder 驱动传统的 IPC 机制是 Linux 内核支持的，但是 Binder 并不是 Linux 支持的，但是 Linux 可以动态添加内核模块，这个模块在内核中有自己的内核空间，因此 Android 就在系统中添加一个模块，这个模块就叫 Binder 驱动。Binder 驱动会自动完成进程 A 和 进程 B 的 Binder 对象的转换；而相应的方法参数就会在用户空间通过 mmap ,ioctl ，open 等 方法就可以调用 Binder 驱动里的方法，然后这样两个不同进程的用户空间就可以通过这个 Binder 驱动的内核空间进行通信。 4.Binder 框架1.Client，客户进程，这是相对的说法，只要是发起进程请求的一方都可以为客户进程 2.Server，服务进程，这也是相对的说法，被请求执行某种服务的进程都可以称为服务端进程 3.ServiceManager，SM，对服务进程的管理，每个服务进程都要在这里注册所拥有的跨进程的 Binder, 并保存对应的 Binder 的引用，Client 可以通过名字在这里查询想要的服务的名字，最后 SM 就会返回该 Server 的一个 Binder 的引用。SM 也是一个进程，但是每个需要和 SM 通信的进程都知道 SM 的引用，这是提前就固定的。 4.Binder 驱动，在具体的通信过程中做中转，比如需要传递的数据，Binder 对象在两个进程间的转换等. 5.Java 层的 Binder1.AIDLAIDL (Android 接口定义语言),用于跨进程通信，通过定义 ADIL ,AS 会自动生成 Binder 类。比如，定义一个如下的接口12345678import com.example.asus.testdemo.Book;//即使在一个包下也要 importinterface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; aidl 支持的数据类型有如下 基本数据类型 String 和 CharSequence List，只支持 ArrayList，每个元素都支持 AIDL Map，只支持 Map,每个key，value,都支持 AIDL Parcelable,所有实现 Parcelable 接口 AIDL,所有定义为 AIDL 的接口，比如上面的 IBookManager ，也可以作为一个接口对象 生成的 aidl 文件为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public interface IBookManager extends android.os.IInterface &#123; public interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.asus.testdemo.IBookManager &#123; private static final java.lang.String DESCRIPTOR = &quot;com.example.asus.testdemo.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.asus.testdemo.IBookManager interface, * generating a proxy if needed. */ public static com.example.asus.testdemo.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.asus.testdemo.IBookManager))) &#123; return ((com.example.asus.testdemo.IBookManager) iin); &#125; return new com.example.asus.testdemo.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.example.asus.testdemo.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.example.asus.testdemo.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.asus.testdemo.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.asus.testdemo.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException; &#125; 这个接口的内部结构就是有一个 Stub 的内部类，这 Stub 内部类还有一个内部类 Proxy。先看 Stub 类，Binder 的 java 层采用的是代理模式，其中 Stub 类代表是 Binder 的本地对象，而 Proxy 则是 Binder 在另一个进程的代理对象。先看 Stub 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static abstract class Stub extends android.os.Binder implements com.example.asus.testdemo.IBookManager &#123; private static final java.lang.String DESCRIPTOR = &quot;com.example.asus.testdemo.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.asus.testdemo.IBookManager interface, * generating a proxy if needed. */ public static com.example.asus.testdemo.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.asus.testdemo.IBookManager))) &#123; return ((com.example.asus.testdemo.IBookManager) iin); &#125; return new com.example.asus.testdemo.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; ... &#125; case TRANSACTION_getBookList: &#123; ... &#125; case TRANSACTION_addBook: &#123; ... &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; DESCRIPTOR，Binder 的唯一标识 asInterface，用于 Binder 到转换，如果客户服务端都在同一进程，就会返回一个 Binder 对象本身，如果是在不同进程就返回其代理 Proxy. asBinder,返回当前的Binder 对象 onTransact，这个方法在服务端的线程池中，通过标识判断客户端调用的是什么方法，data 就是方法的参数。 这是一个抽象类，因此具体的是实现就在 Service 中,通过onBinder 方法返回具体的实现。接着看 Proxy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static class Proxy implements com.example.asus.testdemo.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.asus.testdemo.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; 客户进程得到的对象通常为这个类的实例，_data 就是参数，_reply 就是相应的返回值，而在这里封装了具体的数据写入的底层实现，而这对客户进程是透明的。 三.工作流程1.大致流程1.当有一个应用进程提供一个可跨进程访问的的服务的时候，就会通过默认的通信地址向 ServiceManager 注册服务相应的线程就进入等待，这时 ServiceManager 就会通过 ioctl 方法让 Binder 驱动在内核空间保存相应的信息，然后 ServiceManager 就会唤醒线程通知应用进程注册成功。 2.客户进程查询服务，SM 会通过和 Binder 驱动交互，查询已注册的服务，查询到就返回相应的对象，这时就会返回一个代理对象。 3.通过调用代理对象的方法这时客户进程的这个线程进入等待状态，按之前的 Proxy 的方法的实现可以知道，在客户进程只是对一些数据进行包装，然后写入Binder 驱动和 SM 的共享内存，这是一次拷贝也是唯一的一次， 而服务进程的用户空间的地址和这个内存已经做了映射，所以 服务进程可以直接获取内存中的数据， 对于Binder Proxy 对象，就又转化为 Binder 的 Stub 的具体实现，等执行完后就返回，这同样也是一次通信，最后客户的进程的线程就会被唤醒。 2.跨进程的接口同样的通过定义一个接口，让客户进程实现相应的方法，可以做到在服务进程回调所有客户进程的方法。 123interface IOnNewBookListenerArrivedListener &#123; void onNewBookArrvied(in Book newBook);&#125; 123456789101112131415interface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookListenerArrivedListener listener); void unregisterListener(IOnNewBookListenerArrivedListener listener);&#125; 在服务进程有一个用于对所有接口保存的类，RemoteCallbackList 是系统用于跨进程接口通信的，内部有一个 HasMap ,key 是 IBinder ，value 是 listener, 因此可以根据 Binder 找到客户端，因为每个客户端的 Proxy 都是不一样的。1private RemoteCallbackList&lt;IOnNewBookListenerArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); 在重写的方法中12345678910@Override public void registerListener(IOnNewBookListenerArrivedListener listener) throws RemoteException &#123; mListeners.register(listener); &#125; @Override public void unregisterListener(IOnNewBookListenerArrivedListener listener) throws RemoteException &#123; mListeners.unregister(listener); &#125; 回调的具体使用可以看以下例子1234567private void onNewBookArrived(Book book) throws RemoteException&#123; for (int i=0;i&lt;mListeners.beginBroadcast();i++)&#123; IOnNewBookListenerArrivedListener listenerArrivedListener = mListeners.getBroadcastItem(i); listenerArrivedListener.onNewBookArrvied(book); &#125; mListeners.finishBroadcast(); &#125; 在客户端只要这样使用就可以 12345678private IOnNewBookListenerArrivedListener mListener = new IOnNewBookListenerArrivedListener.Stub() &#123; @Override public void onNewBookArrvied(Book newBook) throws RemoteException &#123; Log.e(TAG, &quot;onNewBookArrvied: &quot;+newBook.toString()); &#125; &#125;; ....mBookManager.registerListener(mListener); 四.其他方式1.Intent/BundleIntent 和 Bundle 都实现了 Parcelable 接口，因为 Intent 常常用于组件的通信，因此在跨进程中，这也只是适合于组件间的跨进程通信，低层也是 Binder 机制。 2.文件共享两个应用进程使用同一个共享文件并结合序列化可实现对数据的传递，但是在 Linux 系统中对文件的读写并没有处理并发情况，因此在高并发访问的情况可能会产生一些问题。 3.Messenger和 Messege 共同使用，但是服务对 Messege 的处理时串行的，因此也不适合高并发情况，且不能获取返回的结果,不适合 Remote Procedure Call （RPC 跨进程调用）。这是对 AIDL 封装后的是使用，也就是内部是 Binder 机制。 4.ContentProvider用于一对多的进程间的数据共享，支持并发操作，因为内部的数据库实际上是可以做到同步的，在底层仍然是 Binder 机制 5.Socket常用于不同网络的进程间的通信，因此不适合 RPC 。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Handler消息机制]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid-Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.简单介绍Android 中的消息机制主要是指 Handler 的运行机制和在 MessageQueue 和 Looper 的配合下 将一个线程中的任务切换到 Hanlder 所在的线程去执行。在 Android 中常常用来在子线程切换到 UI 线程从而在 UI 线程更新 UI 。 Android 的 UI 控件不是线程安全的，如果多个线程并发访问控件会导致控件的状态不可预期，这和多线程访问同一的变量是一个道理，但是控件却不能像简单的变量一样加上锁机制就可以实现线程同步，因为这会降低 UI 的访问效率。所以采用单线程的模式通过 Handler 切换可以实现 UI 的更新。 二.涉及的几个类1.MessageQueue 和 MessageMessageQueue 是一个消息队列，内部是以一个单链表的数据结构维护数据。Message 就是消息队列中存储的对象。 2.Looper在消息机制中 Looper 会不断地从 MessageQueue 中查看是否有新的 Message 需要处理，没有就阻塞等待，这是一个无限循环的模式。MessageQueue 会在 Looper 的构造器中初始化，也就是说一个 Looper 对应一个 MessageQueue . 3.Handler消息的发送者和处理者，内部有一个 Looper 和一个 MessageQueue 。通过 dispatchMessage 方法对消息进行分派，决定最后的回调方式。有一个抽象方法 handleMessage 用与处理消息。在 dispatchMessage 方法中，如果消息是 handler.post 方式发送则会调用 post 里的 Runnable 接口，如果是 sendMessage 方式发送就会调用 handleMessage 方法。 4.ThreadLocal这是 Thread Local Variable 线程局部变量的意思，支持泛型，这个类的功能就是为每个线程提供一个变量（ 用泛型指定 类型）的副本，使得每个线程都可以独立地改变自己的副本而不会和其他线程产生冲突。可以隔离多个线程对共享资源的冲突。在 Handler 中 ThreadLocal 存放着 Looper ，因此只要在 UI 线程中都可以实例化 Handler 就可以得到主线程的 Looper。 三.工作过程在实际开发中，Handler 的使用通常在主线程中，然后在子线程中发送消息，最后在运行在主线程的 handleMessage 处理消息，或者以 Handler.post 方法中处理消息。 1.主线程的消息循环主线程的消息循环的开始是在 ActivityThread 的 main 方法中 123456789public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); ... Looper.loop(); &#125; 这里先看第一个方法 prepareMainLooper ，这是独有的。123public static void prepareMainLooper() &#123; prepare(false); ... 12345678private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; //创建主线程的 Looper sThreadLocal.set(new Looper(quitAllowed)); &#125; 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 在 ActivityThread 的 main 方法中会创建主线程的 Looper ,并且在实例化 Looper 时候就创建消息队列 MessageQueue ，并将当前线程和 Looper 关联起来。接着创建完 UI 线程后就会执行 loop 方法。 1234567891011121314151617public static void loop() &#123; final Looper me = myLooper(); ... //无限循环 for (;;) &#123; Message msg = queue.next(); // might block ... try &#123; ... //这里的 target就是 Handler msg.target.dispatchMessage(msg); ... &#125; // 释放资源 msg.recycleUnchecked(); &#125;&#125; 在 loop 方法中会无限循环对消息队列进行查看，如果有消息就取出消息，并找到消息对应的执行者进行分派，最后释放资源。 2.Handler 的创建12345678public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); ... mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 通常如果使用 Handler 更新 UI 控件的话，那么 Hanlder 的实例化就要在主线程中，因为这样才能在构造方法中获取主线程的 looper 和对应的 MessageQueue 。 3.sendMessage 和 post(1).sendMessage( Message )1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 12345public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; ... return enqueueMessage(queue, msg, uptimeMillis);&#125; 12345678private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //在这里 msg 的 target 就被赋值，这里指向就是 handler msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从上面的方法一步步执行下来，在 enqueueMessage 方法中将 msg 的 target 指向 调用的 handler ，最后就会将消息添加到消息队列中。 (2)post( Runnable )1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 123456private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); //将 Runnable 赋给 Message 的 callback m.callback = r; return m; &#125; post 方式中参数是一个 Runnable 对象，在 Hanlder 会被封装为一个 Message ,最后同样调用 sendMessageDelayed 方法，后续的操作就是一样的。 4.处理消息通过 3 中两种方式都可以发送一个消息，往消息队列中添加 Message ,而接着 looper 循环就会取出这个消息，对其进行分配也就是在之前讲过的 msg.target.dispatchMessage 方法。这里的 msg.target 在 3 中可以看到其实就是 Handler ，接着就看 dispatchMessage . 1234567891011121314public void dispatchMessage(Message msg) &#123; //这对应 post 方式 if (msg.callback != null) &#123; handleCallback(msg); //这对应 sendMessage 方式 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 可以看到最后就会根据之前的发送消息的方式从而选择不同的方法，如果是 post 方式就会执行 post 里面的 run 方法，如果是 sendMessage 方式就会执行 handleMessage .大致流程如图： 点击查看大图 四.HandlerThread 和 IntentService在上面的讲述过程中，都是以主线程的存在情况，因为主线程在程序运行开始阶段系统就会创建被初始化 looper 和 MessageQueue ,不用自己手动创建。这是 Handler 消息机制的在主线程的运用情况，下面就介绍如何在子线程运用 Handler 。 1.HandlerThreadHandlerThread 继承了 Thread ,内部有自己的 Looper 。这个类是对在子线程使用 Handler 和 Looper 的一个简单的封装，从而实现子线程有自己的消息循环。 12345678910111213141516171819202122public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; .... @Override public void run() &#123; mTid = Process.myTid(); //创建自己的 Looper Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); //消息循环 Looper.loop(); mTid = -1; &#125;&#125; 12345678910public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 在子线程中创建一个 Looper ,需要通过 prepare() 方法，后续的步骤也和之前在主线程创建一样，只不过这里的 Looper 是属于 HanlderThread 这个线程的。 2.IntentService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; //因为这里的 handleMessage 是在 HanldeThread 中的 //所以 onHandleIntent 也就运行在子线程中。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; @Override public void onCreate() &#123; super.onCreate(); //创建 HanlderThread 对象 HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); //获取线程中的 Looper mServiceLooper = thread.getLooper(); //绑定自己的 Handler ,注意这里的 Looper 是子线程的， //所以 Handler 中的方法会运行在子线程中 mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; //将 Intent 包装在 Message 中发送 mServiceHandler.sendMessage(msg); &#125; 上面方法是 IntentService 的源码，IntentService 有一个特殊的方法就是 onHandleIntent ，这个方法是一个运行在子线程中方法，所以可以进行一些耗时的操作。IntentService 实现的原理实际上就是运用了 HandlerThread 。在 onCreate 方法中会启动这个线程，并将 ServiceHandler 和 HandlerThread 线程的 Looper 进行绑定，因此 Hanlder 发送的消息就会到这个子线程中去处理。在 handleMessage 调用 onHandleIntent ，从而实现在子线程获取 Intent,并处理操作。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----View事件分发和绘制机制]]></title>
    <url>%2F2018%2F07%2F21%2FAndroid-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%92%8C%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.View 的事件分发(一).概念1.事件分发View 的事件分发其实就是点击事件（ MotionEvent ）从产生后系统开始分发，到传递给一个具体的 View （ 或者Activity ）的过程，View (或 Activity )会选择是否对事件进行消耗。 2.事件的类型和事件序列(1)事件类型 MotionEvent.ACTION_DOWN 按下时产生的事件 MotionEvent.ACTION_MOVE 滑动时产生的事件 MotionEvent.ACTION_UP 抬起时产生的事件 MotionEvent.ACTION_CANCEL 发生异常时产生的事件 (2)事件序列同一个事件序列指的是从按下时候到抬起时产生的一系列事件，通常以 DOWN 开始，中间有不定数个 MOVE ,最后以 UP 或者 CANCLE 结束。 3.分发对象和对应的方法对事件的分发主要涉及三个对象，Activity , ViewGroup ,具体的 View，这三个对象按分发的层次依次是Activity -&gt; ViewGroup -&gt; 具体的 View 。而涉及分发的方法同样主要有三个： dispatchTouchEvent 对一个事件进行分发，可能是分发给下一层处理，或者分发给自己。 onInterceptTouchEvent 这个方法只有 ViewGroup 有，用来判断对事件是否进行拦截，如果拦截就不会分发给下一层. onTouchEvent 对事件进行处理，消耗或者不消耗，不消耗就会返回给上层。对于 ViewGroup 和 View 这个方法还受到 OnTouchListener 和 enable 属性 的影响，具体的后面会阐述。 (二).事件分发1.Activity 对事件的分发12345678public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; Activity 的事件的处理其实并不负责，即如果下层（不管是 ViewGroup 还是 View ）消耗了这个事件，那么 if 语句就为 true , 则 dispatchTouchEvent 就返回 true 。如果没有消耗就自己对事件进行处理，即调用 onTouchEvent 方法。12345678public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false;&#125; 12345678910/** @hide */public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; final boolean isOutside = event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123; return true; &#125; return false;&#125; Activity 的 onTouchEvent 会对这个事件进行判断，如果事件在窗口边界外就返回 true，dispatchTouchEvent 就返回 true ;如果在边界内就 返回 false ,最后 dispatchTouchEvent 也会返回 false 。这部分流程如图 （这是截自整体流程图的一部分） 2.View 对事件的分发这里先说 View 对事件的分发是因为 ViewGroup 继承自 View ,ViewGroup 对事件的分发会调用到父类（也就是View ）的方法，因此先理清 View 的分发有助于理解。 123456789101112131415public boolean dispatchTouchEvent(MotionEvent event) &#123; ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... return result; &#125; 可以看到 View 的事件的处理是先判断 mOnTouchListener !=null 和 View 设置 ENABLED 这两个条件成不成立，不过成立则 调用 onTouch 方法，且如果 onTouch 返回了 true ,那个事件就被消耗 ，View 的 dispatchTouchEvent 就返回 true ; 相反，如果条件不成立或者 onTouch 返回 false ,那么就会执行 View 的 onTouchEvent 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean onTouchEvent(MotionEvent event) &#123; ... final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // 若可点击，包括LONG_CLICKABLE 或者 CLICKABLE if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ... // 执行performClick() performClick(); break; case MotionEvent.ACTION_DOWN: ... break; case MotionEvent.ACTION_CANCEL: ... break; case MotionEvent.ACTION_MOVE: ... break; &#125; //&gt;&gt; 若可点击，就返回true return true; &#125; //&gt;&gt; 若不可点击，就返回false return false; &#125; 123456789public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false; &#125; 在 onTouchEvent 方法中，如果 View 是可点击的，比如设置了 onClick 或者 onLongClick ,就会执行 onClick 方法，并且 onTouchEvent 返回 true ，如果是不可点击的就返回 false 。需要注意的是这里的 onTouchEvent 是可以被重写的。如果 onTouchEvent 返回 true 那么 View 的 dispatchTouchEvent 就返回 true ,事件就被消耗，如果 onTouchEvent 返回 false , 那么 dispatchTouchEvent 也返回 false ,这时 事件就交由上层处理，也就是 ViewGroup 。这部分流程如图 3.ViewGroup 对事件的分发ViewGroup 对事件的分发也是从 dispatchTouchEvent 方法开始的，不同的是 ViewGroup 对了一个对事件进行拦截的方方法 onInterceptTouchEvent 。1234567891011121314151617181920212223242526272829public boolean dispatchTouchEvent(MotionEvent ev) &#123; final boolean intercepted; ... if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; ... //不拦截，分发给下一层 if (!canceled &amp;&amp; !intercepted) &#123; ... if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. ... &#125; ... // 子View 不处理，分发给自己 if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; ...&#125; 123456789101112131415private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; ... final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; //没有 子View 就自己处理 handled = super.dispatchTouchEvent(event); &#125; else &#123; //有就分发给下一层 handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ViewGroup 首先会判断 onInterceptTouchEvent 表示要不要拦截，这个方法也可以重写设置是否拦截，如果返回 false 就表示不拦截，这个事件就会分发给下一层，如果拦截就会分发给自己，当然如果子 View 不处理这个事件，还是会传到 ViewGroup ，ViewGroup 会调用父类也就是 View 的方法，后面的过程就和 View 对事件的处理是一样的 onTouch ,onTouchEvent , onClock …这部分的流程如图： ViewGroup 对事件的拦截 onInterceptTouchEvent 并不是每一次都会调用123456789101112131415if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState();//重置标志 &#125;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; 可以看到这里有三个条件：ACTION_DOWN 事件，mFirstTouchTarget 变量，FLAG_DISALLOW_INTERCEPT 这个标志。 1.对于 ACTION_DOWN 事件在判断之前都会调用 resetTouchState 这个方法重新给 FLAG_DISALLOW_INTERCEPT 置位,因此只要是 DOWN 事件，onInterceptTouchEvent 就会调用。 2.对于 mFirstTouchTarget 这个变量只要有 View 对事件进行处理，那么这个事件的后续事件就会直接交给这个 View ,mFirstTouchTarget 就直接指向 View , 正常情况下不会再询问 ViewGroup 是否拦截。而特殊情况就是下面这个。 3.对于 FLAG_DISALLOW_INTERCEPT子 View 可以重置这个标志，使得 disallowIntercept 的值改变从而可能会重新 onInterceptTouchEvent 对事件进行拦截。 到这里View 的事件分发的各个流程就已经讲完，最后是一个整体的流程： 二.View 的绘制(一).概念1.绘制机制View 的绘制机制实际上指的是 View 的三大流程 测量流程，测量 View 的大小，对应 measure 方法。 布局流程，有了 View 的大小后确定 View 的位置，对应 layout 方法。 绘制流程，对 View 的颜色，内容等进行绘制，对应 draw 方法。 View 的绘制从 ViewRootImpl 的 performTraversals 开始，首先会调用 performMeasure 方法，在这个方法中会一个 View 会调用 measure 去测量自己的大小，在此之前会调用 onMeasure 去测量子 View 的大小，这样层层调用，最后就会完成整个测量过程，后面的 layout 和 draw 的过程也是大致如此。流程如图 2.MeasureSpecMeasureSpec 是一个测量规格，在测量一个 View 的时候 从父类计算出来的 MeasureSpec 会传给这个 View ，同时会根据 View 自身的 LayoutParams 属性，也就是指定的一些 MATCH_PARENT, WRAP_CONTENT,xxdp 等属性最终一起决定 View 的大小。 MeasureSpec 是一个 int 值，有32位，高2位代表 Mode ,后30 位Size .之所以将两个值包装在在一个 int 是因为这样可以减少减少对象的分配。而 Mode 表示测量模式，有三种测量模式分为别 UPSPECIFIED ，未指定，父 View 对子 View 不做任何限制 EXACTLY，精确，父 View 给子 View 的大小是一个确定的值，为 Size AT_MOST，最大，父 View 给子 View 的大小 是一个不确定的值,最大为 Size 具体的计算就在下面的方法中 12345678910111213141516171819protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //这里的第一个参数就是 父View 的 MeasureSpec //第二个参数就是父 View 对子View 的位置限制 padding //和 子View 对自己的位置限制 margin 和 已使用的宽度 widthUsed //第三参数就是 xml 指定的子 View 宽度 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 在父 View 的 MeasureSpec 确定后，会传递给子 View ,子View 就会根据这个 MeasureSpec 和自己的 LayoutParams 属性，计算出自己的 MeasureSpec 和 大小(即 Size)，然后就会将这个 MeasureSpec 传递给子View 的 子View, 从而遍历测量完所有的 View。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //父 View 减去一个 宽度/高度位置限制 就是 父View 给 子View 的 大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us //父 View 是 EXACTLY case MeasureSpec.EXACTLY: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.EXACTLY; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us //父 View 是 AT_MOST case MeasureSpec.AT_MOST: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be //父 View 是 UNSPECIFIED case MeasureSpec.UNSPECIFIED: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; 默认为 0 resultMode = MeasureSpec.UNSPECIFIED; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; 默认为 0 resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType //将 Mode 和 Size 包装成 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 子View 的 MeasureSpec 确定就是上述过程，这个过程可用下图表示理解这个图只需要注意下面几点 只要子 View 是 xxdp 的，不管父View 是什么模式，子 View 都是使用自己的指定的大小 childDimension. 如果父 View 是 确定的 (EXACTLY)，那么 子View 是 MATCH_PARENT 也就是充满父 View 的话，子View 也是确定的 EXACTLY ；如果子 View 是 WRAP_CONTENT，那么子 View 就是不确定的，但是不能超过父 View 的大小，因此子View 就是 AT_MOST 。 如果父 View 是不确定的 (AT_MOST )，那么不管子View 是 MATCH_PARENT 还是 WRAP_CONTENT ，子 View 都是不确定的。 如果父 View 是未指定的 (UNSPECIFIED)，那么子 View 也是未指定的，size 也就没意义，即为 0 。 (二).三个流程View 的三个流程都都是从 ViewRootImpl 的 performTraversals 开始的，而且都是从 DecorView 开始的，这里就不对具体的情况进行梳理，而是从宏观的角度却分析，三个流程是如果在 ViewGroup 到其中的子View 中进行工作的。 1.measure123456789private void performTraversals() &#123;...int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);...performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);... &#125; 12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 在上述过程中,因为第一个 measureSpec 的产生总是布满全屏的, 即 measureSpec 是确定的 EXACTLY, size 就为屏幕大小.在 performMeasure 就会开始对 DecorView (也就是一个 ViewGroup ) 进行测量. 123456789101112private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try &#123; //对 DecorView 开始测量 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 因为 ViewGroup 继承自 View ,首先看 View 的 measure12345678910public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... &#125; 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;//测量自己的大小,一旦完成,View 的测量也就结束,这是 View 默认的方法,具体不同的 View 会有不同的测量方式. setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 在 View 中 measure 是一个 final 方法,因此不能被重写,在里面会调用 onMeasure 方法,这个方法就可以被重写,接下看 具体的某一个的 ViewGroup ( FrameLayout )中的这个方法. 123456789101112131415161718@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); ... for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); ... &#125; &#125; ... setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); ...&#125; 在 FrameLayout 中的 onMeasure 首先会对去调用 measureChildWithMargins 去计算自己的 MeasureSpec 然后就去测量子 View 的大小,等所有的子 View 测量好了,就会测量自己的的大小.而子 View 会重复这个两个方法,最后完成所有 View 的 测量.这个流程如图所示: 2.layout12345678910111213private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125; 在 performLayout 会直接 调用 host 的 layout ,这个 host 实际上就是 DecorView ,DecorView 是一个 ViewGroup ,首先看 ViewGroup 的 layout 方法.123456@Override public final void layout(int l, int t, int r, int b) &#123; ... super.layout(l, t, r, b); ... &#125; 1234@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 在 ViewGroup 中 layout 是一个 final 的方法,在里面会调用父类的layout 方法,也就是 View 的 layout 方法.这里先说明 onLayout 方法,在这里是一个抽象方法,因为不同的 ViewGroup 对子 View 的位置安排是不一样的,因此具体的 onLayout 需要具体的继承类去实现.先看 View 中的 layout 方法123456789101112131415161718@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;) public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame 确定自己的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); .... if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //调用 onLayout onLayout(changed, l, t, r, b); ... &#125; 首先在 layout 方法中会确定自己的位置,即 left,top,bottom,right 这个四个属性,接着就会调用 onLayout ,如果这是一个 View,那么 onLayout 就是一个空方法,如果这是一个 ViewGroup ,那么在这方法内就会去确定 子View 的位置.比如 FrameLayout 中.1234567891011121314@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); ... ... child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; 这部分的流程如图: 3.drawdraw 的绘制基本就包含五个步骤: 绘制背景 绘制自己的内容 绘制子 View 绘制foreground，比如滚动条 绘制一些高光 这个过程对于 View 和 ViewGroup 是一样的,只不过 View 中 不会绘制自己的子 View ,因此是个 dispatchDraw(canvas) 在这里是个空方法.具体的流程如图:]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Window 窗口机制]]></title>
    <url>%2F2018%2F07%2F18%2FAndroid-Window%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.前言Window 在 Android 有两种含义，一种是狭义的，一种是广义的。狭义的 Window 指的是 Window 这个抽象类，它的唯一的实现是 PhoneWindow 。广义的 Window 指的是 Android 中表示的窗口的概念，所谓的 Window 窗口机制实际上说的是广义的 Window ，在 Android 中窗口具体可以划分为 三种： 应用程序窗口：对应 Activity 显示的视图 子窗口：对应 Dialog ,PopupWindow ，Menu 等 系统窗口：对应 StatusBar ，Toast ,输入法键盘等 在 Window 窗口机制中，这三种类型就统称为 Window ，因为它们的作用就是显示某种视图，因此一般说的 Window 没有说明都指的是广义的 Window。 二.Window 的管理 Window 的管理涉及到应用进程和系统服务进程之间的通信，这里分为两个方面进行说明。 (一).在应用进程涉及的几个类1.ViewManager 这是一个接口，里面只有三个方法，定义了对 View ( 也就是所说的视图 )的基本操作，添加，刷新和移除 123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 2.WindowManager这也是一个接口，继承 ViewManager，负责对 Window 进行管理，和操作。每一个 Window 都持有这个对象，用于对自己窗口内部的 View 进行操作。这里还有一个静态的内部类 LayoutParams, 这个类定义 Window 的一些属性，窗口的类别和显示顺序。属性指的是窗口大小，位置，状态等信息，而窗口的类别就是前言中说的三种，这是通过设置 type 值显示的，每个类别有一个范围的 type 值，而显示顺序也是根据 type 值来确定的， type 值越高就越前，也就是越靠近用户。 应用程序窗口的 type ：1 ~ 99 子窗口的 type : 1000 ~ 1999 系统窗口 type : 2000 ~ 2999 123456789101112131415161718192021222324252627282930313233@SystemService(Context.WINDOW_SERVICE)public interface WindowManager extends ViewManager &#123; ... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; ... // 应用程序窗口 public static final int FIRST_APPLICATION_WINDOW = 1; public static final int TYPE_BASE_APPLICATION = 1; public static final int TYPE_APPLICATION = 2; public static final int TYPE_APPLICATION_STARTING = 3; public static final int TYPE_DRAWN_APPLICATION = 4; public static final int LAST_APPLICATION_WINDOW = 99; //子窗口 public static final int FIRST_SUB_WINDOW = 1000; public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1; public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2; public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3; public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5; public static final int LAST_SUB_WINDOW = 1999; //系统窗口 public static final int FIRST_SYSTEM_WINDOW = 2000; public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW; public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1; public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2; ... public static final int LAST_SYSTEM_WINDOW = 2999; &#125;&#125; 3.WindowManagerImplWindowManager 的实现类，持有 Window 类型的变量，因而对 Window 的操作会在这里调用，但是对 View 的三个操作并没有在这里实现，而是由成员变量 WindowManagerGlobal 类型的 mGlobal 去执行。1234567891011121314@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ... mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 4.WindowManagerGlobal 这个类虽然没有实现 ViewManager ，但是它在这里同样定义了这三种操作，同时它还有几个重要的变量。而对于具体的 View 的操作，这里也没有实现而是交由 ViewRootImpl 去实现。12345678910111213141516171819202122public final class WindowManagerGlobal &#123; ... private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); 所有 Window 对应的 View private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); //所有 Window 对应的 ViewRootImpl 。 private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 所有 Window 的属性参数 private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); //已经执行 remove 方法但是还未真正完成删除的 View 。 ... public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... &#125; public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; ... &#125; public void removeView(View view, boolean immediate) &#123; ... &#125;&#125; 5.ViewRootImplViewRootImpl 是连接 Window 和 View 关系的桥梁。有三个方面的作用： 一是管理 View 树，并完成 View 的绘制三大流程 二是管理 Surface 并对输入事件的的转发。 三是与 WMS ( WindowManagerServer )进行进程间的通信。它有两个重要的变量： IWindowSession mWindowSession ： Binder 对象，服进程在 应用程序进程中的代理对象，用于调用服务进程中的方法。在 WMS 中的是是实现为 Session 。 W mWindow ： Binder 对象，用于服务进程的调用应用进程的方法。主要是 WMS 添加Window 成功后在 Window 进行显示或者其他操作。 6.DecorView ，mNextView，mDecor 等DecorView 对于大家可能比较熟悉，这是 Activity 视图中的“根视图”，而其他两个则是 Toast 和 Dialog 的根视图。这看起来好像每种窗口类型都有自己的“根视图”，事实上的确是这样的，我们都知道 Window 实际上就是为了显示各种各样的视图，因此一个 Window 中就可能会有多个 View, 而使用“根视图”则提供了结构上方便，所有的 View 都是以“根视图”来进行添加删除等的，因此便于 WindowManager 对窗口进行管理。在 Activity 中 DecorView 是PhoneWindow 的一个变量，但是并不是所有的窗口都会使用 PhoneWindow 和 抽象接口 Window。整体的体系如图： 点击查看大图 (二).创建 Window ( 在应用进程 )在了解了上面几个概念后，下面就以实际的例子进行说明，虽然不同类型的窗口在创建 Window 的时候整体机制是一样的，即通过 WindowManager 进行管理，但是在一些具体的方面还有有差别的。 1.Activity 的窗口创建和 setContentView在 Activity 启动过程中的最后一步 Activity 实例创建完后会需要调用 attach 方法关联上下文，在这里会创建 Window 对象。123456789final void attach(...)&#123; ... mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ...&#125; 在创建完 Window 后就需要往这个 Window 添加一个最低层的 View 用于管理以后的所有的 View,没错这个 View 就是 DecorView。DecorView 实际上是一个 FrameLayout ，它里面有一个 LinearLayout , LinearLayout 有两个子元素，一个是 的 actionbar ， 一个就是 FrameLayout 的 content 。setContentView 就是在这个 FrameLayout 里添加我们的 LayoutView.在这之前需要先创建 DecorView 。 1234567@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; 首先这里 mContentParent 就是 FrameLayout 的 content 。因为是第一次创建为 null, 就要初始化 DecorView12345678910111213private void installDecor() &#123; ... if (mDecor == null) &#123; mDecor = generateDecor(-1); ... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); &#125; ...&#125; 123456protected ViewGroup generateLayout(DecorView decor) &#123; ... ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... return contentParent;&#125; 在初始化DecorView 后就会加载 Content View ,并添加到 DecorView .这里的 ID_ANDROID_CONTENT 实际上就是 com.android.internal.R.id.content，在 layout 文件中可以看到 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 在上述步骤中只是创建了 Window 实例， 只是将 View 添加到 DecorView ，但是真正的 Window 的添加还未实现，而具体的实现在之前说过是由 WindowManager 进行操作的，这一步在 hanldeResumeActivity 中。12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 在 WindowManager 的 addView 方法中就会见到之前说的几个对象的层层调用，一直到 ViewRootImpl， 这个过程如图所示：在 ViewRootImpl 会先调用 requestLayout 对View 进行绘制，然后调用 addToDisplay 添加到 Window 中。这两个方法都涉及与 WMS 的通信，具体则是由 WindowSession 实现，下面就介绍 Window 创建过程中和 WMS 的通信的部分。 (三).在 SystemServer 进程涉及的几个类1.WindowManagerServerWindowManagerServer 是 Android 系统中负责处理 Window 和 View 相关的 系统服务，主要有如下几个职责： 对所有的 Window 进行添加，删除等管理。这部分主要涉及 DisplayContent，WindowToken 和 WindowState 这几个对象。 对View 进行绘制，这里需要为每个窗口分配 Surface 一个 Surface 就是一个对象，该对象持有一群像素（pixels），这些像素是要被组合到一起显示到屏幕上的。每一个 window 都有唯一一个自己的 surface，window 将自己的内容绘制到该 surface 中。 Surface Flinger 根据各个 surface 在 Z 轴上的顺序 （Z-order） 将它们渲染到最终的显示屏上,z 轴就是以屏幕为平面，由里到外的一个轴向，而屏幕就是 x 和 y 轴组成的平面。 对从输入系统 InputManagerService 传过来的触摸事件寻找合适的窗口进行处理。 对 Window 的动画效果的管理，这主要是由 WindowAnimator 对象进行管理。 2.WindowState用于保存窗口的信息，窗口的信息是可以随时改变的，比如窗口的位置，大小等变化，通常窗口信息的改变，就会进行相应的 View 的改变。WindowState 是保持在一个 Map 里面，这个 Map 保存着系统所有的窗口。 3.AppWindowToken/WindowTokenAppWindowToken 是 WindowToken 的 子类，可以译为令牌，一个 Activity 对应一个 WindowToken, 当应用进程向 WMS 发出创建 Window 的申请的时候需要出示正确的令牌。这里需要注意子窗口通常需要依赖于父窗口才能添加，比如在 Activity 上显示 Dialog 或者 Menu ,因此子窗口通常使用的是父窗口的 WindowToken ，这就是为什么创建 Dialog 的时候关联的上下文不能使用 ApplicationContext ,因为 application 没有 WindowToken. (四).创建 Window ( 在 Server 进程 )在了解了服务端几个类后，下面就是 Window 的创建在 Server 端的过程，首先回到之前的在 ViewRootImpl 的两个方法，requestLayout 方法调用后在 SystemServer 会进行一个 Surface 的创建和绘制，之后就会 view 的绘制。这里属于 Surface 的创建过程，这里就不进行展开，在绘制完成后就会执行 addWindow 方法.addWindow 的源码很长，主要是做一下几个部分：1.对窗口的参数进行检查，比如窗口的类型，窗口的 WindowToken.输入法这种没有 WindowToken 的系统自己会创建一个 windowToken。2.创建 WindowState 对象，将 WindowToken 和 WindowState 关联起来并添加到 HashMap。3.将窗口按照 z 轴的位置添加到 DisPlayContent 的合适的位置。.最后就是窗口的位置，动画等信息保存下来。这样一个窗口创建成功。 (五).Dialog 的 Window 创建Dialog 是一个子窗口，需要依赖于父窗口才能显示。12345678910Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; ... mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; ... w.setWindowManager(mWindowManager, null, null); &#125; 123456789@Override public Object getSystemService(@ServiceName @NonNull String name) &#123; if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; &#125; return super.getSystemService(name); &#125; Dialog 会创建自己的 Window 对象，然后就会在 Activity 的 getSystemService 方法中可以拿到 Activity 的 mWindowManager 对象,这样 Dialog 就会和 Activity 有一样的 Token 。接着看 show 方法。 1234567public void show() &#123; ... mDecor = mWindow.getDecorView(); ... mWindowManager.addView(mDecor, l);&#125; 之前说过所有的 Window 都有一个“根视图”用于对 所有的View 进行管理，在 Dialog 中就对应 mDecor，可以看到同样的，mWindowManager 会调用 addView 执行窗口的添加工作。 后面的过程基本和上述的 setContentView 的过程相似。 (六).Toast 的 Window 创建Toast 是一个系统级的窗口，因此在创建的过程中就有些不同。这里涉及到了几个新的对象 (1)涉及的几个对象1.NotificationManagerService ( NMS )这是一个系统服务，用于管理系统通知，因此也负责 Toast 的管理，其中有几个重要的成员 ArrayList mToastQueue ，这是保存系统中所有 Toast 的队列，每个非系统应用的 Toast 在这个队列的数量不能超过 50 个，这样做是避免网络攻击。 拒绝服务攻击 简称：DoS，也叫洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 WorkerHandler 用于处理 Toast 的显示时间，即在 Toast 显示过后发送一个 延迟的消息进行取消。 1. TN这是 Toast 的内部类，继承自 ITransientNotification.Stub ,因此可以跨进程通信，用于处理 Toast 窗口的创建和 View 的添加。 (2)Toast 的 Window 创建过程首先看 makeText 方法 123456789101112131415public static Toast makeText(@NonNull Context context, @Nullable Looper looper, @NonNull CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context, looper); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result;&#125; 这里的 mNextView 就是 Toast “根视图”，可以看到这个 mNextView 有一个 TextView 用于显示 Toast 的文本信息。 接着看 show 方法 12345678910111213public void show() &#123; ... INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 在 Toast 方法中会调用 NMS 的 enqueueToast ，这就到 NMS 服务中。在 NMS 服务中会将 Toast 封装为 ToastRecord ,并添加到 mToastQueue 队列中。一直到 从队列中取出进行显示的时候就会调用 TN 的 show 方法，并发送一个延迟的消息。12345678@GuardedBy(&quot;mToastQueue&quot;) private void scheduleTimeoutLocked(ToastRecord r) &#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); &#125; SHORT_DELAY = 2 s LONG_DELAY = 3.5 s接着先看 TN 的 show 方法 12345 @Override public void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(SHOW, windowToken).sendToTarget();&#125; 1234567891011mHandler = new Handler(looper, null) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SHOW: &#123; IBinder token = (IBinder) msg.obj; handleShow(token); break; &#125;... 1234567891011 public void handleShow(IBinder windowToken) &#123; ... mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); ... mWM.addView(mView, mParams); ... &#125; catch (WindowManager.BadTokenException e) &#123; /* ignore */ &#125; &#125;&#125; 依次从三个方法看下来就可以知道 TN 的 show 最后会调用 WindowManager 的 addView 方法，这里可以看到 为了调用 handleShow 方法这里使用了 Handler 。这是因为 NMS 调用 TN 的方法是一种跨跨进程的方式，show 方法就运行在 Binder 线程池中，因此需要使用 Handler 回到 Toast 的线程去调用 addView 方法。现在回到 NMS 中，之前发送了个延迟的消息，然后过了相应的时间后就会对这个消息进行处理，也就是将 Toast 窗口删除。 12345678910@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_TIMEOUT: handleTimeout((ToastRecord)msg.obj); //跳到下面 ... &#125; &#125; 12345678910private void handleTimeout(ToastRecord record)&#123; if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) &#123; int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) &#123; cancelToastLocked(index);//跳到下面 &#125; &#125;&#125; 123456789101112131415161718@GuardedBy(&quot;mToastQueue&quot;) void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide(); // 执行 hide &#125; catch (RemoteException e) &#123; ... &#125; ToastRecord lastToast = mToastQueue.remove(index);//移除队列 mWindowManagerInternal.removeWindowToken(lastToast.token, true, DEFAULT_DISPLAY);//删除对应 窗口 keepProcessAliveIfNeededLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; ... showNextToastLocked(); // 如果队列中还有就继续执行 &#125; &#125; 在延迟的消息到达后就会执行 hide 方法，这个过程和添加实际上是相似的，这里就不再说明。接着将 Toast 从队列中删除，并进行窗口的删除，接着判断队列中是否还有 Toast ，如果就继续执行。具体的过程可看下图：点击查看大图最后再补充一点，前面提到过 为了使 TN 的 show 方法切换到 对应的线程而使用了 Hanler ,而其中 Handler 的 Looper 是这样的12345678if (looper == null) &#123; // Use Looper.myLooper() if looper is not specified. looper = Looper.myLooper(); if (looper == null) &#123; throw new RuntimeException( &quot;Can&apos;t toast on a thread that has not called Looper.prepare()&quot;); &#125; &#125; 这就说明当不指定 looper 的时候，默认的是主线程 Looper 。但是如果在 子线程中指定该线程的 Looper ，并调用 Looper.prepare() 方法，就可以在子线程中调用 Toast 的 show 方法。参考《Android 开发艺术探索》 Android解析WindowManager Android解析WindowManagerService]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
</search>
