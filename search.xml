<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android----onSaveInstanceState 的数据存在哪里？为什么限制了大小？]]></title>
    <url>%2F2019%2F03%2F29%2FAndroid-onSaveInstanceState-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%E4%BA%86%E5%A4%A7%E5%B0%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一.问题来源对于 Activity 的 onSaveInstanceState 方法大家都不会陌生,当 Activity 在不正常销毁的情况下,就会调用 onSaveInstanceState 方法，并将 Activity 中需要保存的数据（比如 View 状态 或者我们自己的数据）保存到这个方法的参数 Bundle 中。 但是在实际使用的时候你可能会发现当保存的数据过大的时候就会看到如下的 log 日志1javabinder !!! FAILED BINDER TRANSACTION !!! 甚至可能发生异常(在高版本下会抛出异常,低版本直接打印日志)1android.os.TransactionTooLargeException 上面的信息都是表示 Bundle 传输的数据过大,那么问题来了, onSaveInstanceState 中 Bundle 的数据是存放在哪里，为什么又限制？ 二.解决问题的过程1.官网在官网 有关于 Parcelables and Bundles 的一段介绍，其中就有提到 Bundles 的数据大小问题。 翻译一下： Binder 传输缓冲区是一个限制的大小的区域，大小为 1MB,这块缓冲区用于所有进程间的通信，也就是 Binder 通信。这些传输包括 onSaveInstanceState , startActivity 和其他与系统的交互，当传输的数据超过这个大小的时候就会抛出异常。 特别是 onSaveInstanceState 方法，因其需要在 Activity 返回的时候提供数据，官网建议是数据大小不大于 50K. 关于 startActivity 和其他系统交互需要使用 Binder 进行跨进程通信我们知道，但是你可能就有疑问 onSaveInstanceState 不是在自己进程中做 Activity 某些状态的保存，为什么需要 Binder 呢？ 关于 Binder 机制中 Binder 缓冲区的限制，网上有很多文章，这里就不进行说明了。 2.系统源码追踪ActivityThread在追 onSaveInstanceState 的方法源码的时候，想要找到关于 Binder 方面的内容，就顺着Activity 的方法追，很多人都是到 Application 的 接口中就迷路了.123456789public interface ActivityLifecycleCallbacks &#123; void onActivityCreated(Activity activity, Bundle savedInstanceState); void onActivityStarted(Activity activity); void onActivityResumed(Activity activity); void onActivityPaused(Activity activity); void onActivityStopped(Activity activity); void onActivitySaveInstanceState(Activity activity, Bundle outState); void onActivityDestroyed(Activity activity); &#125; 其实这是一个错误的方向，其实只要想到 onSaveInstanceState 有点类似于 Activity 中其他生命周期的方法，就可以发现 onSaveInstanceState 最开始也是有 ActivityThread 做统一管理的，那么 onSaveInstanceState 的调用 也就和 ActivityThread 有关。 Bundle 的创建在 ActivityThread 的源码中可以看到有这么个方法1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125; &#125; 其中最后调用了 mInstrumentation.callActivityOnSaveInstanceState那么就到 mInstrumentation 类中查找1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) &#123; activity.performSaveInstanceState(outState, outPersistentState); &#125; 这个方法中又调用了 activity.performSaveInstanceState 的方法 123456789101112final void performSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123; onSaveInstanceState(outState, outPersistentState); saveManagedDialogs(outState); storeHasCurrentPermissionRequest(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState + &quot;, &quot; + outPersistentState); &#125; ... public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) &#123; onSaveInstanceState(outState); &#125; 最后调用的是 Activity onSaveInstanceState 方法 ,显然 callCallActivityOnSaveInstanceState 的 r.state 就是 onSaveInstanceState 的方法的中的参数 Bundle .而 r 就是 ActivityThread 的内部类 ActivityClientRecord123456789static final class ActivityClientRecord &#123; IBinder token; int ident; Intent intent; String referrer; IVoiceInteractor voiceInteractor; Bundle state; // 这个就是 r.state 也就是 onSaveInstanceState 的 Bundle &#125; 到这里我们知道 Bundle 是怎样创建的，但是关于 Binder 传输的问题，这里也没有体现，那么究竟是在哪里涉及的 Binder 传输的呢？ onSaveInstanceState 调用时机这里先补充一个点就是 onSaveInstanceState 的方法的调用时机1234567891011121314151617181920212223* &lt;p&gt;If called, this method will occur before &#123;@link #onStop&#125;. There are * no guarantees about whether it will occur before or after &#123;@link #onPause&#125;. * * @param outState Bundle in which to place your saved state. * * @see #onCreate * @see #onRestoreInstanceState * @see #onPause */ protected void onSaveInstanceState(Bundle outState) &#123; outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; if (mAutoFillResetNeeded) &#123; outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); &#125; getApplication().dispatchActivitySaveInstanceState(this, outState); &#125; 从注释中可以看到这个方法的调用会在 onStop 前，那么我们就去 ActivityTread 中看看再 onStop 前发生了什么。123456789101112131415161718private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) &#123; ActivityClientRecord r = mActivities.get(token); .... StopInfo info = new StopInfo(); // performStopActivityInner(r, info, show, true, &quot;handleStopActivity&quot;); ... info.activity = r; //注意这里 将 r.state 赋值给 info.state info.state = r.state; info.persistentState = r.persistentState; //然后调用 Handler 的 post 方法将这个 StopInfo 类传递给消息队列 mH.post(info); mSomeActivitiesChanged = true; &#125; StopInfo 是一个实现了 Runnable 接口的类，且内部也有Bundle 的引用 所以可以 将 ActivityClientRecord 的 Bundle 赋值给 StopInfo 的 Bundle1234567private static class StopInfo implements Runnable &#123; ActivityClientRecord activity; Bundle state; .... &#125; 最后因为 StopInfo 被 Handle post 之后，那么就会执行其相应的 run 方法。1234567891011121314151617181920212223private static class StopInfo implements Runnable &#123; ActivityClientRecord activity; Bundle state; PersistableBundle persistentState; CharSequence description; @Override public void run() &#123; // Tell activity manager we have been stopped. try &#123; //注意到这里将 state 作为参数调用了 ActivityManager.getService() 方法。 ActivityManager.getService().activityStopped( activity.token, state, persistentState, description); &#125; catch (RemoteException ex) &#123; if (ex instanceof TransactionTooLargeException &amp;&amp; activity.loadedApk.getTargetSdkVersion() &lt; Build.VERSION_CODES.N) &#123; Log.e(TAG, &quot;App sent too much data in instance state, so it was ignored&quot;, ex); return; &#125; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; 到这里就可以明白了 onSaveInstanceState 中保存的 Bundle 信息是存在内存中的，且因为是涉及到 Activity 的状态的保存，就需要交由 ActivityManager 进程去做一个管理，所以就需要 Binder 传输做一个跨进程的通信将 Bundle 的数据传递给 ActivityManager。因此 onSaveInstanceState 也涉及到了 Binder 传输，自然而然就受到 Binder 缓冲区大小的限制，到这里问题就解决了。]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----分析ANR]]></title>
    <url>%2F2019%2F03%2F14%2FAndroid-%E5%88%86%E6%9E%90ANR%2F</url>
    <content type="text"><![CDATA[一.前言ANR 是 Android 开发中会遇到的一个经典问题，但是如果不是自己遇到 ANR 并实现解决是很难对 ANR 有深入的体会的，所以本文就产生 ANR 到如何定位做一个详细的记录。 二.产生 ANRANR 产生的原因无非就三种，网上也有很多介绍，这里就简单提及： Input dispatching timed out ： Activity 输入分发（即触摸响应超时） 5s Broadcast Timeout：广播 onReceiver 方法执行超时 10 s Service Timeout: 服务的 主线程方法执行超时 20s 简单的总结就是在主线程做超时的任务，下面就模拟一个在主线程休眠引发 ANR 的场景1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_anr).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; Thread.sleep(20_000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 当重复点击 Button 的时候就会产生 ANR . 分析 ANR 的途径主要是两个 log 日志 traces.txt 文件 1.log 日志 分析 查看 ANR log 日志的时候，log 过滤规则不能设置为仅限本应用，可以直接设置为 NO Filters ANR 的时候会产生如下的红色日志123456789101112// log 需要设置过滤规则为 No Filters03-14 19:52:05.513 1448-1527/? E/ActivityManager://ANR 的主线程的组件ANR in piratehat.appstore (piratehat.appstore/piratehat.httpClient.MainActivity)//进程的 ID PID: 30106//ANR 的种类和原因，这里是 Input dispatching timed out Reason: Input dispatching timed out (piratehat.appstore/piratehat.httpClient.HttpTestActivity, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago. Wait queue length: 2. Wait queue head age: 11632.7ms.) Load: 2.95 / 2.29 / 2.54 CPU usage from 51546ms to 0ms ago: ...// 省略内核中的一些信息 从 log 日志中就可以看出关于 ANR 的几个信息： 发生 ANR 的主线程的组件 进程的 ID ANR 的种类和原因 有这么几个信息还不足以定位到 ANR 的地方和具体的原因，因此还需要另一种途径，分析 traces.txt 文件 2.traces.txt 文件 分析发生 ANR 除了有上面的 log 之外，还有下面针对 本应用的 log(可以设置 Show only selected application 查看)1//03-14 19:52:01.934 30106-30111/piratehat.appstore I/art: Wrote stack traces to &apos;/data/anr/traces.txt&apos; 每一次产生 ANR 的时候，Android 虚拟机就会 dump 出当前进程所有线程信息并存储到 traces.txt 这个文件。 那么怎么获取到这个文件呢？网上有很多方式 dump 当前进程的 traces.txt，但是都行不通，最后自己 dump 出所有再去找到自己应用的。只要在 Terminal 命令输入窗口输入 adb pull data/anr 即可导出所有的 anr traces.txt 文件夹到 对应的目录下（这里是 AppStore 目录）然后找到属于自己应用的 traces.txt 文件 这个文件中可能会包含有其他进程的一些信息. 首先知道几个标识 PID :进程 ID TID :线程 ID , 1 为 主线程 UID :用户 ID , 0 为 root 权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214----- pid 30106 at 2019-03-14 19:52:01 -----Cmd line: piratehat.appstoreBuild fingerprint: &apos;Xiaomi/land/land:6.0.1/MMB29M/V9.5.4.0.MALCNFA:user/release-keys&apos;ABI: &apos;arm64&apos;Build type: optimizedZygote loaded classes=4192 post zygote classes=427Intern table: 55033 strong; 16 weakJNI: CheckJNI is on; globals=419 (plus 218 weak)Libraries: /data/app/piratehat.appstore-2/lib/arm64/libsupportjni.so /system/lib64/libandroid.so /system/lib64/libcompiler_rt.so /system/lib64/libjavacrypto.so /system/lib64/libjnigraphics.so /system/lib64/libmedia_jni.so /system/lib64/libmiuiclassproxy.so /system/lib64/libmiuinative.so /system/lib64/libqti_performance.so /system/lib64/libwebviewchromium_loader.so libjavacore.so (11)suspend all histogram: Sum: 147us 99% C.I. 1us-8us Avg: 3.195us Max: 8usDALVIK THREADS (21):&quot;Signal Catcher&quot; daemon prio=5 tid=2 Runnable | group=&quot;system&quot; sCount=0 dsCount=0 obj=0x12cae0a0 self=0x55a1e9ded0 | sysTid=30111 nice=0 cgrp=default sched=0/0 handle=0x7fa6e82450 | state=R schedstat=( 22837912 5312140 66 ) utm=2 stm=0 core=4 HZ=100 | stack=0x7fa6d86000-0x7fa6d88000 stackSize=1013KB | held mutexes= &quot;mutator lock&quot;(shared held) ....//这里省略一些 信息，下面也是一样 (no managed stack frames)&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x7542afb8 self=0x55a1dbb930 | sysTid=30106 nice=0 cgrp=default sched=1073741825/1 handle=0x7fab053fc8 | state=S schedstat=( 920246246 7424173 385 ) utm=73 stm=19 core=5 HZ=100 | stack=0x7fc946a000-0x7fc946c000 stackSize=8MB | held mutexes= &quot;JDWP&quot; daemon prio=5 tid=3 WaitingInMainDebuggerLoop | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12cb90a0 self=0x55a2088380 | sysTid=30112 nice=0 cgrp=default sched=0/0 handle=0x7fa6d7c450 | state=S schedstat=( 2740050 224427 9 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7fa6c80000-0x7fa6c82000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;ReferenceQueueDaemon&quot; daemon prio=5 tid=4 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12ca94c0 self=0x55a207b6b0 | sysTid=30113 nice=0 cgrp=default sched=0/0 handle=0x7fa6c74450 | state=S schedstat=( 730157 66354 11 ) utm=0 stm=0 core=1 HZ=100 | stack=0x7fa6b72000-0x7fa6b74000 stackSize=1037KB | held mutexes= &quot;FinalizerDaemon&quot; daemon prio=5 tid=5 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12ca9520 self=0x55a2236170 | sysTid=30114 nice=0 cgrp=default sched=0/0 handle=0x7fa6b68450 | state=S schedstat=( 1202655 63333 14 ) utm=0 stm=0 core=2 HZ=100 | stack=0x7fa6a66000-0x7fa6a68000 stackSize=1037KB | held mutexes= &quot;FinalizerWatchdogDaemon&quot; daemon prio=5 tid=6 Waiting | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12ca9580 self=0x55a22369c0 | sysTid=30115 nice=0 cgrp=default sched=0/0 handle=0x7fa6a5c450 | state=S schedstat=( 964737 0 6 ) utm=0 stm=0 core=4 HZ=100 | stack=0x7fa695a000-0x7fa695c000 stackSize=1037KB | held mutexes= &quot;HeapTaskDaemon&quot; daemon prio=5 tid=7 Blocked | group=&quot;system&quot; sCount=1 dsCount=0 obj=0x12ca95e0 self=0x55a2237210 | sysTid=30116 nice=0 cgrp=default sched=0/0 handle=0x7fa6950450 | state=S schedstat=( 943231 0 7 ) utm=0 stm=0 core=6 HZ=100 | stack=0x7fa684e000-0x7fa6850000 stackSize=1037KB | held mutexes= &quot;Binder:30106_1&quot; prio=5 tid=8 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12cbf0a0 self=0x55a2238a10 | sysTid=30117 nice=0 cgrp=default sched=0/0 handle=0x7fa6748450 | state=S schedstat=( 7228229 6658334 40 ) utm=0 stm=0 core=7 HZ=100 | stack=0x7fa664c000-0x7fa664e000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;Binder:30106_2&quot; prio=5 tid=9 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12cc30a0 self=0x55a2239260 | sysTid=30118 nice=0 cgrp=default sched=0/0 handle=0x7fa6642450 | state=S schedstat=( 6283645 7792968 39 ) utm=0 stm=0 core=7 HZ=100 | stack=0x7fa6546000-0x7fa6548000 stackSize=1013KB | held mutexes= &quot;FileObserver&quot; prio=5 tid=10 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12ce3340 self=0x55a1f00ba0 | sysTid=30119 nice=0 cgrp=default sched=0/0 handle=0x7fa21fd450 | state=S schedstat=( 494896 0 2 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7fa20fb000-0x7fa20fd000 stackSize=1037KB | held mutexes= &quot;Binder:30106_3&quot; prio=5 tid=11 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12d450a0 self=0x55a2249010 | sysTid=30124 nice=0 cgrp=default sched=0/0 handle=0x7fa20f8450 | state=S schedstat=( 4480311 4345883 32 ) utm=0 stm=0 core=6 HZ=100 | stack=0x7fa1ffc000-0x7fa1ffe000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;Binder:30106_4&quot; prio=5 tid=12 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12d4c0a0 self=0x55a224a6f0 | sysTid=30127 nice=0 cgrp=default sched=0/0 handle=0x7fa1ff9450 | state=S schedstat=( 4391355 18013748 31 ) utm=0 stm=0 core=6 HZ=100 | stack=0x7fa1efd000-0x7fa1eff000 stackSize=1013KB | held mutexes= ) native: #10 pc 000000000001c644 /system/lib64/libc.so (__start_thread+16) (no managed stack frames)&quot;Binder:30106_5&quot; prio=5 tid=13 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12d500a0 self=0x55a224ba60 | sysTid=30130 nice=0 cgrp=default sched=0/0 handle=0x7f9423e450 | state=S schedstat=( 3941615 3599219 32 ) utm=0 stm=0 core=7 HZ=100 | stack=0x7f94142000-0x7f94144000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;Binder:30106_6&quot; prio=5 tid=14 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12cae100 self=0x55a1f013f0 | sysTid=30151 nice=0 cgrp=default sched=0/0 handle=0x7f93cc3450 | state=S schedstat=( 3181774 4945416 16 ) utm=0 stm=0 core=5 HZ=100 | stack=0x7f93bc7000-0x7f93bc9000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;Thread-47826&quot; prio=5 tid=16 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12ca91c0 self=0x55a2259ac0 | sysTid=30156 nice=0 cgrp=default sched=0/0 handle=0x7f938b1450 | state=S schedstat=( 2956969195 115115680 18859 ) utm=207 stm=88 core=5 HZ=100 | stack=0x7f937af000-0x7f937b1000 stackSize=1037KB | held mutexes= &quot;Studio:VmStats&quot; prio=5 tid=17 TimedWaiting | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12ca9220 self=0x55a2263f80 | sysTid=30157 nice=0 cgrp=default sched=0/0 handle=0x7f937a5450 | state=S schedstat=( 2314347878 48209793 7588 ) utm=203 stm=28 core=4 HZ=100 | stack=0x7f936a3000-0x7f936a5000 stackSize=1037KB | held mutexes= &quot;RenderThread&quot; prio=5 tid=19 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12f6a0a0 self=0x55a1eb9dd0 | sysTid=30161 nice=-4 cgrp=default sched=1073741825/1 handle=0x7f9354f450 | state=S schedstat=( 301889746 26133758 324 ) utm=16 stm=14 core=6 HZ=100 | stack=0x7f93453000-0x7f93455000 stackSize=1013KB (no managed stack frames)&quot;hwuiTask1&quot; prio=5 tid=20 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12f830a0 self=0x55a24701a0 | sysTid=30162 nice=-2 cgrp=default sched=0/0 handle=0x7f933a9450 | state=S schedstat=( 10214478 14752295 67 ) utm=1 stm=0 core=7 HZ=100 | stack=0x7f932ad000-0x7f932af000 stackSize=1013KB | held mutexes=&quot;hwuiTask2&quot; prio=5 tid=21 Native | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x12f870a0 self=0x55a246d420 | sysTid=30163 nice=-2 cgrp=default sched=0/0 handle=0x7f932a5450 | state=S schedstat=( 834375 116302 6 ) utm=0 stm=0 core=2 HZ=100 | stack=0x7f931a9000-0x7f931ab000 stackSize=1013KB | held mutexes= (no managed stack frames)&quot;Studio:Agent&quot; prio=5 (not attached) | sysTid=30148 nice=0 cgrp=default | state=S schedstat=( 7029339016 4208610113 69915 ) utm=214 stm=488 core=7 HZ=100 &quot;Studio:Heartbea&quot; prio=5 (not attached) | sysTid=30153 nice=0 cgrp=default | state=S schedstat=( 6660169473 4244203001 68400 ) utm=238 stm=428 core=6 HZ=100 ----- end 30106 ---------- pid 2256 at 2019-03-14 19:52:02 -----Cmd line: com.fingerprints.serviceext----- end 2256 ---------- pid 2378 at 2019-03-14 19:52:01 -----Cmd line: com.android.phone----- end 2378 ---------- pid 443 at 2019-03-14 19:52:02 -----Cmd line: /system/bin/surfaceflingerABI: &apos;arm64&apos;&quot;surfaceflinger&quot; sysTid=443 #00 pc 0000000000069c54 /system/lib64/libc.so (__epoll_pwait+8) #01 pc 000000000001cca4 /system/lib64/libc.so (epoll_pwait+32) #02 pc 000000000001be88 /system/lib64/libutils.so (_ZN7android6Looper9pollInnerEi+144) #03 pc 000000000001c268 /system/lib64/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+80) #04 pc 000000000002d6d4 /system/lib64/libsurfaceflinger.so #05 pc 0000000000030c48 /system/lib64/libsurfaceflinger.so (_ZN7android14SurfaceFlinger3runEv+20) #06 pc 0000000000001190 /system/bin/surfaceflinger #07 pc 000000000001976c /system/lib64/libc.so (__libc_init+100) #08 pc 0000000000000fcc /system/bin/surfaceflinger&quot;Binder:443_1&quot; sysTid=507 从上面的信息可以看到一个 traces.txt 包含了多个进程的信息。每个进程的信息又包含了其有的线程的信息，比如上面最后一个就是 surfaceflinger 进程的信息。 那么如何找到自己的应用的进程呢？因为每个进程都有自己的进程 ID ,(即 PID )，而在第一种 log 日志分析中已经知道我们的进程 ID 为 30106 ，因此全局搜索 30106 可以找到属于我们进程的 信息。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106----- pid 30106 at 2019-03-14 19:52:01 -----Cmd line: piratehat.appstoreBuild fingerprint: &apos;Xiaomi/land/land:6.0.1/MMB29M/V9.5.4.0.MALCNFA:user/release-keys&apos;ABI: &apos;arm64&apos;Build type: optimizedZygote loaded classes=4192 post zygote classes=427Intern table: 55033 strong; 16 weakJNI: CheckJNI is on; globals=419 (plus 218 weak)Libraries: /data/app/piratehat.appstore-2/lib/arm64/libsupportjni.so /system/lib64/libandroid.so /system/lib64/libcompiler_rt.so /system/lib64/libjavacrypto.so /system/lib64/libjnigraphics.so /system/lib64/libmedia_jni.so /system/lib64/libmiuiclassproxy.so /system/lib64/libmiuinative.so /system/lib64/libqti_performance.so /system/lib64/libwebviewchromium_loader.so libjavacore.so (11)suspend all histogram: Sum: 147us 99% C.I. 1us-8us Avg: 3.195us Max: 8usDALVIK THREADS (21):&quot;Signal Catcher&quot; daemon prio=5 tid=2 Runnable | group=&quot;system&quot; sCount=0 dsCount=0 obj=0x12cae0a0 self=0x55a1e9ded0 | sysTid=30111 nice=0 cgrp=default sched=0/0 handle=0x7fa6e82450 | state=R schedstat=( 22837912 5312140 66 ) utm=2 stm=0 core=4 HZ=100 | stack=0x7fa6d86000-0x7fa6d88000 stackSize=1013KB | held mutexes= &quot;mutator lock&quot;(shared held) ....//这里省略一些 信息，下面也是一样 (no managed stack frames)// “main” ：线程名字// prio ： 线程优先级// tid ：线程&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x7542afb8 self=0x55a1dbb930 | sysTid=30106 nice=0 cgrp=default sched=1073741825/1 handle=0x7fab053fc8 | state=S schedstat=( 920246246 7424173 385 ) utm=73 stm=19 core=5 HZ=100 | stack=0x7fc946a000-0x7fc946c000 stackSize=8MB | held mutexes= //这是一个守护线程&quot;JDWP&quot; daemon prio=5 tid=3 WaitingInMainDebuggerLoop ... (no managed stack frames)//这是一个守护线程&quot;ReferenceQueueDaemon&quot; daemon prio=5 tid=4 Waiting ... //这是一个守护线程&quot;FinalizerDaemon&quot; daemon prio=5 tid=5 Waiting ... //这是一个守护线程&quot;FinalizerWatchdogDaemon&quot; daemon prio=5 tid=6 Waiting ... //这是一个守护线程&quot;HeapTaskDaemon&quot; daemon prio=5 tid=7 Blocked ... //这是一个 Binder 线程&quot;Binder:30106_1&quot; prio=5 tid=8 Native ... (no managed stack frames)//这是一个 Binder 线程&quot;Binder:30106_2&quot; prio=5 tid=9 Native ... &quot;FileObserver&quot; prio=5 tid=10 Native ...//这是一个 Binder 线程&quot;Binder:30106_3&quot; prio=5 tid=11 Native ... (no managed stack frames)//这是一个 Binder 线程&quot;Binder:30106_4&quot; prio=5 tid=12 Native ...//这是一个 Binder 线程&quot;Binder:30106_5&quot; prio=5 tid=13 Native ... (no managed stack frames)//这是一个 Binder 线程&quot;Binder:30106_6&quot; prio=5 tid=14 Native ...&quot;Thread-47826&quot; prio=5 tid=16 Sleeping ... &quot;Studio:VmStats&quot; prio=5 tid=17 TimedWaiting ... &quot;RenderThread&quot; prio=5 tid=19 Native ...&quot;hwuiTask1&quot; prio=5 tid=20 Native ...&quot;hwuiTask2&quot; prio=5 tid=21 Native ... (no managed stack frames)&quot;Studio:Agent&quot; prio=5 (not attached) ...&quot;Studio:Heartbea&quot; prio=5 (not attached) ... ----- end 30106 ----- 因为发生 ANR 的情况是在主线程中，所以 tid = 1 ,看主线程中的信息的123456789101112131415161718192021&quot;main&quot; prio=5 tid=1 Sleeping | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x7542afb8 self=0x55a1dbb930 | sysTid=30106 nice=0 cgrp=default sched=1073741825/1 handle=0x7fab053fc8 | state=S schedstat=( 920246246 7424173 385 ) utm=73 stm=19 core=5 HZ=100 | stack=0x7fc946a000-0x7fc946c000 stackSize=8MB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on &lt;0x0735c84c&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked &lt;0x0735c84c&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at piratehat.httpClient.HttpTestActivity$1.onClick(HttpTestActivity.java:27) at android.view.View.performClick(View.java:5215) at android.view.View$PerformClick.run(View.java:21193) at android.os.Handler.handleCallback(Handler.java:742) at android.os.Handler.dispatchMessage(Handler.java:95) at android.os.Looper.loop(Looper.java:157) at android.app.ActivityThread.main(ActivityThread.java:5571) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:745) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:635) 就可以看到主线程中 ANR 的原因是因为 调用了 Sleep 方法，具体在 onClick 方法中，至此就找到了 ANR 的位置。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP响应gzip+chunked分段压缩流的解压缩（java）]]></title>
    <url>%2F2019%2F02%2F21%2FHTTP%E5%93%8D%E5%BA%94gzip-chunked%E5%88%86%E6%AE%B5%E5%8E%8B%E7%BC%A9%E6%B5%81%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9%EF%BC%88java%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一.问题阐述最近做项目的时候遇到这么一个问题： 用 原生 Socket 进行 HTTP 请求的时候,添加了请求头1Accept-Encoding: gzip 这个请求头表示的含义就是:返回的数据中会对响应体进行压缩,响应头不进行压缩（HTTP/1.1版） 如果服务器支持这种格式的压缩，那么返回的数据会如下这种格式123456789// 响应头不会压缩 HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Encoding: gzipContent-Type: text/html;charset=UTF-8Date: Wed, 20 Feb 2019 06:19:04 GMT// 响应体会进压缩xxxxxxxxxx 服务器压缩的方式可能如下123456789101112131415public static byte[] compress(String str, String encoding) &#123; if (str == null || str.length() == 0) &#123; return null; &#125; ByteArrayOutputStream out = new ByteArrayOutputStream(); GZIPOutputStream gzip; try &#123; gzip = new GZIPOutputStream(out); gzip.write(str.getBytes(encoding));//将字符串转为字节数组，对字节数组进行压缩 gzip.close(); &#125; catch (IOException e) &#123; &#125; return out.toByteArray();//返回压缩后的字节流&#125; 正常情况下,如果请求头包含 gzip,响应时这种方式返回,那么在客户端接收到这种压缩的字节流，只有用同样的压缩流进行解压处理就可以得到数据,并且通常响应头都会包含如下的相应头12Content-Encoding: gzipContent-Length: 13131 这表示返回的响应体是 gzip 格式的，并且字节流长度为 13131 一般情况是这样 但是在这样一种情况,如果返回的数据很大,或者数据量不确定（如一些动态网页）,这个时候服务器就会选择对数据进行分段,并用一个16进制的数进行划分,表示一段的长度,如12345678910111213HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Encoding: gzipContent-Type: text/html;charset=UTF-8Transfer-Encoding: chunked // 分段的数据就会返回这个响应头Date: Wed, 20 Feb 2019 06:19:04 GMTa3 // 16进制 xxxxx5d9fxxxxx0 // 以 0 为结尾 这就使得响应头包含 gzip 和 chunked 的数据是一段经过分段的压缩流,因此也就不能简单地使用 GZIPInputStream 对数据进行处理 二.解决方法 对返回的字节流进行一个代理处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135public class SegmentInputStream extends InputStream &#123; private InputStream mInputStream; //需要处理的字节流 private HashMap&lt;String, String&gt; mHeaders; //响应头 private boolean mChunked; //分段的标识 private boolean mIsData; private boolean mEnd; //读取到末尾的标志 即读取到长度为 0 private long mReadLength = 0L;//当前读取到的长度 private long mSegmentLength = -1L; //分段时，每一段的长度 public final boolean DEBUG = true; public SegmentInputStream(InputStream inputStream) throws IOException &#123; mInputStream = inputStream; mHeaders = new HashMap&lt;&gt;(); mChunked = false; mIsData = false; mEnd = false; parseHeaders(); //在构造函数的时候就先将响应头解析，因为其没有压缩 &#125; public HashMap&lt;String, String&gt; getHeaders() &#123; return mHeaders; &#125; //重写read 方法，每次读的时候跳过分段的16 进制数字 @Override public int read() throws IOException &#123; return !mChunked ? mInputStream.read() : readChunked(); &#125; private int readChunked() throws IOException &#123; if (mEnd) &#123; return -1; &#125; int byteCode; if (mIsData) &#123; byteCode = mInputStream.read(); mReadLength++; if (mReadLength == mSegmentLength) &#123; mIsData = false; mReadLength = 0L; mSegmentLength = -1L; &#125; &#125; // &lt;&lt; 数据的部分读取完毕 else &#123; int endTag = 0;//回车字符标识 一个 /n/r 就是一个回车 byte[] buffer = new byte[1]; ArrayList&lt;Byte&gt; bytes = new ArrayList&lt;&gt;(); while ((byteCode = mInputStream.read()) != -1) &#123; buffer[0] = (byte) byteCode;// 因为read(x,x,x) // 最后会调用read 所以是一个递归，会栈溢出 if (buffer[0] != &apos;\r&apos; &amp;&amp; buffer[0] != &apos;\n&apos;) &#123; bytes.add(buffer[0]); endTag = 0; &#125; else &#123;/* (buffer[0] == &apos;\n&apos; || buffer[0] == &apos;\r&apos;)*/ endTag++; if (endTag == 2 &amp;&amp; bytes.size() != 0) &#123;//四个字符就是有两个回车符，响应头就终止 byte[] resultByte = new byte[bytes.size()]; for (int i = 0; i &lt; resultByte.length; i++) &#123; resultByte[i] = bytes.get(i); &#125; String resultStr = new String(resultByte); mSegmentLength = Integer.parseInt(resultStr.trim(), 16); mEnd = mSegmentLength == 0; mIsData = true; break; &#125; &#125; &#125;//每次处理完成 长度数字后 都 要返回一个 data if (mIsData) &#123; if (mEnd) &#123; return -1; &#125; byteCode = mInputStream.read(); mReadLength++; if (mReadLength == mSegmentLength) &#123; mIsData = false; mReadLength = 0L; mSegmentLength = -1L; &#125; &#125; &#125;// &lt;&lt; 分段的长度读取完毕 return byteCode; &#125; private void parseHeaders() throws IOException &#123; if (mInputStream == null) &#123; return; &#125; int enterCount = 0;//回车字符标识 一个 /n/r 就是一个回车 byte[] buffer = new byte[1]; ArrayList&lt;Byte&gt; bytes = new ArrayList&lt;&gt;(); while (read(buffer, 0, 1) != -1) &#123; // bytes.add(buffer[0]); if (buffer[0] == &apos;\n&apos; || buffer[0] == &apos;\r&apos;) &#123; enterCount++; if (enterCount == 4) &#123; //四个字符就是有两个回车符，响应头就终止 break; &#125; &#125; else &#123; enterCount = 0; &#125; &#125; byte[] resultByte = new byte[bytes.size()]; for (int i = 0; i &lt; resultByte.length; i++) &#123; resultByte[i] = bytes.get(i); &#125; String resultStr = new String(resultByte); String[] headerLines = resultStr.split(&quot;\r\n&quot;); for (String headerLine : headerLines) &#123; String[] header = headerLine.split(&quot;: &quot;); if (header.length == 1) &#123; //HTTP/1.1 200 OK 响应行只有一句 mHeaders.put(&quot;&quot;, header[0].trim()); &#125; else &#123; mHeaders.put(header[0].trim(), header[1].trim()); &#125; &#125; mChunked = mHeaders.containsValue(&quot;chunked&quot;) || mHeaders.containsValue(&quot;CHUNKED&quot;); if (DEBUG) &#123; System.out.println(mHeaders); &#125; &#125;&#125; 详细的处理可以看 AppStore]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 集合----SparseArray 、ArrayMap]]></title>
    <url>%2F2019%2F02%2F16%2FAndroid-%E9%9B%86%E5%90%88-SparseArray-%E3%80%81ArrayMap%2F</url>
    <content type="text"><![CDATA[一.前言SparseArray 和 ArrayMap 是 Android 系统 api 中用于存储键值对数据的集合,相比于 java 集合的 HashMap ,SparseArray 和 ArrayMap 在某些场景下能够以时间换空间策略,带来内存上效率的提升,因此更适合移动设备。 二.SparseArray1.简介12345678910111213141516171819202122232425262728293031/** * SparseArrays map integers to Objects. Unlike a normal array of Objects, * there can be gaps in the indices. It is intended to be more memory efficient * than using a HashMap to map Integers to Objects, both because it avoids * auto-boxing keys and its data structure doesn&apos;t rely on an extra entry object * for each mapping. * * &lt;p&gt;Note that this container keeps its mappings in an array data structure, * using a binary search to find keys. The implementation is not intended to be appropriate for * data structures * that may contain large numbers of items. It is generally slower than a traditional * HashMap, since lookups require a binary search and adds and removes require inserting * and deleting entries in the array. For containers holding up to hundreds of items, * the performance difference is not significant, less than 50%.&lt;/p&gt; * * &lt;p&gt;To help with performance, the container includes an optimization when removing * keys: instead of compacting its array immediately, it leaves the removed entry marked * as deleted. The entry can then be re-used for the same key, or compacted later in * a single garbage collection step of all removed entries. This garbage collection will * need to be performed at any time the array needs to be grown or the the map size or * entry values are retrieved.&lt;/p&gt; * * &lt;p&gt;It is possible to iterate over the items in this container using * &#123;@link #keyAt(int)&#125; and &#123;@link #valueAt(int)&#125;. Iterating over the keys using * &lt;code&gt;keyAt(int)&lt;/code&gt; with ascending values of the index will return the * keys in ascending order, or the values corresponding to the keys in ascending * order in the case of &lt;code&gt;valueAt(int)&lt;/code&gt;.&lt;/p&gt; */ public class SparseArray&lt;E&gt; implements Cloneable &#123; ... &#125; 在源码中对 SparseArray 的介绍就如上面的注释,从中就可以知道以下几点： (1).SparseArray 存储 int -&gt; Objects 映射关系（不是 Integer ）,类似的类还有 SparseBooleanArray ，SparseIntArray ， SparseLongArray ，LongSparseArray。对应的映射关系如下： 类 映射关系 SparseArray int -&gt; Objects SparseBooleanArray int -&gt; boolean SparseIntArray int -&gt; int SparseLongArray int -&gt; long LongSparseArray long -&gt; Objects (2).不像其他的数组结构下标是连续的，它能够允许某些下标不存在，因此称为 SparseArray (稀疏数组),因为避免了自动装拆箱,且不用创建其他的实体（HashMap 需要创建 Entry），因此在内存上有更高的效率。 (3).与 HashMap 中使用 hash 值定位下标的方式不同，SparseArray 使用的是二分查找的方式,因此当有大量数据的时候，SparseArray 的速度将明显慢于 HashMap (4).在删除的元素的时候，SparseArray 不是立即对数组进行压缩（去除数组中为 空的元素），而是使用一个标志，对删除的位置进行标志，只有在数组扩容或者 键值对数量和某个元素需要恢复的时候，才会统一进行压缩。 2.源码123456789101112131415161718192021222324public class SparseArray&lt;E&gt; implements Cloneable &#123; private static final Object DELETED = new Object(); //删除的标志 private boolean mGarbage = false; //压缩标志 private int[] mKeys; //int 类型的数组，存储 key private Object[] mValues; //Object 类型的数组，存储 value private int mSize; // 键值对的数量 //默认构造器，初始化 数量为 10 public SparseArray() &#123; this(10); &#125; //指定数量的构造器 public SparseArray(int initialCapacity) &#123; if (initialCapacity == 0) &#123; mKeys = EmptyArray.INT; mValues = EmptyArray.OBJECT; &#125; else &#123; mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity); mKeys = new int[mValues.length]; &#125; mSize = 0; &#125; 1.put 方法123456public void put(int key, E value) &#123; //先二分查找对应的下标 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); ...&#125; put 方法首先要就要查找对应的需要插入的位置，因为 SparseArray 是一个稀疏数组即可能有这样的情况 （0 ，1 ，3 ，5，6） 因此首先就要找到对应的插入位置。二分查找对应的算法如下123456789101112131415161718static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; final int mid = (lo + hi) &gt;&gt;&gt; 1; final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present &#125; 当查找成功就返回对应的下标，但是查找失败的时候注意最后返回的是 ~lo,而不是简单的 -1, 其实 ~lo 对应的就是需要插入的位置，比如 （0 ，1 ，3 ，5，6）查找 2，返回的就是 -2 ，取反可以将正数转为负数，如果是负数就说明查找失败，比如返回 -2 就说明查找失败，插入的位置为 2 . 接着回到 put 方法。1234567891011121314151617181920212223242526272829303132333435363738public void put(int key, E value) &#123; //使用二分查找 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //i&gt;0 //说明查找成功，直接更新 if (i &gt;= 0) &#123; mValues[i] = value; //查找失败的话 &#125; else &#123; //取反获取对应的插入的位置 i = ~i; //如果下标 小于 元素数量并且之前被标志位删除的话 //重新赋值即可 if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; //否则判断是否需要进行数组压缩 //需要的话就调用 gc 方法进行压缩 //并重新二分查找获取下标 if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; //对数组进行扩容 并复制 //GrowingArrayUtils.insert 使用的是 System.arraycopy mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125; &#125; gc 压缩数组的源码如下123456789101112131415161718192021222324252627private void gc() &#123; // Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize); int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; mGarbage = false; mSize = o; // Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize); &#125; 下一次进行 arrayCopy 的时候多余的 null 就不会进行复制，延迟删除机并一次性压缩就提高了效率。 2.append 方法put 方法是在数组中插入元素，那么 append 对应的就是在数组末尾追加元素12345678910111213141516171819public void append(int key, E value) &#123; //如果 key 小于 存在的key //就使用 put 进行插入 if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) &#123; put(key, value); return; &#125; //判断是否需要 gc if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); &#125; //调用 GrowingArrayUtils.append 在数组末尾追加元素 //内部也是使用 System.arrayCopy mKeys = GrowingArrayUtils.append(mKeys, mSize, key); mValues = GrowingArrayUtils.append(mValues, mSize, value); mSize++; &#125; 3.get 方法get 方法 方法就相对简单了1234567891011121314151617181920public E get(int key) &#123; return get(key, null); &#125; /** * Gets the Object mapped from the specified key, or the specified Object * if no such mapping has been made. */ @SuppressWarnings(&quot;unchecked&quot;) public E get(int key, E valueIfKeyNotFound) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); //如果查找失败或者元素已经被删除 //就返回 null 或者默认的值 if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125; &#125; 与 HashMap 的对比优点 频繁的插入删除操作效率高,因为延迟删除标志 DELETE 通过 gc 函数来清除，内存利用率高 不用自动拆箱 缺点 存取因二分查找的时间复杂度 O(log n)，数据较多的情况下，效率没有 HashMap 高 key 只能是 int 或者 long 因此 SparseArray 应用场景为 数据较少，并且存取的 value 为指定类型的，比如 boolean、int、long，可以避免自动装箱和拆箱问题。 三.ArrayMap12345678910111213141516171819202122232425/** * ArrayMap is a generic key-&gt;value mapping data structure that is * designed to be more memory efficient than a traditional &#123;@link java.util.HashMap&#125;. * It keeps its mappings in an array data structure -- an integer array of hash * codes for each item, and an Object array of the key/value pairs. This allows it to * avoid having to create an extra object for every entry put in to the map, and it * also tries to control the growth of the size of these arrays more aggressively * (since growing them only requires copying the entries in the array, not rebuilding * a hash map). * * &lt;p&gt;Note that this implementation is not intended to be appropriate for data structures * that may contain large numbers of items. It is generally slower than a traditional * HashMap, since lookups require a binary search and adds and removes require inserting * and deleting entries in the array. For containers holding up to hundreds of items, * the performance difference is not significant, less than 50%.&lt;/p&gt; * * &lt;p&gt;Because this container is intended to better balance memory use, unlike most other * standard Java containers it will shrink its array as items are removed from it. Currently * you have no control over this shrinking -- if you set a capacity and then remove an * item, it may reduce the capacity to better match the current size. In the future an * explicit call to set the capacity should turn off this aggressive shrinking behavior.&lt;/p&gt; */public final class ArrayMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; ...&#125; 1.简介在源码中对 ArrayMap 的介绍主要关注在第一段，后面的前面关于 SparseArray 的介绍基本一样，这里就不再赘述，只关注第一段。 ArrayMap 是一个简单的集合用于存储 键值对 。它比传统的键值对集合 HashMap 要在内存上更有效率，因为它维持的是一个数组的数据结构，一个整型数组用于保存每一项的 hash 值,一个 键值数组保存 键值对。因此这就使得 ArrayMap 不用创建额外的实体（HashMap 中需要创建 Entry ），在扩容的时候只需要复制就行了，不用重新 hash . 对应的数据结构如图。 2.源码123456789101112131415161718192021222324252627282930313233343536private static final boolean DEBUG = false; private static final String TAG = &quot;ArrayMap&quot;; // private static final boolean CONCURRENT_MODIFICATION_EXCEPTIONS = true; //缓存长度为 4 时的数组 private static final int BASE_SIZE = 4; //缓存数组数量的最大值，也就是说最多只能缓存10个数组 private static final int CACHE_SIZE = 10; //空数组 static final int[] EMPTY_IMMUTABLE_INTS = new int[0]; //空 ArrayMap public static final ArrayMap EMPTY = new ArrayMap&lt;&gt;(-1); //缓存数组 // mBaseCache 用于缓存长度为 4 的数组 //mBaseCacheSize 记录缓存的个数 static Object[] mBaseCache; static int mBaseCacheSize; //mTwiceBaseCache 用于缓存长度为 8 的数组 //mTwiceBaseCacheSize 记录个数 static Object[] mTwiceBaseCache; static int mTwiceBaseCacheSize; //是否需要唯一的 hash 值 //因为 hashCode 不唯一 final boolean mIdentityHashCode; int[] mHashes; //存放每一项的 hash 值 Object[] mArray; //key/value 数组 int mSize; //键值对大小 MapCollections&lt;K, V&gt; mCollections; 构造函数1234567891011121314151617181920212223242526272829303132public ArrayMap() &#123; this(0, false);&#125;public ArrayMap(int capacity) &#123; this(capacity, false);&#125;/** &#123;@hide&#125; */public ArrayMap(int capacity, boolean identityHashCode) &#123; mIdentityHashCode = identityHashCode; // If this is immutable, use the sentinal EMPTY_IMMUTABLE_INTS // instance instead of the usual EmptyArray.INT. The reference // is checked later to see if the array is allowed to grow. if (capacity &lt; 0) &#123; mHashes = EMPTY_IMMUTABLE_INTS; mArray = EmptyArray.OBJECT; &#125; else if (capacity == 0) &#123; mHashes = EmptyArray.INT; mArray = EmptyArray.OBJECT; &#125; else &#123; allocArrays(capacity); &#125; mSize = 0;&#125;public ArrayMap(ArrayMap&lt;K, V&gt; map) &#123; this(); if (map != null) &#123; putAll(map); &#125;&#125; 无论是哪个构造函数，最后都会调用 两个参数的 ArrayMap(int capacity, boolean identityHashCode) identityHashCode,如果 true 则 hash 值是默认的 hashCode System.identityHashCode(key) 不管 key 的hashCode 是否被重写 。否则就是 key.hashCode() 这个 hashCode 就有可能使重写的情况。 注意最后 如果设置的初始大小大于 0 ，则会调用 allocArrays 。allocArrays 这个方法就是从缓存的数组获取数组，避免重复的创建，既然有获取缓存当然有添加缓存，相应的添加缓存的方法就是 freeArrays 。 首先看缓存的数组是如何添加的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static Object[] mBaseCache;static int mBaseCacheSize;static Object[] mTwiceBaseCache;static int mTwiceBaseCacheSize;//首先添加缓存private static void freeArrays(final int[] hashes, final Object[] array, final int size) &#123; //当 hash 数组大小为 8 的时候 if (hashes.length == (BASE_SIZE*2)) &#123; synchronized (ArrayMap.class) &#123; //如果缓存的数组的个数小于 CACHE_SIZE 即 10 个 if (mTwiceBaseCacheSize &lt; CACHE_SIZE) &#123; //就将 旧的数组第一个元素设置为 mTwiceBaseCache array[0] = mTwiceBaseCache; /第二个元素设置为 旧的 hash 数组 array[1] = hashes; //其他元素设置为 null for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123; array[i] = null; &#125; //把 mTwiceBaseCache 指向就得数组 mTwiceBaseCache = array; mTwiceBaseCacheSize++; if (DEBUG) Log.d(TAG, &quot;Storing 2x cache &quot; + array + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;); &#125; &#125; //当 hash 数组的大小为 4 的时候 //情况和上述的一样 &#125; else if (hashes.length == BASE_SIZE) &#123; synchronized (ArrayMap.class) &#123; if (mBaseCacheSize &lt; CACHE_SIZE) &#123; array[0] = mBaseCache; array[1] = hashes; for (int i=(size&lt;&lt;1)-1; i&gt;=2; i--) &#123; array[i] = null; &#125; mBaseCache = array; mBaseCacheSize++; if (DEBUG) Log.d(TAG, &quot;Storing 1x cache &quot; + array + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;); &#125; &#125; &#125;&#125; 注意到能够添加到缓存的条件只有两种情况 hash 数组的长度为 4 或者 8添加的情况如图： 可以看出这是一个类似链表的结构，相应的获取缓存就是取出链表的头节点，并设置新的头节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344//获取缓存的方法private void allocArrays(final int size) &#123; if (mHashes == EMPTY_IMMUTABLE_INTS) &#123; throw new UnsupportedOperationException(&quot;ArrayMap is immutable&quot;); &#125; if (size == (BASE_SIZE*2)) &#123; synchronized (ArrayMap.class) &#123; if (mTwiceBaseCache != null) &#123; //获取头结点数组 final Object[] array = mTwiceBaseCache; mArray = array; //设置新的头节点 mTwiceBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; array[0] = array[1] = null; //缓存数减 1 mTwiceBaseCacheSize--; if (DEBUG) Log.d(TAG, &quot;Retrieving 2x cache &quot; + mHashes + &quot; now have &quot; + mTwiceBaseCacheSize + &quot; entries&quot;); return; &#125; &#125; &#125; else if (size == BASE_SIZE) &#123; synchronized (ArrayMap.class) &#123; if (mBaseCache != null) &#123; final Object[] array = mBaseCache; mArray = array; mBaseCache = (Object[])array[0]; mHashes = (int[])array[1]; array[0] = array[1] = null; mBaseCacheSize--; if (DEBUG) Log.d(TAG, &quot;Retrieving 1x cache &quot; + mHashes + &quot; now have &quot; + mBaseCacheSize + &quot; entries&quot;); return; &#125; &#125; &#125; //如果需要的长度既不是 4 也不是 8 就创建新的数组。 mHashes = new int[size]; mArray = new Object[size&lt;&lt;1]; &#125; put 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) &#123; final int osize = mSize; final int hash; int index; // key 允许为 null //对应下标为 0 if (key == null) &#123; hash = 0; index = indexOfNull(); //根据 hash 值获取下标 //这个过程 主要由 indexOf 完成 &#125; else &#123; hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode(); index = indexOf(key, hash); &#125; //如果下标存在就 设置并返回 if (index &gt;= 0) &#123; index = (index&lt;&lt;1) + 1; final V old = (V)mArray[index]; mArray[index] = value; return old; &#125; //取反获取需要插入的位置 index = ~index; //如果数组已经满了 if (osize &gt;= mHashes.length) &#123; final int n = osize &gt;= (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1)) : (osize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE); if (DEBUG) Log.d(TAG, &quot;put: grow from &quot; + mHashes.length + &quot; to &quot; + n); final int[] ohashes = mHashes; final Object[] oarray = mArray; //获取缓存，或者创建新的数组 allocArrays(n); if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) &#123; throw new ConcurrentModificationException(); &#125; //进行复制 if (mHashes.length &gt; 0) &#123; if (DEBUG) Log.d(TAG, &quot;put: copy 0-&quot; + osize + &quot; to 0&quot;); System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length); System.arraycopy(oarray, 0, mArray, 0, oarray.length); &#125; //尝试添加到缓存 freeArrays(ohashes, oarray, osize); &#125; //如果在数组内部进行插入 if (index &lt; osize) &#123; if (DEBUG) Log.d(TAG, &quot;put: move &quot; + index + &quot;-&quot; + (osize-index) + &quot; to &quot; + (index+1)); System.arraycopy(mHashes, index, mHashes, index + 1, osize - index); System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1); &#125; if (CONCURRENT_MODIFICATION_EXCEPTIONS) &#123; if (osize != mSize || index &gt;= mHashes.length) &#123; throw new ConcurrentModificationException(); &#125; &#125; //最后赋值 mHashes[index] = hash; mArray[index&lt;&lt;1] = key; mArray[(index&lt;&lt;1)+1] = value; mSize++; return null; &#125; 通过 hash 获取对应下标的过程和 之前的有点不同，因为 hashCode 的不唯一性1234567891011121314151617181920212223242526272829303132333435363738394041424344int indexOf(Object key, int hash) &#123; final int N = mSize; // Important fast case: if nothing is in here, nothing to look for. if (N == 0) &#123; return ~0; &#125; //先使用二分进行查找 int index = binarySearchHashes(mHashes, N, hash); // If the hash code wasn&apos;t found, then we have no entry for this key. if (index &lt; 0) &#123; return index; &#125; //如果查找成功，并且对应的 key 是相同的，即 hashCode 相同且 equals 返回 true // If the key at the returned index matches, that&apos;s what we want. if (key.equals(mArray[index&lt;&lt;1])) &#123; return index; &#125; //前面的 equals 返回 false 则继续查找 //先从index 往 数组后面找 // Search for a matching key after the index. int end; for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) &#123; if (key.equals(mArray[end &lt;&lt; 1])) return end; &#125; //再从 index 往数组前面找 // Search for a matching key before the index. for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) &#123; if (key.equals(mArray[i &lt;&lt; 1])) return i; &#125; // Key not found -- return negative value indicating where a // new entry for this key should go. We use the end of the // hash chain to reduce the number of array entries that will // need to be copied when inserting. //查找失败则返回插入的位置 ，相同的 hashCode //插入是插在后面。 return ~end; &#125; 对于get 方法就相对简单，这里就不做分析。 与 HashMap 的对比优点 在数据量少时，内存利用率高，不用创建新的实体 Entry 迭代效率高，使用数组下标，相比于HashMap迭代使用迭代器，要快缺点 存取因 二分查找的 O(log n ) 复杂度高，效率低 ArrayMap 没有实现 Serializable，不利于在 Android 中借助 Bundle 传输。 因此 适用场景元素数量较少但是查询多，插入数据和删除数据不频繁的情况。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SharedPreferences ANR 总结]]></title>
    <url>%2F2019%2F02%2F14%2FSharedPreferences-ANR-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.简介SharedPreferences 是 Android 中一种轻量级的数据存储方式,数据以键值对,文件以 xml 的形式存储在 /data/data//shared_prefs目录下(在真机上需要 root 权限才能查看) 在源码中 SharedPreferences 是一个接口,具体的实现是SharedPreferencesImpl1234567891011121314151617181920/** * Interface for accessing and modifying preference data returned by &#123;@link * Context#getSharedPreferences&#125;. For any particular set of preferences, * there is a single instance of this class that all clients share. * Modifications to the preferences must go through an &#123;@link Editor&#125; object * to ensure the preference values remain in a consistent state and control * when they are committed to storage. Objects that are returned from the * various &lt;code&gt;get&lt;/code&gt; methods must be treated as immutable by the application. * * &lt;p&gt;&lt;em&gt;Note: This class does not support use across multiple processes.&lt;/em&gt; * * ... */public interface SharedPreferences &#123; ...&#125;final class SharedPreferencesImpl implements SharedPreferences &#123; ...&#125; 在注释中对 SharedPreferences 以下称（SP）解释如下： 对于任何特定的 SP ，所有客户端共享此类的单个实例（也就是应该使用单例模式）。对 SP 数据的修改必须通过一个 SharedPreferences.Editor 对象来确保 SP 数据保持一致状态，并在它们提交存储时进行控制。从各种get 方法返回的对象必须被应用程序视为不可变的。 注意：此类提供强大的一致性保证。它使用昂贵的操作可能会减慢应用程序的速度。经常改变可以容忍损失的属性或属性应该使用其他机制。有关详细信息读取上的评论 SharedPreferences.Editor.commit() 和SharedPreferences.Editor.apply()。（换句话说就是 commit 和 apply 用于对数据进行保存,为了保证一致性这个过程可能会减慢应用程序的速度，如果对一致性要求不高则可以使用其他数据存储机制。）==注意：此类不支持跨多个进程使用。== 二.获取 Sp获取一个 Sp 有三种方式 在一个 Activity 中调用 getPreferences(int mode) 使用 PreferenceManager.getDefaultSharedPreferences(Context context) context.getSharedPreferences(String name, int mode) 第一种方式和第二种方式最后都会使用 第三种方式，不同的使用的名字不同，模式现在都是为 MODE_PRIVATE 其他的都已经废弃不使用1234567891011121314151617181920212223242526//第一种//Activity //public SharedPreferences getPreferences(@Context.PreferencesMode int mode) &#123; return getSharedPreferences(getLocalClassName(), mode); &#125;//第二种//PreferenceManagerpublic static SharedPreferences getDefaultSharedPreferences(Context context) &#123; return context.getSharedPreferences(getDefaultSharedPreferencesName(context), getDefaultSharedPreferencesMode()); &#125; /** * Returns the name used for storing default shared preferences. * * @see #getDefaultSharedPreferences(Context) * @see Context#getSharedPreferencesPath(String) */ public static String getDefaultSharedPreferencesName(Context context) &#123; return context.getPackageName() + &quot;_preferences&quot;; &#125; private static int getDefaultSharedPreferencesMode() &#123; return Context.MODE_PRIVATE; &#125; 下面到 context 的具体实现类 contextImpl 中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Override public SharedPreferences getSharedPreferences(String name, int mode) &#123; // At least one application in the world actually passes in a null // name. This happened to work because when we generated the file name // we would stringify it to &quot;null.xml&quot;. Nice. // 允许名字为 null, 即文件的名字为 null.xml if (mLoadedApk.getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; if (name == null) &#123; name = &quot;null&quot;; &#125; &#125; File file; synchronized (ContextImpl.class) &#123; //mSharedPrefsPaths 的数据结构为 ArrayMap&lt;String, File&gt; //用于保存名字 和对应的文件 if (mSharedPrefsPaths == null) &#123; mSharedPrefsPaths = new ArrayMap&lt;&gt;(); &#125; file = mSharedPrefsPaths.get(name); //如果没有这个文件就创建这个文件 if (file == null) &#123; file = getSharedPreferencesPath(name); mSharedPrefsPaths.put(name, file); &#125; &#125; return getSharedPreferences(file, mode); &#125; @Override public SharedPreferences getSharedPreferences(File file, int mode) &#123; SharedPreferencesImpl sp; //使用 synchronized 进行线程安全的保证 synchronized (ContextImpl.class) &#123; //一个 SP xml 文件对应 一个 SharedPreferencesImpl 实例 final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) &#123; checkMode(mode); ... //创建 SharedPreferencesImpl sp = new SharedPreferencesImpl(file, mode); cache.put(file, sp); return sp; &#125; &#125; .... return sp; &#125; // 获取用于缓存 SharedPreferencesImpl 的 packagePrefs, 一个包名对应一个 // packagePrefs private ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123; if (sSharedPrefsCache == null) &#123; sSharedPrefsCache = new ArrayMap&lt;&gt;(); &#125; final String packageName = getPackageName(); ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName); if (packagePrefs == null) &#123; packagePrefs = new ArrayMap&lt;&gt;(); sSharedPrefsCache.put(packageName, packagePrefs); &#125; return packagePrefs; &#125; 下面就到 SharedPreferencesImpl.java 中 查看创建一个 SharedPreferencesImpl 的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//SharedPreferencesImpl 的构造器 SharedPreferencesImpl(File file, int mode) &#123; mFile = file; mBackupFile = makeBackupFile(file);//创建备份文件，用于 xml 写失败时进行恢复 mMode = mode; mLoaded = false;//判断从磁盘加载到内存的标志 mMap = null; mThrowable = null; startLoadFromDisk();//创建 SharedPreferencesImpl 的时候就将 xml 文件中的数据从磁盘加载到内存 &#125; private void startLoadFromDisk() &#123; synchronized (mLock) &#123; mLoaded = false; &#125; //开启一个线程进行加载 new Thread(&quot;SharedPreferencesImpl-load&quot;) &#123; public void run() &#123; loadFromDisk(); &#125; &#125;.start(); &#125; private void loadFromDisk() &#123; synchronized (mLock) &#123; //如果已经加载完成就返回 if (mLoaded) &#123; return; &#125; if (mBackupFile.exists()) &#123; mFile.delete(); mBackupFile.renameTo(mFile); &#125; &#125; Map&lt;String, Object&gt; map = null; StructStat stat = null; Throwable thrown = null; try &#123; stat = Os.stat(mFile.getPath()); if (mFile.canRead()) &#123; BufferedInputStream str = null; try &#123; str = new BufferedInputStream( new FileInputStream(mFile), 16 * 1024); map = (Map&lt;String, Object&gt;) //从 xml 文件中加载数据到 map //键值对为 String 和 Object XmlUtils.readMapXml(str); &#125; catch (Exception e) &#123; Log.w(TAG, &quot;Cannot read &quot; + mFile.getAbsolutePath(), e); &#125; finally &#123; IoUtils.closeQuietly(str); &#125; &#125; &#125; catch (ErrnoException e) &#123; // An errno exception means the stat failed. Treat as empty/non-existing by // ignoring. &#125; catch (Throwable t) &#123; thrown = t; &#125; synchronized (mLock) &#123; // 设置加载完成 mLoaded = true; mThrowable = thrown; //对出现异常情况进行处理 try &#123; if (thrown == null) &#123; if (map != null) &#123; mMap = map; mStatTimestamp = stat.st_mtim; mStatSize = stat.st_size; &#125; else &#123; mMap = new HashMap&lt;&gt;(); &#125; &#125; // &#125; catch (Throwable t) &#123; mThrowable = t; &#125; finally &#123; //注意这一句，唤醒其他等待的线程 mLock.notifyAll(); &#125; &#125; &#125; 获取 SharedPreferences 总结： 获取 SP 的过程是通过 synchronized 关键字保证多线程安全的。 通过 Map 进行缓存 Sp 实例，因此多次调用 getSharedPreferences 几乎没有性能上的差别。 获取 Sp 的时候就会通过一个线程将 xml 数据从磁盘加载到内存中。这个过程会加锁，加载完成后会设置 mLoaded 标志，并唤醒其他线程。三.get 方法Sp 支持的数据类型为 int , long , float, boolean ,String 和 Set . 下面以 getString 为例123456789101112//SharedPreferencesImpl.java @Override @Nullable public String getString(String key, @Nullable String defValue) &#123; //进行线程安全保证 synchronized (mLock) &#123; //等待加载完成后才能读 awaitLoadedLocked(); String v = (String)mMap.get(key); return v != null ? v : defValue; &#125; &#125; 1234567891011121314151617181920212223@GuardedBy(&quot;mLock&quot;) private void awaitLoadedLocked() &#123; //如果没有加载就开启一个线程进行加载 if (!mLoaded) &#123; // Raise an explicit StrictMode onReadFromDisk for this // thread, since the real read will be in a different // thread and otherwise ignored by StrictMode. BlockGuard.getThreadPolicy().onReadFromDisk(); &#125; //循环判断 while (!mLoaded) &#123; try &#123; //在上面的分析知道只有加载后 mLoaded 就设置 为 true //并调用 notifyAll 唤醒其他线程 //所以这个时候从 wait 进行返回 mLock.wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125; if (mThrowable != null) &#123; throw new IllegalStateException(mThrowable); &#125; &#125; getXXX 方法 总结： 通过 synchronized 进行线程安全保证 在主线程进行获取，但是需要等加载的完成后才能进行读，所以get 方法可能造成主线程阻塞,从而导致 ANR 。 加载完成后读的过程只涉及内存的读。 四.putXXX 和 apply/commit提交数据的时候首先要获取 Editor 对象12345678910@Override public Editor edit() &#123; //这里也是需要等待加载 xml 文件到内存完成后 //才能创建 EditorImpl synchronized (mLock) &#123; awaitLoadedLocked(); &#125; return new EditorImpl(); &#125; 以 putString 为例123456789@Override public Editor putString(String key, @Nullable String value) &#123; //使用 synchronized 进行线程安全保证 synchronized (mEditorLock) &#123; //将数据暂时保存到 mModified 这个 Map 中 mModified.put(key, value); return this; &#125; &#125; 1.apply123456@Override public void apply() &#123; final long startTime = System.currentTimeMillis(); //将修改先写入内存 final MemoryCommitResult mcr = commitToMemory(); //先看 commitToMemory 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private MemoryCommitResult commitToMemory() &#123; ... //将 mModified 的中暂存的数据写入内存 for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123; String k = e.getKey(); Object v = e.getValue(); // &quot;this&quot; is the magic value for a removal mutation. In addition, // setting a value to &quot;null&quot; for a given key is specified to be // equivalent to calling remove on that key. if (v == this || v == null) &#123; if (!mapToWriteToDisk.containsKey(k)) &#123; continue; &#125; mapToWriteToDisk.remove(k); &#125; else &#123; if (mapToWriteToDisk.containsKey(k)) &#123; Object existingValue = mapToWriteToDisk.get(k); if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123; continue; &#125; &#125; mapToWriteToDisk.put(k, v); &#125; changesMade = true; if (hasListeners) &#123; keysModified.add(k); &#125; &#125; mModified.clear(); .... //返回一个 MemoryCommitResult 对象。 return new MemoryCommitResult(memoryStateGeneration, keysModified, listeners, mapToWriteToDisk); &#125; //MemoryCommitResult 的实现 private static class MemoryCommitResult &#123; final long memoryStateGeneration; @Nullable final List&lt;String&gt; keysModified; @Nullable final Set&lt;OnSharedPreferenceChangeListener&gt; listeners; final Map&lt;String, Object&gt; mapToWriteToDisk; final CountDownLatch writtenToDiskLatch = new CountDownLatch(1);//注意这里 有一个 CountDownLatch 设置为 1，说明只要有一个线程调用了 countDown 就可以从 writtenToDiskLatch.await(); 返回 @GuardedBy(&quot;mWritingToDiskLock&quot;) volatile boolean writeToDiskResult = false; boolean wasWritten = false; private MemoryCommitResult(long memoryStateGeneration, @Nullable List&lt;String&gt; keysModified, @Nullable Set&lt;OnSharedPreferenceChangeListener&gt; listeners, Map&lt;String, Object&gt; mapToWriteToDisk) &#123; this.memoryStateGeneration = memoryStateGeneration; this.keysModified = keysModified; this.listeners = listeners; this.mapToWriteToDisk = mapToWriteToDisk; &#125; //调用这个就会从 执行 countDown ，相应的 writtenToDiskLatch.await() 就能返回 void setDiskWriteResult(boolean wasWritten, boolean result) &#123; this.wasWritten = wasWritten; writeToDiskResult = result; writtenToDiskLatch.countDown(); &#125; &#125; 回到 apply 方法中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override public void apply() &#123; final long startTime = System.currentTimeMillis(); //将修改先写入内存 final MemoryCommitResult mcr = commitToMemory(); //这里只是创建了一个 Runnable ，并不是一个线程 final Runnable awaitCommit = new Runnable() &#123; @Override public void run() &#123; try &#123; //注意这里会进行等待也就是 需要 MemoryCommitResult 的 setDiskWriteResult 方法执行后 //才能返回 mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException ignored) &#123; &#125; if (DEBUG &amp;&amp; mcr.wasWritten) &#123; Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration + &quot; applied after &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125; &#125; &#125;; //添加到队列中 QueuedWork.addFinisher(awaitCommit); //这里也只创建一个 Runnable Runnable postWriteRunnable = new Runnable() &#123; @Override public void run() &#123; //这里执行了上面的 awaitCommit 的 run 方法 //不是 start //并将队列中的 awaitCommit 移除 awaitCommit.run(); QueuedWork.removeFinisher(awaitCommit); &#125; &#125;; //添加到队列中 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it&apos;s hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. notifyListeners(mcr); &#125; 12345678910111213141516171819202122232425262728293031323334private void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) &#123; final boolean isFromSyncCommit = (postWriteRunnable == null); //创建一个 Runnable ，同样也没有 start final Runnable writeToDiskRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (mWritingToDiskLock) &#123; writeToFile(mcr, isFromSyncCommit); &#125; synchronized (mLock) &#123; mDiskWritesInFlight--; &#125; if (postWriteRunnable != null) &#123; postWriteRunnable.run(); &#125; &#125; &#125;; //如果是 commit 则执行这里并返回 // Typical #commit() path with fewer allocations, doing a write on // the current thread. if (isFromSyncCommit) &#123; boolean wasEmpty = false; synchronized (mLock) &#123; wasEmpty = mDiskWritesInFlight == 1; &#125; if (wasEmpty) &#123; writeToDiskRunnable.run(); return; &#125; &#125; //如果是 apply 就执行这里 QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit); &#125; 在 QueuedWork.java 中123456789101112131415161718192021222324252627282930public static void queue(Runnable work, boolean shouldDelay) &#123; //getHandler 获取的是一个 handlerThread 的hanlder ,也就是一个子线程 Handler handler = getHandler(); synchronized (sLock) &#123; sWork.add(work); if (shouldDelay &amp;&amp; sCanDelay) &#123; //发送一个消息 MSG_RUN 到 handler 所在线程，也就是 handlerThread 子线程中去 handler.sendEmptyMessageDelayed(QueuedWorkHandler.MSG_RUN, DELAY); &#125; else &#123; handler.sendEmptyMessage(QueuedWorkHandler.MSG_RUN); &#125; &#125;&#125;private static Handler getHandler() &#123; synchronized (sLock) &#123; if (sHandler == null) &#123; //创建一个 handlerThread ，并执行 start 方法 //这就是 apply 写到磁盘的线程 HandlerThread handlerThread = new HandlerThread(&quot;queued-work-looper&quot;, Process.THREAD_PRIORITY_FOREGROUND); handlerThread.start(); sHandler = new QueuedWorkHandler(handlerThread.getLooper()); &#125; return sHandler; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// Handler 的处理private static class QueuedWorkHandler extends Handler &#123; static final int MSG_RUN = 1; QueuedWorkHandler(Looper looper) &#123; super(looper); &#125; public void handleMessage(Message msg) &#123; if (msg.what == MSG_RUN) &#123; processPendingWork(); &#125; &#125; &#125; private static void processPendingWork() &#123; long startTime = 0; synchronized (sProcessingWork) &#123; LinkedList&lt;Runnable&gt; work; synchronized (sLock) &#123; //复制前面的工作队列 work = (LinkedList&lt;Runnable&gt;) sWork.clone(); sWork.clear(); // Remove all msg-s as all work will be processed now getHandler().removeMessages(QueuedWorkHandler.MSG_RUN); &#125; //一个一个执行 run 方法， if (work.size() &gt; 0) &#123; for (Runnable w : work) &#123; w.run(); &#125; &#125; &#125; &#125; &#125; QueuedWork.addFinisher(awaitCommit);在上面的方法中注意到 对每个 apply 都会创建一个相应的 awaitCommit，并添加到 QueuedWork 的一个队列中，但是在 QueuedWork 注意到有这样一个方法 waitToFinish12345678910/** * Trigger queued work to be processed immediately. The queued work is processed on a separate * thread asynchronous. While doing that run and process all finishers on this thread. The * finishers can be implemented in a way to check weather the queued work is finished. * * Is called from the Activity base class&apos;s onPause(), after BroadcastReceiver&apos;s onReceive, * after Service command handling, etc. (so async work is never lost) */public static void waitToFinish() &#123;&#125; 这个方法会在 Activity 暂停时或者 BroadcastReceiver 的 onReceive 方法调用后或者 service 的命令处理后被调用，并且调用这个方法的目的是为了确保异步任务被及时完成。 可以看到 waitToFinish 都是在 ActivityThread 中，也就是主线程调用的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void waitToFinish() &#123; boolean hadMessages = false; Handler handler = getHandler(); synchronized (sLock) &#123; if (handler.hasMessages(QueuedWorkHandler.MSG_RUN)) &#123; // Delayed work will be processed at processPendingWork() below handler.removeMessages(QueuedWorkHandler.MSG_RUN); &#125; // We should not delay any work as this might delay the finishers sCanDelay = false; &#125; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites(); try &#123; //这个方法就会执行 所有的 Runnable 的run 返回 //这个时候 processPendingWork 是执行在主线程中 processPendingWork(); &#125; finally &#123; StrictMode.setThreadPolicy(oldPolicy); &#125; try &#123; while (true) &#123; Runnable finisher; synchronized (sLock) &#123; finisher = sFinishers.poll(); &#125; if (finisher == null) &#123; break; &#125; finisher.run(); &#125; &#125; finally &#123; sCanDelay = true; &#125; ... &#125; 这种设计是为了保证 SP 可靠的、保证写入完成的存储机制。 apply 总结 apply 没有返回值 apply 是在主线程将修改数据提交到内存, 然后再子线程（HandleThread）提交到磁盘 apply 会将 Runnble 添加到 QueueWork 中，如果主线程 Activity 暂停时或者 BroadcastReceiver 的 onReceive 方法调用后或者 service 的命令处理，就会在主线程执行 提交到硬盘的方法，这个过程就会造成主线程 ANR 2.commit123456789101112131415161718192021222324252627public boolean commit() &#123; long startTime = 0; if (DEBUG) &#123; startTime = System.currentTimeMillis(); &#125; //这个也是先写入内存 MemoryCommitResult mcr = commitToMemory(); //这里传入 null 即 postWriteRunnable 为 null SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */); try &#123; mcr.writtenToDiskLatch.await(); &#125; catch (InterruptedException e) &#123; return false; &#125; finally &#123; if (DEBUG) &#123; Log.d(TAG, mFile.getName() + &quot;:&quot; + mcr.memoryStateGeneration + &quot; committed after &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125; &#125; notifyListeners(mcr); return mcr.writeToDiskResult; &#125; 123456789101112131415161718192021222324252627282930313233private void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) &#123; final boolean isFromSyncCommit = (postWriteRunnable == null); final Runnable writeToDiskRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (mWritingToDiskLock) &#123; writeToFile(mcr, isFromSyncCommit); &#125; synchronized (mLock) &#123; mDiskWritesInFlight--; &#125; if (postWriteRunnable != null) &#123; postWriteRunnable.run(); &#125; &#125; &#125;; // Typical #commit() path with fewer allocations, doing a write on // the current thread. // 为 true // 直接在主线程中执行 run 方法。 if (isFromSyncCommit) &#123; boolean wasEmpty = false; synchronized (mLock) &#123; wasEmpty = mDiskWritesInFlight == 1; &#125; if (wasEmpty) &#123; writeToDiskRunnable.run(); return; &#125; &#125; commit 总结 commit 有返回值 commit 是在主线程将修改数据提交到内存, 然后再在主线程提交到磁盘 用 commit 方法最保险。如果担心在主线程调用 commit 方法会出现 ANR，可以将所有的 commit 任务放到单线程池的线程里去执行。 总结 Sp 主线程 getXX 方法会 ANR Sp apply 方法会 ANR Sp 主线程调用 commit 方法 ANR]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View总结]]></title>
    <url>%2F2019%2F02%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[csdn 个人博客 一.学习自定义 View自定义 View 是 Android 中的一个基础技能,但是也相对一个较难的知识点,关于如何学习自定义 View 个人认为可以参考如下文章： Android自定义View的实现方法，带你一步步深入了解View Android 自定义View 安卓自定义View教程目录 自定义 View 在学习了相关的文章后,笔者也通过几天的时间实现了一个牛顿摆的自定义 View NewtonCradle,并在这个过程中将相关知识学习总结如下 二.多个构造器1234567891011public NewtonCradle(Context context) &#123; this(context, null); &#125; public NewtonCradle(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NewtonCradle(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; 在自定义 View 的时候我们通常会 实现这三个构造器,实际上有四个构造器，因为第四个不常用所以一般只实现三个就行了 1.1个参数的构造器1234567/** * Simple constructor to use when creating a view from code. * * @param context The Context the view is running in, through which it can * access the current theme, resources, etc. */ public View(Context context) &#123;&#125; 从注释中可以看到：一个参数的构造器会在代码中直接 new 的时候调用。 2.多个参数的构造器1234567891011121314151617181920212223242526272829303132333435/** * Constructor that is called when inflating a view from XML. This is called * when a view is being constructed from an XML file, supplying attributes * that were specified in the XML file. This version uses a default style of * 0, so the only attribute values applied are those in the Context&apos;s Theme * and the given AttributeSet. *...//两个参数的构造器会调用 三参数的构造器,指定 defStyleAttr 为 0public View(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125;/** * Perform inflation from XML and apply a class-specific base style from a * theme attribute. This constructor of View allows subclasses to use their * own base style when they are inflating. For example, a Button class&apos;s * constructor would call this version of the super class constructor and * supply &lt;code&gt;R.attr.buttonStyle&lt;/code&gt; for &lt;var&gt;defStyleAttr&lt;/var&gt;; this * allows the theme&apos;s button style to modify all of the base view attributes * (in particular its background) as well as the Button class&apos;s attributes. *//三个参数的构造器会去调用 四个 参数的构造器，并指定 //defStyleRes 为 0 public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125;/** * Perform inflation from XML and apply a class-specific base style from a * theme attribute or style resource. This constructor of View allows * subclasses to use their own base style when they are inflating.//最后调用的是四个参数的构造器public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; 从两个参数的构造器的注释中可以知道：当在 xml 文件中使用的 View 的时候，调用的是两个参数的构造器。而三个参数/四个参数的构造器就是通过两个参数的构造器去调用的。 这个四个参数的含义分别是： Context ,上下文,一般为 Activity AttributeSet，属性集合,自定义/非自定义的一些属性,包括 style 中的 1style=&quot;@style/NewtonCradle&quot; defStyleAttr,默认的 style 的 属性，也就是 Theme 中的 style 的 id.当传入为 0 的时候表示不使用这个属性。通常使用形式如 12345&lt;activity ... android:theme=&quot;@style/AppTheme&quot; android:label=&quot;@string/app_name&quot; &gt;... 这样做的原因是当切换不同的主题时,View 的样式也能随之进行改变. defStyleRes 默认的 res 中的 style 的属性，当传入为 0 的时候表示不使用这个 属性。 这个属性的只能在代码中实现加载，因此不常用。 实际上多个构造器的作用都是为属性赋值，只不过针对不同的使用方式使用场景有所区别，因此也形成一种优先级赋值的关系。优先级高的会覆盖优先级低的。 1.在布局xml中直接定义 2.在布局xml中通过style定义 3.自定义View所在的 Activity 的 Theme 中指定 style 引用 4.构造函数中 defStyleRes 指定的默认值 三.invalidate12345invalidate();invalidate(Rect dirty);invalidate(l,t,r,b);invalidateDrawable(Drawable drawable);invalidateOutline(); invalidate 是 View 中用来对 View 进行重绘的方法,它有几个类似的方法用于指定重绘的区域,但是最终都会调用到同一个方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void invalidate() &#123; invalidate(true);&#125; public void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;//invalidate 的几个类似方法最终都会调用到 invalidateInternal 这个方法，不同的是指定重绘的区域//四个参数就是用于指定需要重绘的区域void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; ... //如果是 不可见或者处于动画中则不进行重绘 if (skipInvalidate()) &#123; return; &#125; //判断一些标志位看是否需要重绘，如果 View 没有发生改变则不需要重绘。 if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; if (fullInvalidate) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN; &#125; mPrivateFlags |= PFLAG_DIRTY; //将绘制的区域传递给 父View // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; //ViewGroup 都实现 ViewParent 接口 final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); //传递给 ViewGroup p.invalidateChild(this, damage); &#125; ... &#125; &#125;&#125;//判断是否需要可见或者处于动画中private boolean skipInvalidate() &#123; return (mViewFlags &amp; VISIBILITY_MASK) != VISIBLE &amp;&amp; mCurrentAnimation == null &amp;&amp; (!(mParent instanceof ViewGroup) || !((ViewGroup) mParent).isViewTransitioning(this));&#125; 下面就看 ViewGroup 中的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final void invalidateChild(View child, final Rect dirty) &#123; ... 先将 parent 指向自己 ViewParent parent = this; ... //进入一个 do...while 循环 do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; //首先调用自己的 invalidateChildInParent， //这个方法返回 父容器的 ViewGroup //重新赋值给 parent //通过 循环不断传递给 父 ViewGroup //这里通过类型 ViewParent 而不是 ViewGroup parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); &#125; &#125; 1234567891011 // 返回父 ViewParent 一般为 ViewGroup@Deprecated @Override public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123; ... return mParent; ... &#125; //ViewGroup 实现 ViewParent 接口 public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123;&#125; 通过这种方式,就将绘制的请求回溯到上一层的 ViewGroup ,这里的使用的是 ViewParent 而不是 ViewGroup ,因为还有一个类也是实现了 ViewParent 接口。12public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;&#125; 看到这里，熟悉 View 的绘制流程的都知道一个 View 的绘制最先就是从这里开始的，ViewRootImpl 实现了 ViewParent 这个接口，那么在上述说到的 do/while 循环中最终就会回溯到这里12345678910111213141516171819@Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; // 检查调用这个方法的 线程 和 创建 ViewRootImpl 是否在同一个线程。 checkThread(); .... invalidateRectOnScreen(dirty); return null; &#125; private void invalidateRectOnScreen(Rect dirty) &#123; final Rect localDirty = mDirty; ... if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; //调用下面这个方法 scheduleTraversals(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233 void scheduleTraversals() &#123; .... 通过 Handler 发送一个 Runnable。 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ... &#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; // doTraversal(); &#125; &#125; void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(&quot;ViewAncestor&quot;); &#125; //最终就是回到 View 的绘制的起使方法 performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 在 performTraversals 中会进行一些判断如不需要 measure 和 layout ,然后直接进行 performDraw 方法。 四.postInvalidateInvalidate 是在主线程调用的用于 重绘 View 的方法,那么如果需要在子线程中重新 View 就需要调用 postInvalidate 方法。123postInvalidate();postInvalidate(l,r,t,b);postInvalidateDelayed(mills); postInvalidate 也有一些类型的方法，最终都会调用 mViewRootImpl 的相关方法1234567891011121314151617public void postInvalidate() &#123; postInvalidateDelayed(0); &#125; public void postInvalidate(int left, int top, int right, int bottom) &#123; postInvalidateDelayed(0, left, top, right, bottom); &#125; public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there&apos;s no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125; &#125; 在 ViewRootImpl 中123456789101112public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; //发送一个消息 Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125; public void dispatchInvalidateRectDelayed(AttachInfo.InvalidateInfo info, long delayMilliseconds) &#123; //发送一个消息 final Message msg = mHandler.obtainMessage(MSG_INVALIDATE_RECT, info); mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125; 在 ViewRootImpl 中可以看到 postInvalidate 最终就会通过 Hanlder 发送一个消息到消息队列,然后就回到了主线程12345678910111213 final ViewRootHandler mHandler = new ViewRootHandler();@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; case MSG_INVALIDATE_RECT: final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj; info.target.invalidate(info.left, info.top, info.right, info.bottom); info.recycle(); break; 这个 mHandler 是在主线程中创建的,因此消息的处理也就回到了主线程，最后又调用了 invalidate 方法。 五.requestLayout当一个 View 调用 requestLayout 的时候就需要对 View 树进行重新 测量、布局、绘制这三个流程，。在 View 的源码中,123456789101112131415161718192021222324252627282930313233343536373839 /*Call this when something has changed which has invalidated the * layout of this view. This will schedule a layout pass of the view * tree. This should not be called while the view hierarchy is currently in a layout * pass (&#123;@link #isInLayout()&#125;. If layout is happening, the request may be honored at the * end of the current layout pass (and then layout will run again) or after the current * frame is drawn and the next layout occurs. */ //如果当前 View 在请求布局的时候，View 树正在进行布局流程的话，//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行，这个延迟是通过设置标志实现的。@CallSuper public void requestLayout() &#123; if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123; // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123; if (!viewRoot.requestLayoutDuringLayout(this)) &#123; return; &#125; &#125; mAttachInfo.mViewRequestingLayout = this; &#125; //设置标志 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED //表示需要 重新 测量，布局，绘制 mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; //从这个 mParent 就是 ViewGroup //最终会调用到 viewRootImpl 的 requestLayout mParent.requestLayout(); &#125; if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123; mAttachInfo.mViewRequestingLayout = null; &#125; &#125; 在 ViewRootImpl 的 requestLayout 的过程中12345678@Override public void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; 这里又回到 scheduleTraversals 方法中，由于设置标志位，因此就会进行测量，布局和绘制。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Binder机制（进阶篇）]]></title>
    <url>%2F2019%2F01%2F24%2FAndroid-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一.前言 Android 的 Binder 机制,是作为 Android 进阶学习中一个必学的知识点。 之前,通过学习 《Android 开发艺术探索》以及 网上的一些博客, 大致了解 Android Binder 机制的过程,自以为已掌握 Binder 机制的大致过程,写下博客 Android—-IPC机制（Binder） ,但是实际上只是了解了皮毛，没有深入整个流程，于是重新学习，将新的体会记录成这篇 进阶篇。 阅读这篇文章之前需要具备基本的 Binder 机制的流程,具体可通过这些博客学习 Android—-IPC机制（Binder） Binder学习指南 图文详解 Android Binder跨进程通信的原理 手动实现 Binder 的通信,不依靠 AIDL 自动生成。 二.跨进程(一).用户空间/内核空间 内核空间是 Linux 系统中内核的运行空间,在内核空间可以随意访问系统的资源,系统内核对资源进行同一的管理。 用户空间是每个用户进程运行的空间,这个空间是进程独有的,不能和其他进程进行内存共享,主要是用于保存进程中的数据等,由于可能存在有恶意的用户进程对系统进行破坏,且系统资源是宝贵的,这就需要保证系统的安全,所以一个进程的用户空间不能直接访问系统资源。 那么一个用户空间如何访问系统资源呢？ 通过内核提供的接口,向内核发出指令,然后交由内核去访问系统资源。 大致情况如下图： (二).Binder 驱动虽然两个进程的用户空间互不共享,但是一个进程除了有用户空间,还有内核空间,且内核空间是共有的,所以两个进程想要进行通信,那么就可以通过一个在内核空间的中介进行数据的交互，这个中介就是 Binder 驱动。 Binder 驱动是 Android 在 Linux 内核上添加的一个内核模块，作为内核的一部分在内核空间上运行里运行,两个进程通过这个在内核空间运行的 Binder 驱动就可以进行通信。 (三).内核启动Binder 驱动是运行在内核空间的,在内核启动的时候 就会将 Binder 注册成 misc device 类型的驱动,也就是内核驱动。 123456789101112131415static int __init binder_init(void)&#123; int ret; char *device_name, *device_names; struct binder_device *device; struct hlist_node *tmp; while ((device_name = strsep(&amp;device_names, &quot;,&quot;))) &#123; //初始化 Binder 设备 ret = init_binder_device(device_name); if (ret) goto err_init_binder_device_failed; &#125; return ret; 123456789101112131415161718192021222324252627static int __init init_binder_device(const char *name)&#123; int ret; struct binder_device *binder_device; //1.为 Binder 设备开辟空间 binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL); if (!binder_device) return -ENOMEM; //2.初始化 Binder binder_device-&gt;miscdev.fops = &amp;binder_fops; binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR; binder_device-&gt;miscdev.name = name; binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID; binder_device-&gt;context.name = name; //2.注册 Binder 设备 ret = misc_register(&amp;binder_device-&gt;miscdev); if (ret &lt; 0) &#123; kfree(binder_device); return ret; &#125; hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices); return ret;&#125; 三.ServiceManager有大致了解过的 Binder 的人都知道 Binder 机制涉及到四个对象 客户端 服务端 Binder 驱动 ServiceManager 前三个相信大家都清楚是什么,至于第四个 ServiceManager,从名字上就可以看出,它的作用就是对服务端进行管理,进程间的通信时一个常见的功能,每个进程都可以作为客户端或服务端通过 Binder 驱动参与进程间的通信,而且通信的前提就是找到通信的另一方,并建立联系,ServiceManager 的作用就在于此，其记录了所有的服务端,当一个客户端想要和服务端进行通信的时候，首先就会去 ServiceManager 找到对应的服务端。这好比打电话, Binder 驱动就是信号基站,而 ServiceManager 就是一个通信录，进行 A 要和 进程 B 进行通信,首先就要去 通信录找到进程 B 的电话号码是多少,然后就可通过这个电话号码,将数据通过信号基站传递给进程 B ，这就完成了进程通信。 但是 ServiceManager 本身也是一个进程,这是一个 native 进程,客户端获取电话号码的过程也本应该是一个跨进程的通信(实际上并没有),那么客户端是如何首先获取 ServiceManager 的对应的 Binder 引用的呢? 这就是本篇文章要解决的第一个问题。 (一).ServiceManager 的启动ServiceManager 是一个 native 进程,其源码自然是 C/C++ ,但是不用担心,这里只关注一些重要的地方,通过函数的名字就可以看出其作用。 1.init 进程在 Android 系统中 init 进程是系统启动的第一个进程, 在内核启动后就会启动 init 进程 ,它启动后就会去解析 init.c 这个文件，然后启动其他的 native 进程,而 ServiceManager 作为一个 native 进程,自然也是由它启动的。 在解析 init.rc 文件的时候去启动 servicemanager.rc1234567891011121314151617service servicemanager /system/bin/servicemanager class core animation user system group system readproc critical onrestart restart healthd onrestart restart zygote onrestart restart audioserver onrestart restart media onrestart restart surfaceflinger onrestart restart inputflinger onrestart restart drm onrestart restart cameraserver onrestart restart keystore onrestart restart gatekeeperd writepid /dev/cpuset/system-background/tasks shutdown critical 2.servicemanager 的启动servicemanager 的启动 的 启动从 servicemanager.c 文件中的 main 方法开始的 1234567891011121314151617181920// native\native\cmds\servicemanager\servicemanager.cint main(int argc, char** argv)&#123; struct binder_state *bs; // 1.打开 Binder 驱动 //并设置 servicemanager 进行地址映射的大小为 128 KB bs = binder_open(driver, 128*1024); // 2.将 servicemanager 驱动设置为唯一的管理者，也就是系统内核只有一个servicemanager if (binder_become_context_manager(bs)) &#123; ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno)); return -1; &#125; //3.启动循环，不断处理客户端的请求 binder_loop(bs, svcmgr_handler); return 0;&#125; (1).binder_open1234567891011121314151617 // native\native\cmds\servicemanager\binder.c struct binder_state *binder_open(const char* driver, size_t mapsize)&#123; struct binder_state *bs; struct binder_version vers; bs = malloc(sizeof(*bs)); //进入系统内核 打开 Binder 设备 bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC); //地址映射 bs-&gt;mapsize = mapsize; bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); return bs; 系统内核打开 Binder 设备1234567891011121314151617181920212223242526272829static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; struct binder_device *binder_dev; //为当前进程 创建一个 proc 结构体 //这里就是为 ServiceManager 创建一个结构体 proc = kzalloc(sizeof(*proc), GFP_KERNEL); //初始化结构体的 todo 队列 INIT_LIST_HEAD(&amp;proc-&gt;todo); //初始化结构体的 wait 队列 init_waitqueue_head(&amp;proc-&gt;wait); //加锁 binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); //将当前进程,也就是 ServiceManager 的结构体添加到 Binder 的一个全局队列中 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); filp-&gt;private_data = proc; //释放锁 binder_unlock(__func__); return 0;&#125; 首先我们需要知道的是每一个作为服务端的进程,都对应在 Binder 驱动中的一个节点 todo 队列保存的是请求的事务，如果一个客户端发起一个请求,那么就会向 todo 队列添加一个事务。 wait 队列,将客户端发起请求后等待响应添加到 wait 等待队列,待服务端执行完后就唤醒。 由于发起 Binder 线程的情况有很多但是每个进程只创建一个对应的结构体添加到链表里，因此就需要加锁。 ServiceManager 注册后的情况就是如下图： (2)将 servicemanager 驱动设置为唯一的管理者,并设置为 0 号 handler前面说过 servicemanager 管理者其他服务端,客户端可以通过 serviceManger 查询对应的 Binder 服务端,这个查询的过程就是寻找服务端进程对应的在 binder 中的 “号码”, 这些号码由 servicemanager 统一管理,那么 servicemanager 自己的号码注册为 0 号。 这好比网络传输中获取服务端的 ip 地址首先要通过 DNS 查询,而这个 DNS 的 ip 地址都是已知的。 这里的就是 0 号,“号码”称为 handler12345678910// if (binder_become_context_manager(bs)) &#123; ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno)); return -1; &#125;int binder_become_context_manager(struct binder_state *bs)&#123; return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);&#125; //调用到内核的 ioctl,参数是 BINDER_SET_CONTEXT_MGR1234567891011static int binder_ioctl_set_ctx_mgr(struct file *filp)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; struct binder_context *context = proc-&gt;context; //新建一个节点 ，第二个参数是 0 context-&gt;binder_context_mgr_node = binder_new_node(proc, 0, 0); return ret;&#125; 123456789101112131415161718192021222324252627282930static struct binder_node *binder_new_node(struct binder_proc *proc, binder_uintptr_t ptr, binder_uintptr_t cookie)&#123; struct rb_node **p = &amp;proc-&gt;nodes.rb_node; struct rb_node *parent = NULL; struct binder_node *node; //插入这个节点 while (*p) &#123; parent = *p; node = rb_entry(parent, struct binder_node, rb_node); if (ptr &lt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_left; else if (ptr &gt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_right; else return NULL; &#125; node-&gt;proc = proc; //ptr 指的就是用户空间的一个引用，因此这个参数为 0 //所以 serviceManger 在客户端的对应的 binder 对象就是 0 号引用获得的。 node-&gt;ptr = ptr; return node;&#125; (二).ServiceManager Binder 的获取我们知道 ServiceManager 作为一个进程,客户端于其的通信也是一种进程通信,从上面可以知道 ServiceManager 对应的 Binder 是 0 号引用,那么客户端是是如何获取的到 0 号引用即 ServiceManager 的 Binder 对象呢？ 以 bindService 为例1234567891011//base\core\java\android\app\ContextImpl.java private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; ... //bindService 是通过 ActivityManager.getService() 去调用的 int res = ActivityManager.getService().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); ... &#125; 在 ActivityManager 中123456789101112131415//base\core\java\android\app\ActivityManager.javapublic static IActivityManager getService() &#123; return IActivityManagerSingleton.get(); &#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; //要获取 IActivityManager 对象,就要通过 ServiceManager 去查询并获取 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 1234567891011121314151617181920212223242526272829303132// base\core\java\android\os\ServiceManager.java//通过一个 服务的名字去获取对应的 Binder public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; //这里就是先通过 getIServiceManager 去查询,再返回 return Binder.allowBlocking(getIServiceManager().getService(name)); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;error in getService&quot;, e); &#125; return null; &#125; //获取 ServiceManager Binder 对象 IServiceManager 就在这个 方法里 private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager //关键是这里的 BinderInternal.getContextObject(); sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; &#125; //显然对应的方法就在 BinderInternal.getContextObject();12//base\core\java\com\android\internal\os\BinderInternal.java public static final native IBinder getContextObject(); 这是个 native 方法对应 c++ 实现如下123456//base\core\jni\android_util_Binder.cppstatic jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125; android_util_Binder 的作用就是将 c/c++ 的 Binder 对象转换为 java 层。接着看 ProcessState 的 getContextObject 方法 12345// native\native\libs\binder\ProcessState.cppsp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125; 这个 0 就是之前说过的 ServiceManager 在 Binder 驱动中对应的引用号 hanler，这里就为 0 .即 ServiceManager 为 0 号。1234567891011121314151617181920212223242526272829sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) &#123; IBinder* b = e-&gt;binder; if (b == nullptr || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; //当 handle == 0 的时候 if (handle == 0) &#123; //在 handle == 0 的情况下 //因为 ServiceManager 唯一我们在创建其代理类的时候 //不需要持有其引用的对象，因为其引用号已知为 0 //所以通过简单的远程访问确定其已经注册否则 //ServiceManager 就不能使用。 Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; &#125; &#125; return result;&#125; 在说明 new BpBinder(handle) 的作用之前,这里记录下一个疑问 ServiceManager 对应在 native 层的是 IServiceManager.cpp 但是从上面的调用链来看并没有涉及到,可能是 c/c++ 的语法或者是有部分源码看漏了,这里先借用其他文章的思路,直接看 IServiceManager。 1234567891011121314151617//native\native\libs\binder\IServiceManager.cppsp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != nullptr) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == nullptr) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(nullptr)); if (gDefaultServiceManager == nullptr) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125; 这个获取 的过程可以参考 浅谈Android系统进程间通信（IPC）机制Binder中的Server和Client获得Service Manager接口之路 总结 一般跨进程的通信首先要需要通过 ServiceManager 获取对方的代理接口才能通信,但是 对于 ServiceManager 自己的代理接口的获取过程不需要跨进程,因为其引用号已知 为 0. 如果是同一个进程的的通信,客户端 透过 Binder 驱动向 服务端 请求一个 Binder 代理对象时，Binder 驱动发现它们是同一个进程，就向 客户端 进程返回一个 Binder 本地对象，而不是 Binder 代理对象。 四.通信在客户端拿到 IServiceManager 的 Binder 对象后就将其封装成为一个 代理对象 Proxy123456789101112//base\core\java\android\os\ServiceManager.javaprivate static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; &#125; 下面具体看 ServiceManagerNative的asInterface12345678910111213static public IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj); &#125; 这部分代码对于手动写过 Binder 客户端服务端的人都比较熟悉,主要是判断获取的接口是位于同一进程还是 不同进程，如果是统一进程,则不需要进行跨进程的通信,所以返回本地接口/对象就像就行，如果是不同进程,就返回一个代理对象,下面看如何通过跨进程通信。 以向 SericeManager 获取服务为例1234567891011121314151617181920class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; &#125; 下面就对 getService 的几个变量做一下说明 data ,向 SericeManager (服务端)传递的参数 上面 writeString 写入数据，writeInterfaceToken 写入接口标识 reply ,SericeManager (服务端 ) 执行后的往 reply 写入返回值 mRemote.transact 进行跨进程传输，这个返回会阻塞于 Binder 线程池，因为要等待其 SericeManager (服务端) 返回 reply.readStrongBinder() 服务端返回后唤醒当前 Binder 线程,读取查询后的 Binder 对象。 1.ParcelParcel 是传递的数据的载体,在 java 层和 native 都有对应的类。主要的传输过程都在 transact 函数中。 2.transact123456789101112131415161718192021//base\core\jni\android_util_Binder.cppstatic jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; //将 java 层的对应的 Parcel 对应到 native 层 Parcel* data = parcelForJavaObject(env, dataObj); Parcel* reply = parcelForJavaObject(env, replyObj); //获取native 层的Binder 对象 IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); //调用 native 层的 Binder 的 方法 status_t err = target-&gt;transact(code, *data, reply, flags); reply-&gt;print(); return JNI_FALSE; 最后都会调用 Binder 驱动的 binder_transaction 方法。1234567891011121314151617181920212223242526272829303132static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; // 由 handle 找到相应 binder 引用, 由binder引用 找到相应 binder 节点 ref = binder_get_ref(proc, tr-&gt;target.handle); target_node = ref-&gt;node; &#125; else &#123; target_node = binder_context_mgr_node; &#125; // 由 binder 节点 找到相应 binder proc 结构体 target_proc = target_node-&gt;proc; &#125; //从目标进程 proc 中分配内存空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); //分别拷贝用户空间的 binder_transaction_data 到目标进程的 binder 缓冲区 copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size); copy_from_user(offp, (const void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size); ... return;&#125; 流程如下 通过这种方式数据的传递就从 A 进程到了 Service 进程。 关于 Binder 的机制,这里只是记录笔者的自己理一遍的思路，如果想要深入学习，可以参考一下博客，本篇也是参考其博客才写下的。 Gityuan 的 Binder系列 Binder学习指南 Android Bander设计与实现 - 设计篇 一篇文章了解相见恨晚的 Android Binder 进程间通讯机制 Android进程间通信（IPC）机制Binder简要介绍和学习计划 图文详解 Android Binder跨进程通信的原理]]></content>
      <tags>
        <tag>Android Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----TreeSet]]></title>
    <url>%2F2019%2F01%2F17%2Fjava%E9%9B%86%E5%90%88-TreeSet%2F</url>
    <content type="text"><![CDATA[一.前言TreeSet 是java 集合中 Set 分支下的一个集合，其存储的元素会根据 key 的大小进行排序，下面就看看 TreeSet 的具体实现。 二.分析1.简介 下面引用自源码的注释翻译 TreeSet 是基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 此实现为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。 注意，如果要正确实现 Set 接口，则 set 维护的顺序（无论是否提供了显式比较器）必须与 equals 一致。（关于与 equals 一致 的精确定义，请参阅 Comparable 或 Comparator。）这是因为 Set 接口是按照 equals 操作定义的，但 TreeSet 实例使用它的 compareTo（或 compare）方法对所有元素进行比较，因此从 set 的观点来看，此方法认为相等的两个元素就是相等的。即使 set 的顺序与 equals 不一致，其行为也是 定义良好的；它只是违背了 Set 接口的常规协定。 注意，此实现不是同步的。如果多个线程同时访问一个 TreeSet，而其中至少一个线程修改了该 set，那么它必须 外部同步。这一般是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSortedSet 方法来“包装”该 set。此操作最好在创建时进行，以防止对 set 的意外非同步访问：SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…)); 此类的 iterator 方法返回的迭代器是快速失败 的：在创建迭代器之后，如果从结构上对 set 进行修改，除非通过迭代器自身的 remove 方法，否则在其他任何时间以任何方式进行修改都将导致迭代器抛出 ConcurrentModificationException。因此，对于并发的修改，迭代器很快就完全失败，而不会冒着在将来不确定的时间发生不确定行为的风险。 注意，迭代器的快速失败行为无法得到保证，一般来说，存在不同步的并发修改时，不可能作出任何肯定的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测 bug。 总结如下： TreeSet 的内部实现是通过 TreeMap 来支持的 TreeSet 的查找添加删除等操作的时间复杂度都是 O(logn) TreeSet 的比较是通过 compare 或者 compareTo 来判断的或者排序的 TreeSet 不是线程安全的，如果需要同步可以需要 synchronizedSortedSet 进行同步的包装。 TreeSet 的迭代器采用的快速失败的机制，也就是说如果生成了一个迭代器，如果这个时候对集合进行了修改，迭代器就会失效，除非是迭代器的 remove 方法。 2.变量12345//提供支持的 mapprivate transient NavigableMap&lt;E,Object&gt; m;//因为内部的实现是一个 Map , 所以就需要一个//虚拟的 value 作为所有的 key 的 valueprivate static final Object PRESENT = new Object(); 3.构造器123456789101112131415161718192021222324TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m;&#125; public TreeSet() &#123; this(new TreeMap&lt;&gt;());&#125;public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator));&#125;public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s);&#125; 从上面的构造器中可以看出，对于普通的 TreeSet ，最后都是交由 TreeMap 去实现。 4.增删该查123456789101112131415161718192021222324252627public int size() &#123; return m.size();&#125; public boolean isEmpty() &#123; return m.isEmpty();&#125;public boolean contains(Object o) &#123; return m.containsKey(o);&#125;public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return m.remove(o)==PRESENT;&#125; public void clear() &#123; m.clear();&#125; 可以看到所有的实现，最后都对应着 TreeMap 的实现，详细可以看这篇 java集合—-TreeMap，这里就不做重复地分析了。]]></content>
      <tags>
        <tag>java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----TreeMap]]></title>
    <url>%2F2019%2F01%2F17%2Fjava%E9%9B%86%E5%90%88-TreeMap%2F</url>
    <content type="text"><![CDATA[一.前言对于 Map 接口常见的或者常用的一般都是 HashMap 或者 LinkedHashMap 等，对于 TreeMap 的话在日常开发中使用的较少，但是作为 Map 体系中一个实现类，还是有必要去深入了解的，否则面试的你可能就会栽在这上面。 二.深入分析1.简介 以下内容引用自源码的中的注释 TreeMap 是基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 此实现为 containsKey、get、put 和 remove 操作提供受保证的 log(n) 时间开销。 注意，如果要正确实现 Map 接口，则有序映射所保持的顺序（无论是否明确提供了比较器）都必须与 equals 一致。（关于与 equals 一致 的精确定义，请参阅 Comparable 或 Comparator）。这是因为 Map 接口是按照 equals 操作定义的，但有序映射使用它的 compareTo（或 compare）方法对所有键进行比较，因此从有序映射的观点来看，此方法认为相等的两个键就是相等的。即使排序与 equals 不一致，有序映射的行为仍然是 定义良好的，只不过没有遵守 Map 接口的常规协定。 注意，此实现不是同步的。如果多个线程同时访问一个映射，并且其中至少一个线程从结构上修改了该映射，则其必须 外部同步。（结构上的修改是指添加或删除一个或多个映射关系的操作；仅改变与现有键关联的值不是结构上的修改。）这一般是通过对自然封装该映射的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSortedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的不同步访问，如下所示：SortedMap m = Collections.synchronizedSortedMap(new TreeMap(…)); collection（由此类所有的“collection 视图方法”返回）的 iterator 方法返回的迭代器都是快速失败 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 remove 方法，否则在其他任何时间以任何方式进行修改都将导致迭代器抛出 ConcurrentModificationException。因此，对于并发的修改，迭代器很快就完全失败，而不会冒着在将来不确定的时间发生不确定行为的风险。 注意，迭代器的快速失败行为无法得到保证，一般来说，当存在不同步的并发修改时，不可能作出任何肯定的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测 bug。 此类及其视图中的方法返回的所有 Map.Entry 对都表示生成它们时的映射关系的快照。它们不 支持 Entry.setValue 方法。（不过要注意的是，使用 put 更改相关映射中的映射关系是有可能的。） 总结几个点如下： TreeMap 是基于红黑树的实现的一个 Map , 会根据 key 节点的值进行排序，默认是key 的自然排序 因为是基于红黑树的，所以增删改查都是基于红黑树的增删改查，因此时间复杂度都是一个 log(n) 级的 对于 key 的 判断也是通过 key 的 equals 方法进行判断的。 TreeMap 不是线程安全的，在多线程并发的情况下需要同步，可以使用 Collections 的同步包装方法。 对于 TreeMap 返回的迭代器后，对 TreeMap 的修改都会导致迭代器失效，除了迭代器自身的 remove 方法。 2.变量123456789101112 //排序的比较器 private final Comparator&lt;? super K&gt; comparator;//TreeMap 的红黑树的根节点 private transient Entry&lt;K,V&gt; root;//集合的元素数量 private transient int size = 0;//快速失败机制的 修改数//可以根据这个变量判断是否集合被修改 private transient int modCount = 0; 从上面的几个变量中，可以看出 TreeMap 的内部结构就是保存着一棵红黑树的根节点，不像 HashMap 那样是个数组。 3.构造方法123456789101112131415161718192021222324252627// 默认 对 key 的自然排序 public TreeMap() &#123; comparator = null; &#125; //指定比较器的排序 public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125;//给定 map 集合元素的排序 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m); &#125; //给定一个比较器和 map 集合元素的排序 //这个就是将有序的 map 集合转换为红黑树实现 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException | ClassNotFoundException cannotHappen) &#123; &#125; &#125; 4.插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public V put(K key, V value) &#123; //根节点 Entry&lt;K,V&gt; t = root; //如果根节点 为 null //就将插入的节点作为根节点 //然后返回 if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; //往红黑树中去插入 int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //如果有指定的 comparator 就使用指定的 // 比较器去比较 if (cpr != null) &#123; do &#123; parent = t; //注意这里的方法是通过比较器的 // compare 方法 //而不是 key 的 hashCode 或者 equals //因为要排序 cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else //找到值就更新， //说明如果 TreeMap 对于 元素 //是通过 compare 比较并保证不重复的 return t.setValue(value); &#125; while (t != null); &#125; else &#123; //如果没有指定的 comparator 就使用 key 的 //compareTo 方法。 //这里也表明这 TreeMap 不允许元素为空值 if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; //如果有没有找到这个节点，或者说这个新的节点 //就创建一个节点插入，然后进行红黑树的调整。 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125; 5.查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance //如果有指定的比较器 //就调用下面这个方法 if (comparator != null) return getEntryUsingComparator(key); //不允许 key 为 空 if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //从红黑树中去查找 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125; final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; @SuppressWarnings("unchecked") K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; &#125; return null;&#125; 对于 TreeMap 的插入和查找过程总结如下 TreeMap 不允许 key 为 null 不存在两个元素的 compare 或者 compareTo 返回 0 的情况。 因为每次都是从树中去查找，所以时间复杂度为 O(log n) 6.和 HashMap 的区别 TreeMap 是红黑树，有一个根节点的变量，HashMap 是通过数组+链表/红黑树 实现 TreeMap 没有涉及到 equals/hashCode 方法，排序是通过 compare/compareTo 方法进行比较大小， HashMap 涉及到了 hashCode /equals 方法。 增删改查性能比较，TreeMap 为 O(logn) , HashMap 为 O(1) -&gt; O(logn)总和来说，HashMap 比较快。]]></content>
      <tags>
        <tag>java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----HashSet]]></title>
    <url>%2F2019%2F01%2F16%2Fjava%E9%9B%86%E5%90%88-HashSet%2F</url>
    <content type="text"><![CDATA[一.前言 java集合—-Set HashSet 是 Set 接口的一个实现类，当然就具有 Set 接口指定的一些规范。即所有在集合中的元素都是唯一的，那么 HashSet 是如何保证添加的元素的一个唯一性呢，这其中除了equals 还涉及到其他方法吗？ 下面对 HashSet 的源码进行一个深入的了解。 二.深入解析1.简介 下面引用自源码中的注释 HashSet 实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序;(也就是添加顺序)特别是它不保证该顺序恒久不变。允许使用 null 元素。 注意，HashSet 不是同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：Set s = Collections.synchronizedSet(new HashSet(…)); 此类的 iterator 方法返回的迭代器是快速失败 的：在创建迭代器之后，如果对 set 进行修改，除非通过迭代器自身的 remove 方法，否则在任何时间以任何方式对其进行修改，Iterator 都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来在某个不确定时间发生任意不确定行为的风险。 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器在尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误做法：迭代器的快速失败行为应该仅用于检测 bug。 2.变量HashSet 自身增加的变量只有三个12345678910//用于序列化和反序列化的 UID static final long serialVersionUID = -5024744406713321676L; //为 HashSet 提供具体实现的 map private transient HashMap&lt;E,Object&gt; map; //因为 HashSet 是保存一个简单元素 //而Map 存储的 key--value //所以就创建一个虚拟的 value 值 private static final Object PRESENT = new Object(); 3.构造器12345678910111213141516171819202122232425262728 //默认的构造器，内部是创建一个 HashMap public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; //指定初始元素的构造器 public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; //指定一个初始容量和增长因子的 HashSet public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125;//指定一个初始容量的 HashSet public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; // default 权限的构造器 //这个构造器只是用在创建 LinkedHashSet HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 从 HashSet 的几个变量和构造器可以看出，内部的过程其实都是使用创建出一个 HashMap ，包括指定初始容量和增长因子等都是内部创建一个 HashMap 。 4.add 方法123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet 内部是由 HashMap 提供实现的，且 HashSet 中的元素都是作为 HashMap 的一个 key ,那么 value 就都是同一个对象，即 PRESENT 。 那么到这里，对于 HashSet 如何保证元素唯一的问题其实就转换为 HashMap 中 如何保证 key 的唯一性。 下面到 HashMap 的一个 put 方法中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public V put(K key, V value) &#123; // 注意这里的前前两个参数 //一个是 key 经过 hash 函数处理后的值 //一个是 key 的原值 return putVal(hash(key), key, value, false, true);&#125;//这里对源码进行一些删除，只关注我们需要的地方即可//版本 ：JDK 10final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table 为 null 或者 //table 数组长度为 0 的话就进行 //resize() 进行初始化。 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果根据 key的 hashCode 处理后的 hash 值 //定位到数组位置为 null 的话就直接创建一个节点。 //不需要进行判断两个元素是否相等。 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 否则就需要进行判断 else &#123; Node&lt;K,V&gt; e; K k; //判断两个元素是否是同一个元素的判断就在这里 //第一个情况是 两个对象处理 hash 值是相等的并且 key 也是同一个 key // 第二种是 key 的 equals 方法。 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //这是去红黑树插入 else if (p instanceof TreeNode) //这是根据节点插入。 else &#123; &#125; //e 不为null ,put 返回的参数就不为 null if (e != null) &#123; // existing mapping for key V oldValue = e.value; .. return oldValue; &#125; &#125; //如果在第一次进行判断时数组对应位置没有被初始化， //就说明是第一次添加，也就是没有重复，这里就返回 null. //在 HashSet 的 add 方法中 map.put(e, PRESENT)==null; //就返回 true ,也就是没有重复，添加成功。 //否则就是上面 e != null 情况，就说明 重复添加了， //map.put(e, PRESENT)==null; 返回 false return null; &#125; &#125; 从上面的注释已经可以知道 HashSet 是如果判断一个元素是否重复的，总结如下： 通过 key 的 hashCode 定位到数组位置，如果刚好为 null,第一次添加，就不重复。 如果不为 null, 因为 hashCode 可能存在着从重复（哈希冲突），所以需要结合 equals 进行判断。 key 为 null 或者 不为 null 的情况，如果 hash 相等，并且 key == 返回 true ,即是同一个对象 ，重复（这种情况判断了 key 为 null 和 同一个对象的情况） key 不 null 的情况，且不是同一个对象（== 返回 false ）,但是 equals 返回 true , 仍然是重复（这种情况就盘判断了我们定义的 对象相等的情况 即 equals 返回 true ）。 因此这里就要注意，对于一个类，如果重写其 equals，就要保证 equals返回 true 的时候，hashCode 返回相同的值 ，hashCode 返回不同的值的时候， equals返回 false 因为 判断一个对象是否重复在 HashSet 中其实使用了这两个方法，进行判断。 5.其他1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; public void clear() &#123; map.clear();&#125; @SuppressWarnings("unchecked")public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(e); &#125;&#125;private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (E e : map.keySet()) s.writeObject(e);&#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity &lt; 0) &#123; throw new InvalidObjectException("Illegal capacity: " + capacity); &#125; // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123; throw new InvalidObjectException("Illegal load factor: " + loadFactor); &#125; // Read size and verify non-negative. int size = s.readInt(); if (size &lt; 0) &#123; throw new InvalidObjectException("Illegal size: " + size); &#125; // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Constructing the backing map will lazily create an array when the first element is // added, so check it before construction. Call HashMap.tableSizeFor to compute the // actual allocation size. Check Map.Entry[].class since it's the nearest public type to // what is actually created. SharedSecrets.getJavaObjectInputStreamAccess() .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity)); // Create backing HashMap map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;&gt;(capacity, loadFactor) : new HashMap&lt;&gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; @SuppressWarnings("unchecked") E e = (E) s.readObject(); map.put(e, PRESENT); &#125;&#125; public Spliterator&lt;E&gt; spliterator() &#123; return new HashMap.KeySpliterator&lt;&gt;(map, 0, -1, 0, 0);&#125; 其实只要清楚了 HashSet 的判断重复的原理，对于删除等其他操作，就很简单了，都是基于查找过程。对于其他方法，也就是通过 HashMap 结合使用，这里就不进行深究了。]]></content>
      <tags>
        <tag>java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----Set]]></title>
    <url>%2F2019%2F01%2F16%2Fjava%E9%9B%86%E5%90%88-Set%2F</url>
    <content type="text"><![CDATA[一.前言今天面试，上来第一个问题就是关于 Set 集合,因为之前做的准备都是什么 HashMap 啊, List 之类的，但是对于 Set 集合没有做过多的了解，所以一时语塞。看来基础是不能挑着学的。全部掌握才不怕。 二.Set 接口1.简介 以下内容引用自 源码中的注释 Set 集合是一个不包含重复元素的集合。更确切地讲，set 不包含满足对于两个存在Set 中对象 e1 和 e2， e1.equals(e2) 的元素，并且最多包含一个 null 元素。 注：如果将可变对象用作 set 元素，那么必须极其小心。如果对象是 set 中某个元素，如果以一种影响 equals 比较的方式改变对象的值，那么 set 的行为就是不确定的。此项禁止的一个特殊情况是不允许某个 set 包含其自身作为元素。 总的来说：就是 Set 集合中存储的元素是不能存在重复的，且存储在 Set 集合中的元素如果一个可变的对象，则对对象的操作就千万不能使这个对象的 equals 方法发生变化，否则就会使 Set 集合处于未知的状态，因为 Set 集合保证对象唯一的条件的是通过 equals 方法来判断的。 2.Set 接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123; //返回 Set 集合元素的数量，最多为 Integer.MAX_VALUE int size(); //判断是否包含元素 boolean isEmpty(); //判断 Set 集合是否包含一个指定的元素 o, //更确切地讲，是判断 Set 是否存在一个元素 o1 //使得 o1.equals(o) 返回 true. boolean contains(Object o); //返回一个 Set 集合的迭代器，具体元素的顺序交给子类去实现。 Iterator&lt;E&gt; iterator(); //以数组的形式返回集合中的元素，顺序和上面的 iterator 一样。 Object[] toArray(); //返回一个包含此 set 中所有元素的数组；返回数组的运行时类型是指定数组的类型。 &lt;T&gt; T[] toArray(T[] a); //添加一个不重复的元素，更确切地讲是添加一个元素，并保证集合中的 //任意一个元素 o 都不会使 o.equals(e) 返回 true. boolean add(E e); // 移除以一个元素 boolean remove(Object o); //判断Set 是否包含了 集合 c 的所有元素 boolean containsAll(Collection&lt;?&gt; c); //向Set 添加集合 c 中的元素 boolean addAll(Collection&lt;? extends E&gt; c); //删除所有没有在集合 c 中的元素 boolean retainAll(Collection&lt;?&gt; c); //删除所有在集合 c 的元素 boolean removeAll(Collection&lt;?&gt; c); //清除所有元素 void clear(); //Set 集合自己的equals/hashCode 方法。 boolean equals(Object o); int hashCode(); //创建一个可以分割的迭代器 @Override default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, Spliterator.DISTINCT); &#125; //返回一个不可变的 Set 集合 //下面几个方法都是，参数为集合中固定的元素。 static &lt;E&gt; Set&lt;E&gt; of() &#123; return ImmutableCollections.Set0.instance(); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1) &#123; return new ImmutableCollections.Set1&lt;&gt;(e1); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2) &#123; return new ImmutableCollections.Set2&lt;&gt;(e1, e2); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9); &#125; static &lt;E&gt; Set&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) &#123; return new ImmutableCollections.SetN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10); &#125; @SafeVarargs @SuppressWarnings("varargs") static &lt;E&gt; Set&lt;E&gt; of(E... elements) &#123; switch (elements.length) &#123; // implicit null check of elements case 0: return ImmutableCollections.Set0.instance(); case 1: return new ImmutableCollections.Set1&lt;&gt;(elements[0]); case 2: return new ImmutableCollections.Set2&lt;&gt;(elements[0], elements[1]); default: return new ImmutableCollections.SetN&lt;&gt;(elements); &#125; &#125; //复制一个 Set 集合，返回的是一个不可变得Set 集合 @SuppressWarnings("unchecked") static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123; if (coll instanceof ImmutableCollections.AbstractImmutableSet) &#123; return (Set&lt;E&gt;)coll; &#125; else &#123; return (Set&lt;E&gt;)Set.of(new HashSet&lt;&gt;(coll).toArray()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode173----二叉搜索树迭代器]]></title>
    <url>%2F2019%2F01%2F12%2FLeetCode173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[问题实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。 调用 next() 将返回二叉搜索树中的下一个最小的数。 示例： 12345678910BSTIterator iterator = new BSTIterator(root);iterator.next(); // 返回 3iterator.next(); // 返回 7iterator.hasNext(); // 返回 trueiterator.next(); // 返回 9iterator.hasNext(); // 返回 trueiterator.next(); // 返回 15iterator.hasNext(); // 返回 trueiterator.next(); // 返回 20iterator.hasNext(); // 返回 false 提示： next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。 解法 题目的意思就是放回根据搜索二叉树的排序顺序，迭代返回节点。 首先要了解搜索二叉树的一些特性 对于一个节点，其左孩子比它小，右孩子比它大。 其左右子树都满足搜索二叉树的特性 以这个图为例： 总结： 初始化的时候，首先将根节点的左孩子入栈，然后再将其左孩子的左孩子入栈，知道没有左孩子。 next 方法，从栈中 pop 出返回，再返回之前判断其右孩子为不为空，不为空就将其右孩子入栈，并从其右孩子开始，将其左孩子入栈，操作和初始化将根节点一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class BSTIterator &#123; TreeNode node ; Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) &#123; node = root; stack = new Stack&lt;&gt;(); while(node!=null)&#123; stack.push(node); node = node.left; &#125; &#125; /** @return the next smallest number */ public int next() &#123; int val ; node = stack.pop(); val = node.val; node = node.right; while(node!=null)&#123; stack.push(node); node = node.left; &#125; return val; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stack.isEmpty(); &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode144-94-145----二叉树的前序-中序-后序遍历]]></title>
    <url>%2F2019%2F01%2F11%2FLeetCode144-94-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[问题1给定一个二叉树，返回它的 前序 遍历。 示例: 输入: [1,null,2,3] 输出: [1,2,3] 解法 对于二叉树的前序遍历，可以简化成对下面这个状态的遍历。 这棵树的遍历过程如下： 首先要访问 5 然后就是 5 的左孩子， 然后就是 5 的右孩子 因此就需要保存 5 这个节点，所以应该使用栈保存下来。再看复杂一点的。 可以总结出规律： 节点为空，pop 出一个，访问其右孩子 节点不为空，入栈，记录，然后访问其左孩子 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while(node != null || !stack.isEmpty())&#123; if(node == null)&#123; node = stack.pop(); node = node.right; &#125;else&#123; stack.push(node); list.add(node.val); node = node.left; &#125; &#125; return list; &#125;&#125; 问题2给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 输出: [1,3,2] 对于二叉树的中序遍历，可以简化成对下面这个状态的遍历。 这棵树的遍历过程如下： 首先过 5 然后就是过 5 的左孩子，因为 5的左孩子为 空，所以访问 5 然后就是过 5 的右孩子。 因此就需要保存 5 这个节点，所以应该使用栈保存下来。再看复杂一点的。 可以总结出规律： 节点为空，pop 出一个，记录，访问其右孩子 节点不为空，入栈，然后访问其左孩子12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; while(node != null ||!stack.isEmpty())&#123; if(node == null)&#123; node = stack.pop(); list.add(node.val); node = node.right; &#125;else&#123; stack.push(node); node = node.left; &#125; &#125; return list; &#125;&#125; 问题3给定一个二叉树，返回它的 后序 遍历。示例: 输入: [1,null,2,3] 输出: [3,2,1] 对于二叉树的中序遍历，可以简化成对下面这个状态的遍历。 从右往左，再逆转过来就是后序遍历 先过5，并且记录5，然后过 5 的右孩子 5 的右孩子为空，过 5 的左孩子 5 的左孩子为空 因此就需要保存 5 这个节点，所以应该使用栈保存下来，同时因为5需要 pop,还需要输出栈保存访问路径。再看复杂一点的。 可以总结出规律： 节点为空，pop 出一个，访问其左孩子（这里是左孩子） 节点不为空，入栈，记录，然后访问其右孩子 逆转记录12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode node = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; output = new Stack&lt;&gt;(); while(node != null || !stack.isEmpty())&#123; if(node == null)&#123; node = stack.pop(); node = node.left; &#125;else&#123; stack.push(node); output.push(node); //后续+逆转，所以是先 右孩子 node = node.right; &#125; &#125; while(!output.isEmpty())&#123; list.add(output.pop().val); &#125; return list; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode42----接雨水]]></title>
    <url>%2F2019%2F01%2F07%2FLeetCode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[问题给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 解法雨水的量 = 蓝色的面积+黑色的面积 - 黑色的面积 首先可以知道从左后最高点位置，柱体（蓝+黑）是越来越高的，最右到最高点位置也是。 使用 cur 记录当前的高度 从左到最高点位置，如果当前高度没有高于 cur ,就不用更新cur, 否则就更新 cur . 总的面积就是每个柱形的面积和，即每次遍历的时候就 加上 cur. 加上最高的位置的大小 hegiht[maxIndex] cur 更新为 0 再从右到最高点以同样的方式记录。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)&#123; return 0; &#125; int maxIndex = 0; for(int i= 0 ; i&lt; height.length ;i++)&#123; if(height[maxIndex] &lt; height[i])&#123; maxIndex = i; &#125; &#125; int cur =0; int sum = 0; for(int i=0;i&lt;maxIndex ;i++)&#123; if(height[i] &gt; cur)&#123; cur = height[i]; &#125; sum += cur; &#125; sum += height[maxIndex]; cur = 0; for(int i = height.length -1;i &gt; maxIndex ;i--)&#123; if(height[i] &gt; cur)&#123; cur = height[i]; &#125; sum += cur; &#125; for(int i=0;i&lt; height.length ;i++)&#123; sum-=height[i]; &#125; return sum; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Handler(HandlerA发送的消息HandlerB 能接收吗？)]]></title>
    <url>%2F2019%2F01%2F01%2FAndroid-Handler-HandlerA%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AFHandlerB-%E8%83%BD%E6%8E%A5%E6%94%B6%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一.前言在之前的两篇文章 Handler 消息机制 Handler 消息机制(进阶篇) 中介绍了 Android 中的 Handler ，Looper 和 MessageQueue 的整体工作流程，其中可以知道对于一个 Looper ，可以有多个 Handler 与之绑定（通过 Hanlder 的构造器指定 Looper），那么就产生一个疑问，在同一个线程下，即针对绑定同一个 Looper 的 HanlderA 和 HanlderB ,Hanlder A 发送的消息可以让 HanlderB 接收吗？ 答案是:可以的 二.消息的发送在 Hanlder 消息机制发送消息时指定 Hanlder 主要有下面几种情况。 1.Hanlder 直接发送1234567Message message = Message.obtain();mHandler1.sendMessage(message);//mHandler1.sendMessageAtTime(message,0);//mHandler1.sendEmptyMessage(0);//mHandler1.sendEmptyMessageAtTime(0,0);//mHandler1.sendEmptyMessageDelayed(0,0);//mHandler1.sendMessageAtFrontOfQueue(message); 对于类似上面这种方式，从源码中可以看到其实最后都调用了同一个方法 enqueueMessage 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public final boolean sendMessage(Message msg) &#123; //调用下面的 return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what) &#123; //调用下面的 return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; //调用下面的 sendMessageDelayed return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; //调用下面的 sendMessageAtTime return sendMessageAtTime(msg, uptimeMillis); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; //也是调用 sendMessageAtTime return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; //最后都是调用 enqueueMessage return enqueueMessage(queue, msg, uptimeMillis); &#125; public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; //这里也是调用 enqueueMessage return enqueueMessage(queue, msg, 0); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //注意这里的 msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //在 enqueueMessage 中调用 queue.enqueueMessage return queue.enqueueMessage(msg, uptimeMillis); &#125; 从源码中可以看到，对于类是 Hanlder 直接发送的那种方式，最后都会调用 enqueueMessage 方法，而在 这个方法里 msg.target = this; 这段就是为 消息指定 Hanlder ，这个this ,就是说明 如果 HandlerA 发送了消息，那么 处理这个消息的就是 HanlderA, (这似乎和开头的答案不符，且先保留疑问，继续往下看。) 2.Message sendToTarget123456789 //第一种，在 obtain 的时候指定 Handler。Message message = Message.obtain(mHandler1);//Message message = Message.obtain(mHandler1,....);message.sendToTarget();//或者 使用message.setTarget 指定。Message message = Message.obtain();message.setTarget(mHandler1);message.sendToTarget(); 在这种方式下，看 obtain 指定 Hanlder 的情况或者setTarget 的情况。12345678910111213141516public static Message obtain(Handler h) &#123; Message m = obtain(); //注意这里 m.target = h; return m;&#125; public void setTarget(Handler target) &#123; this.target = target;&#125; public void sendToTarget() &#123; target.sendMessage(this);&#125; 也是直接将 Hanlder 赋值给 Message 的 Target.然后再 sendToTarget 中直接使用 Hander.sendMessage 发送这个消息，那么就回到了第一种情况。 从这两种方式可以看出，最后都是会调用 enqueueMessage 中的方法，并指定 HandlerA 发送 HanlderA 就接收。 可以从下面的例子验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Main2Activity extends AppCompatActivity &#123; private static final String TAG = &quot;Main2Activity&quot;; private Handler1 mHandler1 = new Handler1(); private Hanlder2 mHanlder2 = new Hanlder2(); class Handler1 extends android.os.Handler &#123; @Override public void handleMessage(Message msg) &#123; Log.e(TAG, msg.what + &quot;Handler1+handleMessage: &quot; + msg.getTarget()); &#125; &#125; class Hanlder2 extends Handler &#123; @Override public void handleMessage(Message msg) &#123; Log.e(TAG, msg.what + &quot;Hanlder2+handleMessage: &quot; + msg.getTarget()); &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); findViewById(R.id.btn_1).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = Message.obtain(mHandler1); message.setTarget(mHanlder2);//这里只是将 target 换作 hander2 ，实质上还是 Hander2 发送 message.sendToTarget();// Message message = Message.obtain();// message.setTarget(mHandler1);// message.sendToTarget(); &#125; &#125;).start(); &#125; &#125;); findViewById(R.id.btn_2).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Message message = Message.obtain(); message.what = 2; message.setTarget(mHandler1);//这里没有用，因为下面发送的代码最后还是会重指定 为 handler2 mHanlder2.sendMessage(message); &#125; &#125;); &#125;&#125;//点击 Button1 01-01 17:16:54.440 19403-19403 E/Main2Activity: 0Hanlder2+handleMessage: Handler (.Main2Activity$Hanlder2) &#123;ba26787&#125;//点击 Button201-01 17:17:22.303 19403-19403 E/Main2Activity: 2Hanlder2+handleMessage: Handler (.Main2Activity$Hanlder2) &#123;ba26787&#125; 从结果可以看出，不管之前如何设置 target 或则 obtain 方法参数，最后都是只要是 hander2 发送 就 Hander2 接收。 那么答案的可以是如何实现的？其实很简单1234567891011121314findViewById(R.id.btn_2).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Message message = Message.obtain(); message.what = 2; //和上面的代码不一样的是这两段互换了位置 //先发送 mHanlder2.sendMessage(message); //后指定 target message.setTarget(mHandler1); &#125; &#125;); 点击 Button2101-01 17:23:03.157 20678-20678 E/Main2Activity: 2Handler1+handleMessage: Handler (.Main2Activity$Handler1) &#123;b226bc6&#125; 可以看到对于 Hander2 发送的消息，最后回到了 Handler1 这里去执行。这是为什么？在 enqueueMessage 中最后是调用了 MessageQueue 的 enququMessage1234567891011121314151617181920212223242526boolean enqueueMessage(Message msg, long when) &#123; synchronized (this) &#123; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; //对于发送的 消息， if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; //mBlocked 为true 的时候是当消息队列中没有消息的时候 &#125; //唤醒 JNI 中的线程 // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 我们知道在 Looper 循环获取消息的时候，都是从 MessageQueue 中的next 方法去获取一个消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //当没有消息的时候，这里就会阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. // 有消息的时候就不阻塞 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //如果没有消息了 pendingIdleHandlerCount 就不会改动，为 -1 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; //那个就会执行这里 if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. //Loop 陷入等待。 mBlocked = true; continue; &#125; &#125;&#125; 从上面可以看出，当执行到 enqueueMessage 这里的时候，会先去执行 native 方法的唤醒操作，而这个时候，已经不是在 java 这里的主线程，因此主线程继续执行，所以就更改了 Message 的 Target ,然后在分发的时候，因为 target 已经变了，所以就换到 Hander212345678try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; 这里的时间间隔其实很短，之后过一段时间再执行 setTarget 就会失效。12345678910 Message message = Message.obtain();message.what = 2;mHanlder2.sendMessage(message);try &#123; Thread.sleep(1);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;//这里就无效了message.setTarget(mHandler1); 因此，其实 得出结论 HandlerA发送的消息HandlerB 能接收的。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----LayoutInflater 生成 View 原理]]></title>
    <url>%2F2018%2F12%2F28%2FAndroid-LayoutInflater-%E7%94%9F%E6%88%90-View-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一.前言在 Android 中，通常需要指定一个布局的时候，通常都是在 xml 文件中通过不同的标签指定我们需要的控件，但是在 Activity 中是可以直接通过 Java 对象获取到我们需要的 View 对象的，而从一个 xml 文件转换为一个 View 对象或者 ViewGroup 对象的这个过程，就是通过 LayoutInflater 完成的。 二.原理1.setContentView在一个 Activity 中，指定一个 Activity 的布局就是直接通过 setContentView 方法来完成的。1234public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar(); &#125; 可知 Activity 的 setContentView 实际上又是调用 window 的 setContentView ，而 window 的实现类就是 PhoneWindow 。所以在 Phone 中可以看到下面的实现。123456789101112131415161718192021222324252627282930 // This is the view in which the window contents are placed. It is either // mDecor itself, or a child of mDecor where the contents go. ViewGroup mContentParent; @Override public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; // 注意这里，使用了 mLayoutInflater mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125; 从 PhoneWindow 中可以看到 setContentView 最后还是调用了 mLayoutInflater.inflate 方法，而 mContentParent 从注释中就可以这出这个要么是 DecorView 也就是 FrameLayout,要么就是 FrameLayout 的一个子布局。下面就看 LayoutInflater 的 inflate 方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null); &#125; //调用下面的方法 public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); &#125; //获取一个 xml 的解析器 final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125; &#125; // 再次调用下面的 public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. //首先寻找根节点 int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; //如果根节点的 标签和 start 和 end 不一致就抛出异常 if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); &#125; // final String name = parser.getName(); if (DEBUG) &#123; System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); &#125; //如果是 Merge 标签 if (TAG_MERGE.equals(name)) &#123; //但是 root 为 null 或者每一个 依附于一个 root //就需要抛出异常，因为 Merge 不能单独存在 if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; //对 Merge 标签去递归解析下面的 标签 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; //如果是普通的标签 //就通过 createViewFromTag 反射出来一个 View // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println(&quot;Creating params from root: &quot; + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; //然后再去递归 解析 子布局 if (DEBUG) &#123; System.out.println(&quot;-----&gt; start inflating children&quot;); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println(&quot;-----&gt; done inflating children&quot;); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. //如果 root 不为 空并且 attachToRoot 为 true //就把生成的 View 添加到 root 中。 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. //如果没有就 直接返回生成的 View if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; .... return result; &#125; &#125; 对于 setContentView 来说，因为指定了 root 为 FrameLayout ,所以上述过程实际上就是 将生成的View 添加到 FrameLayout。 2.LayoutInflate在 RecyclerView 中添加一个 item 的时候经常可以见到类似下面这段代码。1LayoutInflater.from(mContext).inflate(R.layout.item_app, parent, false) 这实际上就是 Android 中获取 LayoutInflater 的一种方式，最后会调用到12LayoutInflater layoutInflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); 可见 layoutInflater 也是一个系统的服务。inflate 方法接收三个参数： int resource:布局文件 xml 的资源 id ViewGroup root:如果 attchToRoot 为 true 的话，root 作为父布局 boolean attachToRoot:是否加载到 root 布局中对于这个后面两个的作用就是： 如果 root 为 null，就直接将生成的 View 返回 如果 root 不为 null，attachToRoot 为 true，则会给加载的布局文件的指定一个父布局，即 root，并将生成的 View 添加到 Root 中，但是当该 view 被添加到父 view 当中时， 布局文件中的最外层的 View 的 layout 属性就没作用。 如果 root 不为 null，attachToRoot 为 false，则当该 view 被添加到父 view 当中时，布局文件最外层的所有 layout 属性生效。 在不设置 attachToRoot 参数的情况下，attachToRoot = root != null; 以 RecyclerView 中添加一个 item 为例,最后的 attachToRoot 为 false 时1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;60dp&quot; android:orientation=&quot;vertical&quot;&gt;&lt;/LinearLayout&gt; layout_width 和 layout_height 都没有作用，这也就是说 layout_xx 属性的生效前提是 他们有一个 父布局，对于 setContentView 那肯定就是 FrameLayout ，因此如果要让这两个属性生效的话，attachToRoot 就应该置为 false ,这也就是为什么在 给 RecyclerView 添加 item 的时候需要设置为 false ,因为一个 item 并不需要填满整个 View . 三.总结LayoutInflater 生成 View 树 1.调用 XML 解析器将 xml 资源解析成 XmlResourceParser 对象作为参数传递给 inflate(parser, root, attachToRoot); 方法 2.遍历查找当前 xml 资源文件的根节点如果没有就抛出异常，解析失败 3.用 createViewFromTag 方法，该方法根据当前根节点的名称和属性名创建一个 root View。 4.调用 rInflate 方法，遍历 xml 资源根布局 root view 下的子元素，并且将子元素view依次添加到 root view下面 5.根据当前view的节点名称和属性调用 createViewFromTag 方法创建子元素 view，然后递归调用 rInflate 方法，遍历子元素 View 的所有子元素，依次类推。最终生成 View 树. inflate 三个参数的作用： 如果 root 为 null，就直接将生成的 View 返回 如果 root 不为 null，attachToRoot 为 true，则会给加载的布局文件的指定一个父布局，即 root，并将生成的 View 添加到 Root 中，但是当该 view 被添加到父 view 当中时， 布局文件中的最外层的 View 的 layout 属性就没作用。 如果 root 不为 null，attachToRoot 为 false，则当该 view 被添加到父 view 当中时，布局文件最外层的所有 layout 属性生效。 在不设置 attachToRoot 参数的情况下，attachToRoot = root != null;]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Handler消息机制（进阶篇）]]></title>
    <url>%2F2018%2F11%2F17%2FAndroid-Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一.前言前不久写过一篇 Android—-Handler消息机制，那篇文章只是对 Android 中的 Hanlder 机制的简单介绍，最近又重新回顾一下，发现了之前许多没有注意到的细节，因此就增加一篇 进阶篇。 Android—-Handler消息机制 二.简介Android 中的消息机制主要是指 Handler 的运行机制和在 MessageQueue 和 Looper 的配合下 将一个线程中的任务切换到 Hanlder 所在的线程去执行。在 Android 中常常用来在子线程将更新UI 的结果传递个 UI 线程，从而在 UI 线程更新 UI 。 实际上 Handler 消息机制的作用并不仅仅是更新 UI ，还包括对 Activity 的协调执行 Activity 的生命周期等，只是在 Handler 机制中常常以 子线程更新 UI 为例子讲述其中的原理而已。至于为什么 UI 为什么不能在子线程更新，从设计的角度上看可以看下面这段。 《Android 开发艺术探索》中这样描述：Android 的 UI 控件不是线程安全的，如果多个线程并发访问控件会导致控件的状态不可预期，这和多线程访问同一的变量是一个道理，但是控件却不能像简单的变量一样加上锁机制就可以实现线程同步，因为这会降低 UI 的访问效率。所以采用单线程的模式通过 Handler 切换可以实现 UI 的更新。 三.原理分析下面就从 UI 线程初始化，整个消息机制开始作用，到发送一个 消息是如果作用的这个过程讲述一下 Hanlder 机制的过程。 1.初始化我们都知道一个 App 启动的时候首先会从 Zygote 进程 fork 出一个 App 进程，启动 Binder 线程池（这是 Native 层的），然后会开启 UI 线程 ActivityThread （main 方法是 Java 层的）， 但是看过源码的都知道 ActivityThread 并不是 Thread 类的子类，但是它有 main 方法，所以可以说 ActivityThread 是依附在进程的第一个线程，不需要通过继承 Thread 。 下面看 ActivityThread 的 Main 方法。12345678910111213141516public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); thread.attach(false); ... if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); &#125; 对上面的逻辑其实就很简单，分为下面步骤 创建主线程的 Looper , 和 MessageQueue 开启一个 Binder 线程， thread.attach(false) 。 获取 UI 线程（即主线程） 的 Handler,这个主要是用于执行 Activity 的生命周期或者其他用的。 开启 Looper 循环。 首先来看 Loop 的几个变量123456789101112// sThreadLocal.get() will return null unless you&apos;ve called prepare(). //ThreadLocal 类型变量，保存 Looper static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //主线程的 Looper private static Looper sMainLooper; // guarded by Looper.class // 消息队列 final MessageQueue mQueue; //当前线程 final Thread mThread; 首先可以看到 ThreadLocal 类型，里面保存的是 Looper ，对于 ThreadLocal，需要知道： ThreadLocal 不是用来解决对象共享访问问题的，而是线程本地变量，其 set 的对象作用域为当前线程内部，生命周期伴随线程执行而终止，多个线程间不共享，切记将 ThreadLocal 理解成多线程变量副本的认知是绝对错误的，没有副本这一操作， ThreadLocal 中 set 进去的对象依然是引用方式而不是复制拷贝，所以谈不上副本，所以一般不建议 ThreadLocal 的 set 参数传递共享对象；ThreadLocal 特别适合会被多线程调用框架的编写，可以很容易解决框架中当前线程本地变量的效果. 那么在 Looper 类中，有下面两个方法12345678910111213// private static void prepare(boolean quitAllowed) &#123; // 如果不为 null,就抛错,也就是 prepare 执行调用一次。 if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; //通过 sThreadLocal 获取Looper public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; 对于 上面讲述的总结如下： 由于 ThreadLocal ,所以每个线程只有一个 Looper 每个 Looper 又对应着 一个 MessageQueue ，所以一个线程只有一个消息队列。 线程内部的的 Looper 不能共享，不能访问。 回到 ActivityThread 的 Main 方法里首先会调用 prepareMainLooper (1).prepareMainLooper1234567891011121314151617181920212223public static void prepareMainLooper() &#123; // prepare(false); // synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; // sMainLooper = myLooper(); &#125; &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; // private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 逻辑就是 通过 prepare 设置线程的 Looper ,并且设置这个 Looper 不允许 quit 随便退出，这是因为这是 主线程的 Looper ，如果主线程的 Looper 退出循环，那么整个 App 就应该是退出或者崩溃了。 初始消息队列，并设置当前线程。 (2) Looper.loop()初始化完成后就开启了消息的循环123456789101112131415public static void loop() &#123; final Looper me = myLooper(); .... final MessageQueue queue = me.mQueue; .... for (;;) &#123; Message msg = queue.next(); // might block try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; msg.recycleUnchecked(); &#125; &#125; 可以看到这里明显有一个死循环，不停地从 MessageQueue 中取出消息。这里就有两个问题 死循环获取消息的时候 ，如果响应其他事务，比如点击？ 死循环会不会一直消耗资源。 对于第一个问题对于第一个问题：可以回到 ActivityThread main 中执行 Looper.loop 方法之前123456789101112131415public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... //在执行 loop 循环之前首先 thread.attach(false); ActivityThread thread = new ActivityThread(); thread.attach(false); ... if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); 这里 又创建了一个 ActivityThread ，并执行 thread.attach(false) ，实际上这里面开启一个 Binder 线程，并且对于主线程 的一些重要的属性 比如主线程的 Hanlder ,Instrumentation ,mInitialApplication 都是在这里初始化的，这就说明 这个 ActivityThread 的作用是通过 Binder 处理各个 Binder 信息，比如 AMS 发送来的 启动 Activity 的命令。因为 ActivityThread 的创建也是直接 在这个进程上创建的 ，所以实际上他们的 Lopper 是同一个，只不过另一个线程在执行死循环，这个 Binder 线程 用与处理各种事务。这就解答了第一个问题。 对于第二个问题：可以参考 这里 Android消息机制2-Handler(Native层) 这个问题涉及到 Linux pipe/epoll 机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 总结如下： 首先会创建主线程的 Looper 然后再开启循环前，启动一个 Binder 线程，用于处理其他事务 启动 Looper 循环。 2.Handler在 ActivityThread 中有一个 H 的变量，通过源码可以知道这也是一个 Handler ,这个 Handler 的主要作用就是分发 Binder 线程中的消息，常见的有执行 Activity 的生命周期。12345678private class H extends Handler &#123; //启动 Activity public static final int LAUNCH_ACTIVITY = 100; //暂停 Activity public static final int PAUSE_ACTIVITY = 101; ... &#125; Handler 的构造方法1234567891011public Handler(Callback callback, boolean async) &#123; .... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 可以看到对于 Handler 的构造会自动地绑定这个线程的 Looper 和消息队列。对于主线程的 那当然就是 主线程的 MainLooper 3.发送消息两种方式：sendMessage 和 post (1).sendMessage( Message )12345public final boolean sendMessage(Message msg)&#123; //会去调用 延迟的方法，设置时间为 0 return sendMessageDelayed(msg, 0);&#125; 12345678public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; //系统当前时间和 延迟的时间 return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 123456//执行public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; ... return enqueueMessage(queue, msg, uptimeMillis);&#125; 123456789//将消息添加的到 对列中 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //在这里 msg 的 target 就被赋值，这里指向就是 handler msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 从上面的方法一步步执行下来，在 enqueueMessage 方法中将 msg 的 target 指向 调用的 handler ，最后就会将消息添加到消息队列中。 (2)post( Runnable )12345public final boolean post(Runnable r) &#123; //将 Runable 封装成 Message return sendMessageDelayed(getPostMessage(r), 0); &#125; 123456private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); //将 Runnable 赋给 Message 的 callback m.callback = r; return m; &#125; post 方式中参数是一个 Runnable 对象，在 Hanlder 会被封装为一个 Message ,最后同样调用 sendMessageDelayed 方法，后续的操作就是一样的。 4.Looper 获取消息之前我们知道 Looper 是在一个循环内获取消息的1234567for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; (1)Message首先看看 Message 这个对象的获取，对于 sendMessage 中的方法，这个 Message 是我们自己创建的，但是对于 对于 post 方法是通过 Message.obtain(); 获取的1234567891011121314151617181920public final class Message implements Parcelable &#123; private static Message sPool; // sometimes we store linked lists of these things /*package*/ Message next; public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; &#125; 关注于 sPool/next 这个两个 Message 的关键变量，可以看到对于 Message 的复用机制并不是通过 Map , 而是通过链表的形式服用。 在 MessageQueue 中每次添加一个消息，也是通过链表维护添加的顺序的。 12345678910boolean enqueueMessage(Message msg, long when) &#123; msg.when = when; Message p = mMessages; ... msg.next = p; mMessages = msg; .... &#125; 1234567891011//在 MessageQueue 的方法中,获取链表最末尾也就是最先添加的消息 Message next() &#123; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; ... return msg; (2)添加 Message 到复用链表前面讲了 Message 的复用，对于 Message 的回收，实际上就是在 Looper 循环中123456789101112131415public static void loop() &#123; final Looper me = myLooper(); .... final MessageQueue queue = me.mQueue; .... for (;;) &#123; Message msg = queue.next(); // might block try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; msg.recycleUnchecked(); &#125; &#125; 最后这段代码就是回收 Message123456789101112131415161718192021222324*/ void recycleUnchecked() &#123; // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; 可以看到就是对 Message 的各种信息置 为初始，然后添加到 链表中 。 (2)延迟的 Message在 Hanlder 是可以发送一个 延迟的 Message 给消息队列的， Hanlder 可以保证在一个相对精确的时间被执行。在 MessageQueue 的处理中 next 方法中 12345678910111213141516171819202122232425262728293031323334353637 int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; //这个方法相当于线程 的wait 方法， //第一次的时候还 是 0 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; //获取当前的延迟时间 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //当前的时间小于 小于消息的延迟时间 //说明还没有到时间 if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. //计算剩余的时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; ... if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. //设置阻塞 mBlocked = true; continue; &#125; &#125; .... //然后继续循环 //这个方法相当于线程 的wait 方法， //这个时候 nextPollTimeoutMillis 就不 是 0 了 //进行等待，等到时间到了的时候就唤醒线程执行。 nativePollOnce(ptr, nextPollTimeoutMillis); 如果在 第一个消息的时间还没有到的时候，又有一个新的 Message 进来，那么在 MessageQueue 的 enqueueMessage 方法1234567891011121314151617181920212223boolean enqueueMessage(Message msg, long when) &#123; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // 新的 Message 的时间小于 前一个 Message // 所以 将新的 Message 添加到链表的头部。 if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; // We can assume mPtr != 0 because mQuitting is false. // 唤醒线程，这个时候 新的 Message 就在链表头部 //取出来就可以直接处理，而延迟的就继续延迟。 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; 5.处理消息通过 3 中两种方式都可以发送一个消息，往消息队列中添加 Message ,而接着 looper 循环就会取出这个消息，对其进行分配也就是在之前讲过的 msg.target.dispatchMessage 方法。这里的 msg.target 在 3 中可以看到其实就是 Handler ，接着就看 dispatchMessage . 1234567891011121314public void dispatchMessage(Message msg) &#123; //这对应 post 方式 if (msg.callback != null) &#123; handleCallback(msg); //这对应 sendMessage 方式 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 可以看到最后就会根据之前的发送消息的方式从而选择不同的方法，如果是 post 方式就会执行 post 里面的 run 方法，如果是 sendMessage 方式就会执行 handleMessage .大致流程如图： Hanlder 之所以能在线程间传递消息实际上还是因为，线程间是共享资源的.]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底理解 ListView----缓存机制]]></title>
    <url>%2F2018%2F11%2F16%2F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-ListView-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.前言ListView 作为一个 Android 5.x 之前的一个用于显示数据列表的控件，或许在今天都已经被 RecyclerView 完全替代，但是其中的缓存机制仍然值得我们去了解，对后面学习 RecyclerView 的缓存机制有很大的帮助。 下面将根据 ListView 的三个过程彻底理解其缓存机制 OnLayout 过程，这个过程实践上有两次，而且两次是有区别的。 滑动一个 Item ，即最上面的一个 item 移除屏幕，屏幕下面出现后一个 item 。 滑动一个以上的item . 二.RecycleBin机制ListView 的缓存实际上都是由 RecyclerBin 类完成的，这是 ListView 的父类 AbsListView 的一个内部类，它也是 GridView 的一个父类，说明 ListView 的缓存和 GridView 的缓存实际上有很多相似的地方。1234567891011121314151617181920212223242526272829class RecycleBin &#123; // 第一个可见的 item 的下标 private int mFirstActivePosition; // 表示屏幕上可见的 itemView private View[] mActiveViews = new View[0]; //表示废弃的 itemView ，即屏幕上被移除的 itemView //就会添加到这里, 注意这里是个 数组， //数组的每个元素都是 List ,因为 ListView 可能存在多个 //类型的 item ，因此用不同的 List 进行存储。 private ArrayList&lt;View&gt;[] mScrapViews; // 表示不同类型的 itemView 的数量 private int mViewTypeCount; // 表示mScrapViews 数组中一个元素，默认是 第一个 private ArrayList&lt;View&gt; mCurrentScrap; ... //下面就是初始化的过程。 ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount]; for (int i = 0; i &lt; viewTypeCount; i++) &#123; scrapViews[i] = new ArrayList&lt;View&gt;(); &#125; mViewTypeCount = viewTypeCount; mCurrentScrap = scrapViews[0]; mScrapViews = scrapViews; 与上面对应的有四个方法，分为两类， 对于可见的 itemView 有两个操作： fillActiveViews ，将屏幕上可见的 itemView 添加到 ActiveViews 数组。 1234567891011121314void fillActiveViews(int childCount, int firstActivePosition) &#123; ... final View[] activeViews = mActiveViews; for (int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams(); if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123; activeViews[i] = child; lp.scrappedFromPosition = firstActivePosition + i; &#125; &#125; &#125; getActiveView(), 根据位置取出 ActiveViews 数组 中的 itemView ，并将最对应的数组元素置为 null。 12345678910View getActiveView(int position) &#123; int index = position - mFirstActivePosition; final View[] activeViews = mActiveViews; if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123; final View match = activeViews[index]; activeViews[index] = null; return match; &#125; return null; &#125; 对于移除屏幕的 itemView 也有两个操作： addScrapView() ,将移除 的 itemView 添加到 mScrapViews/mCurrentScrap 中。 123456789void addScrapView(View scrap, int position) &#123; ... if (mViewTypeCount == 1) &#123; mCurrentScrap.add(scrap); &#125; else &#123; mScrapViews[viewType].add(scrap); &#125; ... &#125; getScrapView(),用于从废弃缓存中取出一个 ItemView,如果只有一个类型就直接从 mCurrentScrap 当中获取尾部的一个 view 进行返回，同样取出后就直接移除元素。 123456789101112View getScrapView(int position) &#123; final int whichScrap = mAdapter.getItemViewType(position); if (whichScrap &lt; 0) &#123; return null; &#125; if (mViewTypeCount == 1) &#123; return retrieveFromScrap(mCurrentScrap, position); &#125; else if (whichScrap &lt; mScrapViews.length) &#123; return retrieveFromScrap(mScrapViews[whichScrap], position); &#125; return null; &#125; 三.OnLayout 过程一个 View 的绘制的时候至少会进行 2 次 onMeasure、onLayout，原因可参考这篇文章View为什么会至少进行2次onMeasure、onLayout,那么对于 ListView 这两次过程由于缓存机制的存在，就显得不一样。 (1)第一次 OnLayout对于 RecyclerBin 中的几个变量，因为还未添加任何 View 所以都为 0. 变量 数量 mActiveViews (表示屏幕可见的itemView ) 0 个 mCurrentScrap/mScrapViews[0] ((表示废弃移除的itemView )) 0个 getChildCount()/childCount 0 个 1234567891011121314151617181920@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; ... //因为是第一次 OnLayout 所以 getChildCount //还是 0 final int childCount = getChildCount(); if (changed) &#123; for (int i = 0; i &lt; childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; //直接进入 layoutChildren layoutChildren(); ....&#125; 1234567891011121314151617181920212223@Overrideprotected void layoutChildren() &#123; ... // 因为 childcount 为 0 ，所以这里并没有什么作用 //但是 在第二次的时候 这里就需要注意 //现在可以先跳过。 // Pull all children into the RecycleBin. // These views will be reused if possible final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; if (dataChanged) &#123; for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i), firstPosition+i); &#125; &#125; else &#123; recycleBin.fillActiveViews(childCount, firstPosition); &#125; //和上面的一样 // Clear out old views detachAllViewsFromParent(); //&#125; 1234567891011121314switch 里面 default: if (childCount == 0) &#123; if (!mStackFromBottom) &#123; final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); // 到这里方法 sel = fillFromTop(childrenTop); &#125; else &#123; final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); &#125; &#125; 因为是第一次 OnLayout ，因此有效的操作实际上就到 fillFromTop 这个方法12345678private View fillFromTop(int nextTop) &#123; mFirstPosition = Math.min(mFirstPosition, mSelectedPosition); mFirstPosition = Math.min(mFirstPosition, mItemCount - 1); if (mFirstPosition &lt; 0) &#123; mFirstPosition = 0; &#125; return fillDown(mFirstPosition, nextTop); &#125; fillFromTop-&gt;fillDown 这两个方法就是进行第一次往 ListView 添加 View 。其中的 fillDown 有个具体的循环。1234567891011121314private View fillDown(int pos, int nextTop) &#123; View selectedView = null; ... int end = (mBottom - mTop); ... //进入一个循环 while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); &#125;&#125; 上面的循环就是 根据屏幕的大下，对 ListView 添加满屏幕的 ItemView 。重点关注一下 makeAndView12345678910111213141516171819202122232425private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; if (!mDataChanged) &#123; // Try to use an existing view for this position. //尝试从 getActiveView 获取，但是这个时候为 0 //所以 activeView 为 null final View activeView = mRecycler.getActiveView(position); if (activeView != null) &#123; // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; &#125; &#125; //通过 obtainView 获取 // Make a new view for this position, or convert an unused view if // possible. final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child;&#125; 123456789View obtainView(int position, boolean[] outMetadata) &#123; ... //首先会获取一个 ScrapView 缓存废弃的 itemView ，因为这个时候为 0 //所以 会将 null 传到 mAdapter.getView 这个方法中。 final View scrapView = mRecycler.getScrapView(position); final View child = mAdapter.getView(position, scrapView, this); ... return child; &#125; 我们可以知道 mAdapter.getView 方法就是 BaseAdapter 中的 getView 方法。12345678910@Override public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView==null)&#123; convertView = LayoutInflater.from(Main2Activity.this).inflate(R.layout.item,null); &#125; TextView textView = convertView.findViewById(R.id.tv_text); textView.setText((position + &quot;:对应为&quot; + convertView).replace(&quot;android.widget.&quot;,&quot;&quot;)); return convertView; &#125; &#125;); 此时 convertView 就是 scrapView ，因为这时为 null ，所以就通过 LayoutInflater 进行加载。这样 obainView 放回一个 加载的 View , 最后回到 setupChild ,在 setupChild 就将 ItemView 添加到 ListViewGoup 并 mChildrenCount ++ .12345678private void addInArray(View child, int index) &#123; View[] children = mChildren; final int count = mChildrenCount; ... children[index] = child; mChildrenCount++; ... &#125; (2)第二次 OnLayout经过一次 OnLayout 后之前的三个变量变化如下：| 变量 | 数量 || ——————————————————– | ————– || mActiveViews (表示屏幕可见的itemView ) | 0 个 || mCurrentScrap/mScrapViews[0] ((表示废弃移除的itemView )) | 0个 || getChildCount()/childCount | 占满屏幕的数量 |首先还是还是 从 layoutChildren 开始123456789101112131415161718192021222324252627@Override protected void layoutChildren() &#123; ... // 因为 childcount 这个时候就有值了 n ， //假设为 n // 首先判断有没有数据改变 dataChanged // 没有就进入 else // Pull all children into the RecycleBin. // These views will be reused if possible final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; if (dataChanged) &#123; for (int i = 0; i &lt; childCount; i++) &#123; recycleBin.addScrapView(getChildAt(i), firstPosition+i); &#125; &#125; else &#123; // 这里就将 屏幕上的 itemView 添加到 //ActiveViews 中 ，ActiveViews 就是表示屏幕上的 itemView //集合 recycleBin.fillActiveViews(childCount, firstPosition); &#125; //然后就将 所有的 View 从 ListView 中先移除 //这是为了后面操作导致重复添加。 // Clear out old views detachAllViewsFromParent(); // &#125; 上面的逻辑就是将 ListView 中的itemView 添加到 ActiveViews 数组中，然后就先移除，因为保存到了 ActiveViews 中，所以不用担心会重新 LayoutInflate 的问题。| 变量 | 数量 || ——————————————————– | —- || mActiveViews (表示屏幕可见的itemView ) | n 个 || mCurrentScrap/mScrapViews[0] ((表示废弃移除的itemView )) | 0个 || getChildCount()/childCount | n 个 |因为是第二次 onLayout ，所以不会进入 fillTop -&gt;fillDown ，而是进入 fillSpecific，但是最后还是回到 makeAndaddView123456private View fillSpecific(int position, int top) &#123; boolean tempIsSelected = position == mSelectedPosition; View temp = makeAndAddView(position, top, true, mListPadding.left, .... .... &#125; 1234567891011121314private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; if (!mDataChanged) &#123; // Try to use an existing view for this position. final View activeView = mRecycler.getActiveView(position); if (activeView != null) &#123; // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; &#125; &#125; ...&#125; 因为 ActiveView 不为 null 了，所以这里就将之前保存的 每个 itemView 重新添加到 ListView ViewGroup . 而且 ActiveView 每次get 都会进行删除。这样三个变量的结果就为| 变量 | 数量 || ——————————————————– | —- || mActiveViews (表示屏幕可见的itemView ) | 0 个 || mCurrentScrap/mScrapViews[0] ((表示废弃移除的itemView )) | 0个 || getChildCount()/childCount | n 个 | 四.滑动一个 item因为是 滑动所以肯定在 onTouchEvent 的 MOVE 里面12345678910@Override public boolean onTouchEvent(MotionEvent ev) &#123; .... switch (actionMasked) &#123; .... case MotionEvent.ACTION_MOVE: &#123; onTouchMove(ev, vtev); break; &#125; 1234567private void onTouchMove(MotionEvent ev, MotionEvent vtev) &#123; // 这里又回到 layoutChildren if (mDataChanged) &#123; // Re-sync everything if data has been changed // since the scroll operation can query the adapter. layoutChildren(); &#125; 在 layoutChildren 最后又会回到 makeAndAddView12345678910111213141516171819202122private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; if (!mDataChanged) &#123; // Try to use an existing view for this position. final View activeView = mRecycler.getActiveView(position); if (activeView != null) &#123; // Found it. We&apos;re reusing an existing child, so it just needs // to be positioned like a scrap view. setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; &#125; &#125; // 执行下面的 // Make a new view for this position, or convert an unused view if // possible. final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; &#125; 这里因为 之前的 getActiveView 已经将所有的 item取出，所以还是会通过 obtainView 去加载一个 item.而且在 onTouchMove 最后还会调用123456789101112for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View child = getChildAt(i); if (child.getTop() &lt;= bottom) &#123; break; &#125; else &#123; .... // 将移除屏幕的 itemView 添加到 ScrapView mRecycler.addScrapView(child, position); &#125; &#125; &#125; &#125; 这个时候那个几个变量的变化为mActiveViews (表示屏幕可见的itemView )| 0 个mCurrentScrap/mScrapViews[0] ((表示废弃移除的itemView )) | 1个getChildCount()/childCount | n+1 个 五.继续滑动12345678910private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) &#123; final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured. setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; &#125; 123456789101112131415final View scrapView = mRecycler.getScrapView(position); //这个时候和第一次就不同了 因为 这个时候 的 scrapView //就不为 null, 因此 scrapView 和 convertView 就不为null. final View child = mAdapter.getView(position, scrapView, this); if (scrapView != null) &#123; if (child != scrapView) &#123; // Failed to re-bind the data, return scrap to the heap. mRecycler.addScrapView(scrapView, position); &#125; else if (child.isTemporarilyDetached()) &#123; outMetadata[0] = true; // Finish the temporary detach started in addScrapView(). child.dispatchFinishTemporaryDetach(); &#125; &#125; 上面的过程实际上就是将之前移除屏幕的 itemView 重新获取并设置到 mAdapter.getView 中，这也是 我们在写 getView 方法的时候需要对 convertView 进行判断，因为这样就可以利用 ListView 的缓存机制，不用重新进行 LayoutInflate 。 最后： 一个 ListView 共创建的 itemView 数就是屏幕显示的 数量+1 ，这个原因在滑动一个 item 的时候就说明。 为了证明这个说法，最后做一下验证。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp的任务队列----ArrayDeque]]></title>
    <url>%2F2018%2F11%2F10%2FOkHttp%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97-ArrayDeque%2F</url>
    <content type="text"><![CDATA[一.前言OkHttp 的处理网络请求的时候会有两个队列。一个是正在执行的队列，一个是等待执行的队列。12private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); 可以看到他们的实现都是 ArrayDeque ,这是一个底层是循环数组的实现，所谓循环数组就是当不需要扩容的时候，数组在逻辑上是首位相连的一个圆，没有固定的头尾，当数组满的时候就进行扩容。 下面主要就 JDK1.8 的源码分析 ArrayDeque 的原理，后面也会提及JDK 10 。 二.ArrayDeque1.源码中的介绍123456789Resizable-array implementation of the &#123;@link Deque&#125; interface. Array * deques have no capacity restrictions; they grow as necessary to support * usage. They are not thread-safe; in the absence of external * synchronization, they do not support concurrent access by multiple threads. * Null elements are prohibited. This class is likely to be faster than * &#123;@link Stack&#125; when used as a stack, and faster than &#123;@link LinkedList&#125; * when used as a queue. ... 上面对 ArrayDeque 的介绍可以分几点： ArrayDeque 没有内容的限制，当需要的时候可以进行扩容。 是不是线程安全的，在多线程的情况下不支持并发安全。 不允许元素为 null。 在某些情况下，作为栈使用比 Stack 快，作为队列使用比 LinkedList 快。 下面就看看具体的实现。 2.源码分析内部的实现12345678910111213141516171819202122232425262728293031323334353637383940transient Object[] elements; // non-private to simplify nested class access //头元素下标 transient int head; //尾部元素下一个位置的下标 transient int tail; //最小的初始容量 private static final int MIN_INITIAL_CAPACITY = 8; //默认初始容量为 16 public ArrayDeque() &#123; elements = new Object[16]; &#125; // 当指定的容量不是 2 的倍数的时候，转换为最接近的数 //比如 17 最近的是 16 public ArrayTest(int numElements) &#123; allocateElements(numElements); &#125; private void allocateElements(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1; // Good luck allocating 2^30 elements &#125; elements = new Object[initialCapacity]; &#125; 上面的源码可以看到一下几点： ArrayDeque 内部是基于数组实现的。维护一个头部小标和一个尾部后一个元素下标。 默认初始量为 16 ，自己指定时也会转换为 2 的倍数。 获取队列头部元素element()， getFirst()，peek()，peekFirst() 操作，其都是调用 getFirst() 实现的，访问队列头部元素但不删除12345678910/** * @throws NoSuchElementException &#123;@inheritDoc&#125; */ public E getFirst() &#123; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[head]; if (result == null) throw new NoSuchElementException(); return result; &#125; 删除队列头部remove()，removeFirst()，poll()，pollFirst() 操作，其都是调用 pollFirst() 实现的123456789101112public E pollFirst() &#123; final Object[] elements = this.elements; final int h = head; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[h]; // Element is null if deque empty if (result != null) &#123; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); &#125; return result; &#125; 对上面的步骤做一下解释： 首先取出头部的元素，将其置为空。 然后 head 这个下标就循环后移。 这里的1head = (h + 1) &amp; (elements.length - 1); 其实就跟1head = (h + 1) % (elements.length) 是一样的作用，目的就是当 head 到达数组末尾的时候，+1 就能回到数组的起始下标 即 0 ，从而实现循环。之所以能用 &amp; 操作是因为在初始或者扩容的时候都要求数组的最后长度为 2 的倍数。比如默认长度 16 时， h + 1 的二进制为 0001 0000 ，length - 1二进制就为 0000 1111 ，相与就为 0 ，其他情况就正常加 1 . 添加元素添加元素到队列尾部的操作可以发现 add(E e)，offer(E e)，offerLast(E e)，addLast(E e) 操作都是调用 addLast(E e) 实现的。12345678910111213141516171819202122232425 public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; //判断头部下标和尾部下标是否重叠 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) //进行扩容 doubleCapacity(); &#125; private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(&quot;Sorry, deque too big&quot;); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; &#125; 首先，但添加的元素为 null 的时候就会抛出异常，说明 ArrayDeque 不能添加 null . 添加完一个元素后就会判断 头部和尾部下标时候重叠，如果重叠就说明数组已经满了需要进行扩容。 将数组容量直接 X2 ，然后将原本的元素调用 System.arraycopy 进行复制。 重新指定 head ，tail 。 具体的扩容可见下图： JDK 10 中源码在JDK 10 对 ArrayDeque 的实现有些不同，就是不再直接扩容 X2 倍，而是根据需要 X2 或者增加原来的 1/2。因此对下标的循环加1 也就直接进行判断是否达到数组的尾部，是就直接置 0.1234static final int inc(int i, int modulus) &#123; if (++i &gt;= modulus) i = 0; return i; &#125; 三.ArrayDeque 与 LinkedList区别LinkedList 实现了 List 接口又实现了 Deque 接口（Deque 是 Queue 的子接口），而 LinkedList 的实现是基于双向链表结构的，其容量没有限制，是非并发安全的队列，所以不仅可以当成列表使用，还可以当做双向队列使用，同时也可以当成栈使用（因为还实现了 pop 和 push 方法）。此外 LinkedList 的元素可以为 null 值 ArrayDeque 是一个用循环数组实现的双端队列 Deque，满足可以同时在数组两端插入或删除元素的需求ArrayDeque 是非线程安全的，当多个线程同时使用的时候需要手动同步，不允许放 null 元素，没有索引位置，不能根据索引位置获取数组中的元素。 使用场景 如果只需要 Deque 接口且从两端进行操作则一般来说 ArrayDeque 效率更高一些。 如果同时需要根据索引位置进行操作或经常需要在中间进行插入和删除操作则应该优先选 LinkedList 效率高些。]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----List]]></title>
    <url>%2F2018%2F10%2F16%2Fjava%E9%9B%86%E5%90%88-List%2F</url>
    <content type="text"><![CDATA[一.Listjava 中的 List 是一种类似于列表的集合，Java集合—-Map说过 Map 接口的实现类是不保证添加顺序的(LinkedHashMap 除外) ,但是对于 List 的接口实现类，基本上都是保证了添加的顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; // Query Operations //询问操作 int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); // Modification Operations //修改操作 boolean add(E e); boolean remove(Object o); // Bulk Modification Operations //大量修改的操作 boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125; &#125; /** *Java 8 开始支持排序操作 * @since 1.8 */ @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;) default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; void clear(); // Comparison and hashing //比较和 hash 操作 boolean equals(Object o); int hashCode(); // Positional Access Operations //基于位置的访问 E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); // Search Operations //返回位置的操作 int indexOf(Object o); int lastIndexOf(Object o); // List Iterators //迭代器，用于遍历列表 ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); // View //list 的子视图，也就是子列表 List&lt;E&gt; subList(int fromIndex, int toIndex); /* * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override default Spliterator&lt;E&gt; spliterator() &#123; if (this instanceof RandomAccess) &#123; return new AbstractList.RandomAccessSpliterator&lt;&gt;(this); &#125; else &#123; return Spliterators.spliterator(this, Spliterator.ORDERED); &#125; &#125; /** * Java 9 扩展的返回不可变的list 列表 * @since 9 */ static &lt;E&gt; List&lt;E&gt; of() &#123; return ImmutableCollections.List0.instance(); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1) &#123; return new ImmutableCollections.List1&lt;&gt;(e1); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2) &#123; return new ImmutableCollections.List2&lt;&gt;(e1, e2); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9); &#125; static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10); &#125; @SafeVarargs @SuppressWarnings(&quot;varargs&quot;) static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123; switch (elements.length) &#123; // implicit null check of elements case 0: return ImmutableCollections.List0.instance(); case 1: return new ImmutableCollections.List1&lt;&gt;(elements[0]); case 2: return new ImmutableCollections.List2&lt;&gt;(elements[0], elements[1]); default: return new ImmutableCollections.ListN&lt;&gt;(elements); &#125; &#125; /** *Java 新增的复制集合方法，如果是不可变的集合，就直接返回，如果是可变的集*合就复制并返回一个不可变得集合。 * @since 10 */ @SuppressWarnings(&quot;unchecked&quot;) static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123; if (coll instanceof ImmutableCollections.AbstractImmutableList) &#123; return (List&lt;E&gt;)coll; &#125; else &#123; return (List&lt;E&gt;)List.of(coll.toArray()); &#125; &#125;&#125; 二.ArrayList1.继承关系首先看一下 ArrayList 的继承关系123456public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;&#125;public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123;&#125; 与 Map 相似，ArrayList 也会继承一个抽象类 AbstractList 而这个抽象类有继承自 AbstractCollection ，这两个抽象类的主要作用就是将一些通用的方法进行复用，对于具体的实现可能就会进行重写从而实现自己的特性。 除此之外，还看到 RandomAccess 这个接口123456789101112 * for typical instances of the class, this loop: * &lt;pre&gt; * for (int i=0, n=list.size(); i &amp;lt; n; i++) * list.get(i); * &lt;/pre&gt; * runs faster than this loop: * &lt;pre&gt; * for (Iterator i=list.iterator(); i.hasNext(); ) * i.next(); * &lt;/pre&gt;public interface RandomAccess &#123;&#125; 这是一个 标记接口，在这个接口中的说明中有一段话 this loop: … runs faster than this loop: (如上)，这段话的意思就是说对于 实现这个接口的类来说，使用 for 循环进行遍历要比使用迭代器快得多，比如在 Collections 的查巡操作中会根据书数组还是迭代器进行选择12345678910@SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123; if (c==null) return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key); if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key, c); else return Collections.iteratorBinarySearch(list, key, c); &#125; 至于 ArrayList 为什么要实现这个接口？ 实际上就是因为 ArrayList 的内部实现是通过数组实现的。 标记接口就是标记实现这个接口的类具有某种特性。 2.数组1transient Object[] elementData; // non-private to simplify nested class access ArrayList 从名字就可以猜出这是一个基于数组的集合，内部有一个用于存储元素的集合 elementData，这里使用 transient 进行修饰，就说明这个数组不进行序列化，但是 ArrayList 又支持序列化，这似乎有点矛盾，我们接着看。123456789101112131415161718192021222324252627 /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; //说明这是数组元素的个数，不是数组的长度 //重写 writeObject private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; // 这是根据集合的元素个数，而不是数组的长度 s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; ArrayList 并没有去序列化整个数组，而是对数组中的元素逐个进行序列化，这样做就减少空元素的序列化，加快序列化的速度。 3.add12345678910111213 public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true; &#125; private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) //判断是否达到数组的长度 elementData = grow(); // 如果是就进行扩容 elementData[s] = e; //如果还没有就直接对数组进行赋值 size = s + 1; // 将集合元素加一 &#125; 对于 ArrayList 的添加元素操作，首先会判断是否达到数组的长度，如果是就进行扩容，如果还没有就直接对数组进行赋值，最后将将集合元素加一。 这里的关键就是数组的动态扩容。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * Default initial capacity. * 数组默认初始化个数 为 10 个 */ private static final int DEFAULT_CAPACITY = 10; //数组的极限值，-8 是因为一些 虚拟机会在在数组添加一些 头信息 //-8 进行容错，但是最后还是最大还是创建 Integer.MAX_VALUE 。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private Object[] grow() &#123; return grow(size + 1); &#125; private Object[] grow(int minCapacity) &#123; System.out.println(newCapacity(minCapacity)); return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); &#125;// 扩容的具体操作private int newCapacity(int minCapacity) &#123; // overflow-conscious code //原来的容量 int oldCapacity = elementData.length; //计算新的容量 //新的容量 = 原来的容量 + （原来的容量的一半） int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果计算的新的容量比指定的扩容容量小，那么就使用指定的容量 //通常比指定的小是因为 使用 addAll 添加元素 if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; //如果新的容量大于MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8) //那么就使用 hugeCapacity 进行容量分配 //否则就是用计算出来的新容量 return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); &#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 最后的扩容就是调用 Arrays.copyOf 进行数组的复制。 3.remove对于 ArrayList 的各种移除操作，最后都会调用下面两种方法之一。12345678910111213private void fastRemove(Object[] es, int i) &#123; modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null; &#125; private void shiftTailOverGap(Object[] es, int lo, int hi) &#123; System.arraycopy(es, hi, es, lo, size - hi); for (int to = size, i = (size -= hi - lo); i &lt; to; i++) es[i] = null; &#125; 简单地说还是对数组进行复制，然后再将空出的位置置为 null ，等待 GC 回收。 4.subList1234public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; subList 返回的是 ArrayList 的一个子视图，也就是子集合，实际的是 ArrayList 的一个内部类 SubList，虽然 SubList 也实现了 AbstractList 接口但是 SubList 并不是 ArrayList 的子类，== 和 instanceOf 会返回 false 。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final ArrayList&lt;E&gt; root; private final SubList&lt;E&gt; parent; private final int offset; private int size; ...&#125;/** * Constructs a sublist of an arbitrary ArrayList. */ public SubList(ArrayList&lt;E&gt; root, int fromIndex, int toIndex) &#123; this.root = root; this.parent = null; this.offset = fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; /** * Constructs a sublist of another SubList. */ private SubList(SubList&lt;E&gt; parent, int fromIndex, int toIndex) &#123; this.root = parent.root; this.parent = parent; this.offset = parent.offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = root.modCount; &#125; public E set(int index, E element) &#123; Objects.checkIndex(index, size); checkForComodification(); E oldValue = root.elementData(offset + index); root.elementData[offset + index] = element; return oldValue; &#125; public E get(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); return root.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return size; &#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); checkForComodification(); root.add(offset + index, element); updateSizeAndModCount(1); &#125; public E remove(int index) &#123; Objects.checkIndex(index, size); checkForComodification(); E result = root.remove(offset + index); updateSizeAndModCount(-1); return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); root.removeRange(offset + fromIndex, offset + toIndex); updateSizeAndModCount(fromIndex - toIndex); &#125; SubList 里并没有数组变量但是有一个root b变量 root 变量就是原本的集合，而且从两个构造器可以看出 SubList 也可以产生它 的 SubList 。而且 对于 SubList 的各种修改操作也都是调用 root 却修改原生的 集合，换句话说也就是对 SubList 的修改也会影响到原声的 ArrayList . 删除指定范围的元素就可以使用 list.subList(from,to).clear(); 特别注意的是这进行这些方法的时候都回调用这个 checkForComodification 方法进行检查 .1234private void checkForComodification() &#123; if (root.modCount != modCount) throw new ConcurrentModificationException(); &#125; 这个方法表示的是 如果 ArrayList 的 modCount 和 SubList 的 modCount 不一样的时候就会抛出异常，也就是说，在生成了 SubList 后，如果再对 ArrayList 进行修改则其 modCount 就会发生变化，这个时候如果又对 SubList 进行操作就会异常。 简单地说就是再生成 SubList 后，如果对 ArrayList 操作了，则不能对已生成的 SubList进行操作。 Array.asList12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; &#125; @Override public int size() &#123; &#125; @Override public Object[] toArray() &#123; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; &#125; @Override public E get(int index) &#123; &#125; @Override public E set(int index, E element) &#123; &#125; @Override public int indexOf(Object o) &#123; &#125; @Override public boolean contains(Object o) &#123; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayItr&lt;&gt;(a); &#125; &#125; Arrays 有一个 asList 的返回一个 ArrayList ,从上面的源码可以看出，这个实际上也是 Arrays 的一个内部类，而且这个不是现在通常说的 ArrayList ,因此两个类也没 有继承关系，但是这个内部类可以转为 ArrayList 因为 ArrayList 的 构造器参数是 Collection&lt;? extends E&gt; c 而且这个内部类并没有包含 ArrayList 的所有方法，比如就没有 add 方法，不具备扩展和缩小。 对于数组 Array和 ArrayList 的区别 可以包含基本类型和对象类型，ArrayList 只能包含对象类型；Array 的大小是固定的，ArrayList 的大小是动态变化的；ArrayList 提供了更多的方法和特性， addAll()、removeAll()、iterator() 等。 5.equals12345678910111213141516public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) &#123; E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) return false; &#125; return !(e1.hasNext() || e2.hasNext()); &#125; 对于 ArrayList 的equals 比较，最后还是比较其中的元素数量和每个元素对应时候符合 equals 。显然对于 ArrayList 和 SubList (这里取全部元素)，就符合 equals 返回 true 。 6.线程安全ArrayList 是不是线程安全的，一个方法是用 Collections.synchronizedList 方法把 ArrayList 变成一个线程安全的，另一个方法就是 Vector，它是ArrayList的线程安全版本，区别在于：Vector 可以指定增长因子，如果该增长因子指定了，那么扩容的时候会每次新的数组大小会在原数组的大小基础上加上增长因子；如果不指定增长因子，那么就给原数组大小*2。 ArrayList适用于查找但是不适用于增加和删除，因为内部的操作都是调用 System.arrayCopy 这种效率很低的方法进行处理，所以如果遇到了数据量略大且需要频繁插入或删除的操作效率就比较低了。 三.LinkedListLinkedList 是以双向链表实现，链表无容量限制。1234567891011121314151617181920212223242526272829public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. */ transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; ...&#125; // 内部的节点类 private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; LinkedList 的继承关系也很简单 AbstractSequentialList 用于保持有序性，除此之外还实现了 Deque ，表明这个一个 双向的链表，支持 Deque 的一些操作。对于每一个 Node 节点，包含了对上一个节点和下一个节点的引用。对于整个 LinkedList 持有头节点和尾节点的引用 。 1.基本操作由于 LinkedList 是以链表形式存在，因此内部定义了许多对节点的基本操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * Links e as first element. * 添加一个元素作为头节点 */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; /** * Links e as last element. * 添加一个元素作为尾节点 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; /** * Inserts element e before non-null Node succ. * 在一个节点之前插入一个节点 */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; /** * Unlinks non-null first node f. * 删除头节点 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; /** * Unlinks non-null last node l. * 删除尾节点 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; /** * Unlinks non-null node x. * 删除某个节点 */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; /** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty * 返回第一个头节点 */ public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125; /** * Returns the last element in this list. * * @return the last element in this list * @throws NoSuchElementException if this list is empty * 返回尾节点 */ public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125; 基本上所有的增加删除都是基于上面这几个操作完成。 2.查询LinkedList 不是以数组的为基础的，因此不能直接定位到指定的元素，需要进行遍历1234567891011121314151617181920212223public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; /** * Returns the (non-null) Node at the specified element index. */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 对于 LinkedList 的查巡遍历并不是从前往后进行的，而是进行判断，如果下标小于长度的一半就从头节点开始，否则就从尾节点开始。访问的复杂度为 O(N/2)）只有在链表两头的操作（比如 add()、addFirst()、removeLast() 或用在 iterator() 上的 remove() 操作）才不需要进行遍历寻找定位。 四.对比 当插入的元素比较靠后的时候，ArrayList 效率低，因为 ArrayList 将批量 copy 大量的元素。 ArrayList 使用最普通的 for 循环遍历，数组元素之间没有关联，而迭代器强制将 RandomAccess 的 ArrayList 建立了前后遍历关系，且在每次遍历过程中进行了一堆判断，所以比较慢。 LinkedList 使用 foreach 循环比较快，前后元素是通过链表索引建立关联的，无法直接取到对应的下标，因此在使用普通的 index 索引下标遍历时就需要计算对应的元素在哪，二分法决定头部还是尾部遍历，然后一步步的遍历找到元素，所以在遍历中每次都要从头查找元素位置，十分低效率。而迭代器的实现就是指向下一个元素，迭代器直接通过 LinkedList 的指针进行遍历，一次遍历就能找到每个合适的元素。 ArrayList 是动态数组顺序表，顺序表的存储地址是连续的，所以查找比较快，但是插入和删除时由于需要把其它的元素顺序移动，所以比较耗时。LinkedList 是双向链表的数据结构，同时实现了双端队列 Deque 接口，链表节点的存储地址是不连续的，每个存储地址通过指针关联，在查找时需要进行指针遍历节点，所以查找比较慢，而在插入和删除时比较快。 五.CopyOnWriteArrayListCopyOnWriteArrayList 是 java 并发包中 concurrent 下的一个基于读写分离思想的容器，其主要作用是应用在多线程并发的情况读多写少的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//锁对象final transient Object lock = new Object();//数组的实现 用 volatile 修饰private transient volatile Object[] array;final Object[] getArray() &#123; return array;&#125;final void setArray(Object[] a) &#123; array = a;&#125;// 先看添加元素的方法public E set(int index, E element) &#123;// 先锁住 synchronized (lock) &#123; Object[] elements = getArray(); E oldValue = elementAt(elements, index); if (oldValue != element) &#123; int len = elements.length; //复制一个新的数组，长度在原来的基础上加一 Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; //将原来的引用指向新的数组。 setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125;&#125;//下面也是同样的原理public boolean add(E e) &#123;// 先锁住 synchronized (lock) &#123; // 获取旧的数组 Object[] elements = getArray(); int len = elements.length; //复制新的数组，长度加一 Object[] newElements = Arrays.copyOf(elements, len + 1); //将元素放到最后 newElements[len] = e; //改变旧的引用 setArray(newElements); return true; &#125;&#125; 从上面的实现中可以看出，CopyOnWriteArrayList 在添加元素的时候，通过加锁的方式来实现保证线程的安全，对每次添加一个元素，就是通过复制一个新的数组，然后将旧的引用指向新的数组。这就是一种写时复制的思想，因为写的时候是通过复制实现的，那么这个时候读也是没有问题的。 12345678910111213/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; return elementAt(getArray(), index); &#125; @SuppressWarnings(&quot;unchecked&quot;) static &lt;E&gt; E elementAt(Object[] a, int index) &#123; return (E) a[index]; &#125; 对于读，这里并没有加锁，而是直接读取。因此对 CopyOnWriteArrayList 的并发读写可以分为三种情况： 1·如果写操作未完成，那么直接读取原数组的数据； 2·如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据； 3·如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。 这种情况下，CopyOnWriteArrayList 不能保证写一个数据后马上对读可见，但是它保证了 CopyOnWriteArrayList 最后的数据都是一致的，因为添加是加锁的。由于 CopyOnWriteArrayList 的复制机制，因此性能在数据多或者数据较大的时候都会比较低，通过这种空间的解决了读写分离。]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java----谈谈String]]></title>
    <url>%2F2018%2F10%2F14%2FJava-%E8%B0%88%E8%B0%88String%2F</url>
    <content type="text"><![CDATA[一.简介String 可以说是 Java 中使用得最频繁的一个类了，不管是作为开发者的业务使用，还是一些系统级别的字符使用， String 都发挥着重要的作用。又因 String 是不可变的、f且 Java 在运行时也保存了一个字符串池(String pool) ，就使得 String 变得很特殊。 二.==/equalsString 对象的创建有两种方式：12String strComplier = &quot;A&quot;;String strNew = new String(&quot;A&quot;); 虽然同样是创建字符串 “A” ,但是这两种方式在内存分配上是由区别的。 1.String strComplier = “A”;Java 程序在运行的时候会维护一个常量池，编译期生成的各种字面量和符号引用会在类加载后进入方法区的运行时常量池。对于 上述这种实现字符串的方式就可以在编译的时候确定字符串的内容，因此这一行生成的内存结构就如下图。 不严谨的讲：虚拟机栈中的 strComplier 存储的就是 A 在常量池中的地址。 2. String strNew = new String(“A”);因为使用的 new 的方式，所以这句代码只有的运行的时候才能确定字符串的内容。而对于 new 关键字，java 是将对象的实例数据存放堆上的，但是又因 String 常量池的存在，因此实际上在堆上的 String 对象的数据又指向了字符串常量池。 不严谨的讲:虚拟机栈中的 strNew 存储的就是 strNew 这个对象在堆内存的地址，而 strNew 中的字符串数据又指向了常量池中的 A . 3.==/equals有了前面的知识基础之后，对于字符串这两个比较操作就十分简单了。 (1).==== 比较的两个对象的引用是否相等，也就是说比较两个地址是否相等，显然对于下面的比较。123String a = &quot;A&quot;;String a1 = &quot;A&quot;;System.out.println(a1 == a); //指向的都是 A 的地址，地址相同，返回的是 true 123String a = new String(&quot;A&quot;);String a1 = new String(&quot;A&quot;);System.out.println(a==a1);//分别指向的是在堆内存上的对象的地址，地址不同，返回的是 false 123String a = &quot;A&quot;;String a1 = new String(&quot;A&quot;);System.out.println(a == a1);//一个指向常量池，一个指向堆，返回 false 123String a = &quot;A&quot;;String a1 = a; //编译的时候不能确定System.out.println(a == a1);//一个指向常量池，一个指向堆，返回 false 通过这个例子可以看出实际上对于 == 的比较，只要在编译的时候能够确定的，都是相同 的。12345678910111213141516171819String a = &quot;A1&quot;;String a1 = &quot;A&quot; +1;System.out.println(a == a1);//trueString a = &quot;A1&quot;;String a1 = a +1;System.out.println(a == a1);//falseString a = &quot;A1&quot;;final String a1 = a + 1;System.out.println(a == a1);// final 修饰的在 a1 在编译的时候就能确定下来private static String get1() &#123; return &quot;1&quot;;&#125;String a = &quot;A&quot;;final String a1 = get1();String a2 = &quot;a&quot; + a1;System.out.println(a == a2); //使用了 方法，只能在运行的时候确定，所以返回false (2)equals12345678910111213public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (coder() == aString.coder()) &#123; return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); &#125; &#125; return false; &#125; 对于 equals 的比较： 首先如果是两个对象相同的对象就直接返回 true . 接着先判断时候属于 String 类的对象，不是就直接返回 false ,这就说明 对于 StringBuilder(“A”) 和 String(“A”) 显然 equals 返回的是 false ，但是对于前面说过的两种方式，实际上都是 String 对象。 然后，就要判断编码的方式如果编码的方式不同就直接返回 false ，如果编码方式相同就比较两个字符串是否完全相等。 如果两个字符串是完全的一样， 就是 true . 1234567String stringCompiler = &quot;A&quot;;String stringNew = new String(&quot;A&quot;);StringBuilder stringBuilder = new StringBuilder(&quot;A&quot;);StringBuffer stringBuffer = new StringBuffer(&quot;A&quot;)System.out.println(stringCompiler.equals(stringNew)); // trueSystem.out.println(stringCompiler.equals(stringBuilder)); // falseSystem.out.println(stringNew.equals(stringBuffer)); // false (3)引申1String strNew = new String(&quot;A&quot;); 对于这行代码，前面说过会在堆保存对象的实例数据，然后在常量池保存了 “A” 这个常量。所以这一句实际涉及了两个 String 对象。 三.final12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;&#125; 众所周知，String 类是 final ，也就是String 是不可继承的。且对于内部的实现 char 数组也是通过 final 修饰的，加上使用 privvate 进行修饰，且对 String 的所有修改都不会设计 char 数组 的修改吗，即一个 String 对象创建之后所有对它修改后的字符串都是新生成的 String 对象，因此 String 是不可变得。 String 设计成 final 主要有下的原因： 实现字符串常量池，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串，即可以实现多个变量引用 JVM 内存中的同一个字符串实例，如果字符串不是不变的，String interning 将不能实现(String interning 是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。 安全问题，在系统中有很多地方都是以字符串的形式存在的，比如数据库的用户名，Socket 的主机和端口，当你在调用其他方法，比如调用一些系统级操作之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，其内部的值被改变了，可能引起严重的系统崩溃问题。 缓存提升性能，String 大量运用在哈希的处理中，由于 String 的不可变性，可以只计算一次哈希值，然后缓存在内部，后续直接取就好了，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。 线程安全，因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。 使用 StringBuilder 和 StringBuffer 拼接字符串前面说过 String 是final 类的，因此对于字符串的拼接实际上就是创建了新的对象。1234String str = &quot;111&quot;;str += &quot;222&quot;;str += &quot;333&quot;;System.out.println(str); 编译器每次碰到 ”+=” 的时候，会 new 一个 StringBuilder 出来，接着调用 append 方法，在调用 toString 方法，生成新字符串。因此对于字符串的拼接，应该直接使用 StringBuilder 或者 StringBuffer。虽然 这两类也是 final 但是他们在内部 维护了父类一个可变的 byte 数组，每次 append 的时候就往 byte 数组里面放字符. StringBuffer 和 StringBuilder用法一模一样，唯一的区别只是 StringBuffer 是线程安全的，它对所有方法都做了同步，StringBuilder 是线程非安全的，所以在不涉及线程安全的场景，比如方法内部，尽量使用 StringBuilder，避免同步带来的消耗. StringBuffer 123456@Override public synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this; &#125; StringBuilder 1234567891011@Override public StringBuilder append(Object obj) &#123; return append(String.valueOf(obj)); &#125; @Override @HotSpotIntrinsicCandidate public StringBuilder append(String str) &#123; super.append(str); return this; &#125; 四.nullString 是一个 引用型对象，因此也就存在着 null 值，又因 String 是一个经常使用的对象，如果为 null 的话很可能导致整个系统崩溃，因此 String 对 null 值有很高的容错率123public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString(); &#125; String 对象：直接判断是否为 null，如果为 null 给 null 对象赋值为”null”。 非 String 对象：通过调用 String.valueOf 方法，如果是 null 对象，就返回 “null” ，否则调用对象的 toString 方法 对于字符串的拼接也是如此123String s = null;s = s + &quot;!&quot;;System.out.print(s);// 输出 null! 前面说过对于 “+=” 都是转为 StringBuffer 的 append ,下面就看 AbstractStringBuilder 是如何处理 null 的 （AbstractStringBuilder 是 StringBuffer 和 StringBuilder 的父类 ）123456789101112131415private AbstractStringBuilder appendNull() &#123; ensureCapacityInternal(count + 4); int count = this.count; byte[] val = this.value; if (isLatin1()) &#123; val[count++] = &apos;n&apos;; val[count++] = &apos;u&apos;; val[count++] = &apos;l&apos;; val[count++] = &apos;l&apos;; &#125; else &#123; count = StringUTF16.putCharsAt(val, count, &apos;n&apos;, &apos;u&apos;, &apos;l&apos;, &apos;l&apos;); &#125; this.count = count; return this; &#125; 可以看到也是直接添加 “null” 字符串。 五.保密性为什么针对安全保密高的信息，char[]比String更好? 因为 String 是不可变的，就是说它一旦创建，就不能更改了，直到垃圾收集器将它回收走。而字符数组中的元素是可以更改的（这就意味着可以在使用完之后将其更改，而不会保留原始的数据）。所以使用字符数组的话，安全保密性高的信息(如密码之类的)将不会存在于系统中被他人看到。]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合----Map]]></title>
    <url>%2F2018%2F10%2F13%2Fjava%E9%9B%86%E5%90%88-Map%2F</url>
    <content type="text"><![CDATA[一.Mapjava 中的 Map 是一种以键值对存储数据的数据结构，可用于快速查找。 Map 通常 是不保证有序性的（除了 TreeMap ），且一个 Map 内部 一般要包括三个集合视图，key 的集合，value 的集合 ，以及键值对的 Entry 集合，对这三个集合的修改都会直接影响 Map 集合。123456789101112//key 的集合，需要保持互异性 使用 Set Set&lt;K&gt; keySet();// value 的集合，不需要保持互异性 Collection&lt;V&gt; values();// 键值对的 Entry 的集合Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();//键值对的接口interface Entry&lt;K, V&gt; &#123; &#125; 可以看到对于 key 和 Entry 都是用 Set 集合，Set 集合一般有如下特点： 无序性：一个集合中，每个元素的地位都是相同的，元素之间也都是无序的（也有有序的 Set）。 互异性：一个集合中，任何两个元素都是不相同的。 确定性：给定一个集合以及其任一元素，该元素属于或者不属于该集合是必须可以确定的。 二.AbstractMap1234public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; &#125; AbstractMap 是一个抽象类，在具体的 Map 的实现类和接口之间定义的一层抽象，为了就是服用一些用的函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// 键值对集合 EntrySet 是一个抽象的函数，交由实现类去实现public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();//下面的几个函数都是基于 EntrySet 可以复用的函数public int size() &#123; return entrySet().size();&#125;public boolean isEmpty() &#123; return size() == 0;&#125;public boolean containsValue(Object value) &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (value==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getValue()==null) return true; &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (value.equals(e.getValue())) return true; &#125; &#125; return false;&#125;public boolean containsKey(Object key) &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return true; &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return true; &#125; &#125; return false;&#125;public V get(Object key) &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return e.getValue(); &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return e.getValue(); &#125; &#125; return null;&#125;public V remove(Object key) &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); Entry&lt;K,V&gt; correctEntry = null; if (key==null) &#123; while (correctEntry==null &amp;&amp; i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) correctEntry = e; &#125; &#125; else &#123; while (correctEntry==null &amp;&amp; i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) correctEntry = e; &#125; &#125; V oldValue = null; if (correctEntry !=null) &#123; oldValue = correctEntry.getValue(); i.remove(); &#125; return oldValue;&#125;public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue());&#125; public void clear() &#123; entrySet().clear();&#125;// AbstractMap并没有实现put()函数。//对于不可修改的 Map 实现子类直接继承就行了，//但是而对于一个可修改的Map实现子类则必须重写 put() 函数public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125;// Views// ketSet 视图集合//values 视图集合 transient Set&lt;K&gt; keySet;transient Collection&lt;V&gt; values;public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new AbstractSet&lt;K&gt;() &#123; public Iterator&lt;K&gt; iterator() &#123; return new Iterator&lt;K&gt;() &#123; private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() &#123; return i.hasNext(); &#125; public K next() &#123; return i.next().getKey(); &#125; public void remove() &#123; i.remove(); &#125; &#125;; &#125; public int size() &#123; return AbstractMap.this.size(); &#125; public boolean isEmpty() &#123; return AbstractMap.this.isEmpty(); &#125; public void clear() &#123; AbstractMap.this.clear(); &#125; public boolean contains(Object k) &#123; return AbstractMap.this.containsKey(k); &#125; &#125;; keySet = ks; &#125; return ks;&#125;public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vals = values; if (vals == null) &#123; vals = new AbstractCollection&lt;V&gt;() &#123; public Iterator&lt;V&gt; iterator() &#123; return new Iterator&lt;V&gt;() &#123; private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() &#123; return i.hasNext(); &#125; public V next() &#123; return i.next().getValue(); &#125; public void remove() &#123; i.remove(); &#125; &#125;; &#125; public int size() &#123; return AbstractMap.this.size(); &#125; public boolean isEmpty() &#123; return AbstractMap.this.isEmpty(); &#125; public void clear() &#123; AbstractMap.this.clear(); &#125; public boolean contains(Object v) &#123; return AbstractMap.this.containsValue(v); &#125; &#125;; values = vals; &#125; return vals;&#125; 在 AbstractMap 还有两个 Entry 的实现类。 SimpleEntry 简单的 Entry ，对一个 key 和 value 的封装。 SimpleImmutableEntry，简单不可变的 Entry， 这个键值对 的 值是不能改变的。123456789101112131415public static class SimpleEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -8499721149061103585L; private final K key; //key是final 的 private V value; // value 不是 final 的 ... // 可以进行 setValue 操作 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; 123456789101112public static class SimpleImmutableEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable &#123; private final K key; private final V value; value 是final 的 //进行set操作会抛出异常 public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; &#125; 三.HashMap1.Hash 算法(1)简介hash 算法是一种可以从一个任何长度的数据中提取出一个固定长度的算法，这个固定的长度就叫做 hashCode ，hash 算法具有如下两种特性： 唯一性：同样的输入经过 hash 算法得出的结果都是一样的。 不可逆性，不能从 hashCode 得出原本的数据。 重复性：对于不同的输入，可能得出同样的输出。 (2)hash Code在数据查找过程中，最理想的情况是可以不进行记录的比较，就直接得到待查记录。若记录的关键字与存储位置存在某种一一映射关系，那么就可以通过待查记录的关键字，计算其存储位置，直接找到该记录。实现这种对应关系的函数就散列函数，散列函数中就运用到了 hash 算法产生的 hash Code . (3)hash 表hash 查找通常需要维护一个数组，这个数组就叫做 hash table (hash 表 或 散列表)这个数组元素被称为桶（ bin ）,当传入一个 关键字 key 的时候，就可以通过散列 函数直接将 key 转为数组的下标。通过下标就可以直接得到对应的数据。 (4)冲突前面说过 hash 算法具有重复性，因此在 hash Code 上建立的 散列函数也就存在着重复，不是一一对应的关系，出现两个不同的数据拥有在 hash 表中同一下标的情况就叫做冲突。 处理冲突的方式有两种方式： 开放地址法： 开放地址又分为线性探测和二次探测。 链地址法。 线性探测思想是：若哈希表的地址区间长度为m，将哈希表看成是一个循环空间，如若冲突就放在数组后一个位置，如果下一个位置已有数据就再往后放。 这种想法的缺点很明显：如果连续序列越长，则当新的元素加入该表时，与这个序列发生冲突的可能性越大。 二次探测思想是：探测的序列不是连续的，而是跳跃式的，为后续待插入的记录留下空间从而减少堆聚。如若冲突就根据一些跳跃的函数进行跳跃式的探测，如若有数据就再进行探测。 链地址法链地址法将关键字为同义词的记录链接在同一个单链表中，即数组元素是一个个节点，如若冲突就在这个节点上生成一个链表。 2.HashMapHashMap 实际上就是基于 hash 表的一个查找集合。 HashMap 的散列函数12345678910111213141516171819202122// HashMap 维护的 哈希表 transient Node&lt;K,V&gt;[] table; //对 key 进行处理static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; //要想看 HashMap 的散列函数就必须找到 put 方法 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123; //注意这一句的(n-1)&amp;hash 就是数组的小标 ... &#125; HashMap 的散列函数没有一个固定的实现，但是基本的思想都在上面的代码中。 内部实现了一个hash()函数，首先要对key 的 hashCode() 进行处理 该函数将 key.hashCode() 的低 16 位和高 16 位做了个异或运算，其目的是为了扰乱低位的信息以实现减少碰撞冲突。 把处理的返回值与 table.length - 1 做与运算（table 为 哈希表），得到的结果即是数组的下标。 (n-1) 就是数组的最后一位的而下标，就像是一个低位掩码，它和 hash() 做与操作时会将高位屏蔽只保留低位，它会导致总是只有最低的几位是有效的，因为就算你的 hashCode() 实现得再好也难以避免发生碰撞，所以 hash () 对 hash code 的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。 处理冲突HashMap 处理冲突的方式使用的是链地址法。12345678910 //哈希数组 transient Node&lt;K,V&gt;[] table; //节点 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; //可构成链表 &#125; 每个节点都包含下一个节点的引用。链表虽然实现简单，但是在查找的效率上只有 O(n)，而 HashMap 大部分的操作都是在进行查找，如果链表变得越来越长，这个查找的效率就非常差。Java 8 对其实现了优化，链表的节点数量在到达阈值时会转化为红黑树，这样查找所需的时间就只有O(log n)。 红黑树 就是平衡二叉查找树 这就是对阈值的介绍，当链表的长度大于阈值就会转为红黑树，如果小于阈值就转为链表。12345678//链表的节点大于这个值就进行树化static final int TREEIFY_THRESHOLD = 8;//树的节点太少就转为链表static final int UNTREEIFY_THRESHOLD = 6;//数组长度大于这个值才进行树化static final int MIN_TREEIFY_CAPACITY = 64; 12345678/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;&#125;final void treeify(Node&lt;K,V&gt;[] tab) &#123;&#125; 数组扩容HashMap 避免冲突的另一种方式就是对散列表进行动态扩容。所谓扩容，其实就是用一个容量更大（在原容量上乘以二）的数组来替换掉当前的数组，这个过程需要把旧数组中的数据重新hash到新数组，所以扩容也能在一定程度上减缓碰撞。 table 数组的大小约束对于整个 HashMap 都至关重要，为了防止传入一个不是2次幂的整数，必须要有所防范。tableSizeFor()函数会尝试修正一个整数，并转换为离该整数最近的2次幂. 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; HashMap通过负载因子（Load Factor）乘以 table 数组的长度来计算出临界值，算法：threshold = load_factor capacity。比如，HashMap 的默认初始容量为 16（capacity = 16），默认负载因子为 0.75（ load_factor = 0.75），那么临界值就为threshold = 0.75 16 = 12，只要 Entry 的数量大于12，就会触发扩容操作。 1234567891011121314final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; .... // 默认的阈值 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); ... threshold = newThr; ... &#125; return newTab; &#125; 从上面解释可以看出，负载因子越小，数组就越小，查找的性能就会越高，但同时额外占用的内存就会越多，因为需要经常扩容。 扩容后的下标扩容后的下标需要依靠两个前提条件： 数组是永远长度是 2 次幂的. 扩容前的下标是 （n-1）&amp; hash . 前面说过 n-1 就像一个掩码，现在数组增加一倍，在进行 &amp; 操作的时候 n-1 就增加了一位，因此只要判断 hash 和新增加的有效位是 0 还是 1 就可以确定新的位置，如果是 0 就不变，如果是 1 ,索引就是原索引加上扩容前的容量。通过这种方式就可以将本来在 扩容前冲突的两个节点拆分到新的数组，在扩容的时候均匀地散开。 四.TreeMapTreeMap 是一个基于红黑树的有序的 Map ，继承自 AbstractMap 抽象类，实现了 NavigableMap 接口，这个接口又继承了 SortedMap 。 SortedMap12345678910111213141516171819202122232425262728public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123; //定义排序的原则，对 key 进行排序 Comparator&lt;? super K&gt; comparator(); SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K,V&gt; headMap(K toKey); SortedMap&lt;K,V&gt; tailMap(K fromKey); K firstKey(); K lastKey(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();&#125; 这个接口定义就是对 Map 的元素的排序，以及几个子视图，比如 从 from 到 to 的视图或者从 from 到结束或者从开始到 to 的视图。 NavigableMapNavigableMap 对 SortMap 进行了扩展，增加了对键值对的导航方法，和一些以逆序升序排序的集合视图。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123; //返回比 key 小的键值对 Map.Entry&lt;K,V&gt; lowerEntry(K key); K lowerKey(K key); Map.Entry&lt;K,V&gt; floorEntry(K key); K floorKey(K key); Map.Entry&lt;K,V&gt; ceilingEntry(K key); K ceilingKey(K key); Map.Entry&lt;K,V&gt; higherEntry(K key); K higherKey(K key); Map.Entry&lt;K,V&gt; firstEntry(); Map.Entry&lt;K,V&gt; lastEntry(); Map.Entry&lt;K,V&gt; pollFirstEntry(); Map.Entry&lt;K,V&gt; pollLastEntry(); NavigableMap&lt;K,V&gt; descendingMap(); NavigableSet&lt;K&gt; navigableKeySet(); NavigableSet&lt;K&gt; descendingKeySet(); NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive); NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive); SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K,V&gt; headMap(K toKey); SortedMap&lt;K,V&gt; tailMap(K fromKey);&#125; TreeMap对于 TreeMap 返回的子视图，都是由两个内部类提供，对这些集合视图的修改同样会影响 TreeMap。123456789/** * 升序 */static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123;&#125;/** * 降序 */static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123;&#125; TreeMap 之所以能够排序是因为内部使用的是红黑树的数据结构，红黑树就是一种平衡二叉查找树，节点使用一个 boolean 型表示。 12345678910111213141516 private transient Entry&lt;K,V&gt; root; // 根节点 // Red-black mechanics private static final boolean RED = false; private static final boolean BLACK = true; static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK;&#125; 五.LinkHashMapLinkHashMap 是一个用链表维护 Map 元素添加顺序的 Map .123456789101112public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;&#125;static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; LinkedHashMap 继承 HashMap 并实现了 Map 接口，Entry 也继承了 HashMap.Node ,不过增加了 两个节点，before, after 用于将键值对构建成一条双向的链表。 LinkHashMap 同时增加了一个对顺序的标记位。12345// 这个标记位表示的是遍历元素的模式// true 表示按最近最多访问的顺序// false 表示按插入的顺序// 默认是 false final boolean accessOrder; LishHashMap 可以说是结合了 HashMap 查找元素的优点和链表遍历元素的快捷优点，牺牲了获取元素和删除元素维护链表性能。 LishHashMap 并没有重写 put 方法，说明对 put 方式，两者的方式基本是一样，不过是构造节点 newNode 的时候进行前后节点的关联。12345678910private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; &#125; 而对于 get 方法，如果 accessOrder 标记位指定的是访问模式，还需要将最近访问的节点调整到链表的最后。12345678910111213141516171819202122232425262728293031323334public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); //调整这个节点的位置 return e.value; &#125; //将这个节点调整到链表的最后。void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125; &#125; 遍历的时候就直接使用链表的形式进行遍历123456789public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; if (action == null) throw new NullPointerException(); int mc = modCount; for (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != null; e = e.after) action.accept(e.key, e.value); if (modCount != mc) throw new ConcurrentModificationException(); &#125; 因此对于 LinkHashMap 的遍历，时间与元素的数量成正比，而 HashMap 则是与 table 数组成正比。且 LinkHashMap 还支持按访问顺序排序，因此可以简单地运用成最近使用的缓存策略。 六.ConcurrentHashMap前面的 Map 都是属于非线程安全的 Map ，可以通过 Collections.synchronizedMap(Map&lt;K,V&gt; m) 转换成一个线程安全的 Map123456789101112131415161718192021222324252627282930313233343536373839404142434445private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map&lt;K,V&gt; m) &#123; this.m = Objects.requireNonNull(m); mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; synchronized (mutex) &#123;m.putAll(map);&#125; &#125; public void clear() &#123; synchronized (mutex) &#123;m.clear();&#125; &#125; 这种方式就是通过 synchronized 将原本的 Map 进行包装而已，锁住的一整个 Map ,同一时间只能只有一个线程访问，性能极差。 java 8 的 ConcurrentHashMap 则是作为线程安全的最优实现。因为目的是在多线程的环境下使用，因此各个方面就需要考虑多线程的问题。 1.初始化ConcurrentHashMap 的初始化时 懒加载的，只有在 put 操作的时候才进行初始化。为了避免多次初始化，使用了变量 sizeCtl 用于控制 table 数组的初始化和扩容。 1private transient volatile int sizeCtl; 它的值代表如下集中情况： -1 ，表示 table 正在初始化或者扩容 -(1+n) ，表示有 n 个线程在进行扩容 大于 0: table 还未初始化，就表示初始化的数组大小 table 初始化了就表示，触发扩容的阈值。 12345678910111213141516171819202122private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) &#123; // CAS 尝试 try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab; &#125; sizeCtl 是一个 volatile 变量，只要有一个线程 CAS 操作成功，sizeCtl 就会被暂时地修改为-1，这样其他线程就能够根据 sizeCtl 得知 table 是否已经处于初始化状态中，最后 sizeCtl 会被设置成阈值，用于触发扩容操作。 2.扩容对 talbe 的扩容并没有选择直接加锁，而是选择了基于 CAS 的并发同步策略，将table 作为一个多线程共享的任务队列，让多个线程同时协助扩容。这个时候只需要在原来的 table 数组上维护一个指针表示数组下标，当一个线程进行数据迁移的时候，就先移动指针。1234/** * The next table index (plus one) to split while resizing. */ private transient volatile int transferIndex; 3.get123456/** * The array of bins. Lazily initialized upon first insertion. * Size is always a power of two. Accessed directly by iterators. */transient volatile Node&lt;K,V&gt;[] table; 因为 get 只要保证访问 table 与节点的操作总是能够返回最新的数据就可以了。ConcurrentHashMap 并没有采用锁的方式，而是通过 volatile 关键字来保证它们的可见性。虽然 volatile 不保证原子性，但是 ConcurrentHashMap 只是用来确保访问到的变量是最新的，所以也不会发生什么问题。 4.put 和 removeConcurrentHashMap 对锁的粒度只是针对每个 table 元素，对节点进行操作的时候需要通过CAS 和 互斥锁保证线程安全，只对需要操作的这个 table 元素加锁。123456789101112131415161718/** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; //这里是无限循环 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 这里是 CAS 插入 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //如果失败的话才进行 加锁 ... synchronized (f) &#123;&#125; ... &#125; 12345678910111213public V remove(Object key) &#123; return replaceNode(key, null, null);&#125; final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; ... synchronized (f) &#123;&#125; &#125; &#125; 对于 put 操作时先使用 CAS 尝试修改，如果有线程竞争才去通过 加锁，而对于 remove 因为一次需要删除多个，所以是直接加锁。 5.计数123456789101112131415 private transient volatile long baseCount; private transient volatile CounterCell[] counterCells; final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum; &#125; 12345678/** * A padded cell for distributing counts. Adapted from LongAdder * and Striped64. See their internal docs for explanation. */ @jdk.internal.vm.annotation.Contended static final class CounterCell &#123; volatile long value; CounterCell(long x) &#123; value = x; &#125; &#125; ConcurrentHashMap 的计数方式使用两个变量进行协助。在一个低并发的情况下，就只是简单地使用 CAS 操作来对 baseCount 进行更新，但只要这个 CAS 操作失败一次，就代表有多个线程正在竞争，那么就转而使用 CounterCell 数组进行计数，数组内的每个 ConuterCell 都是一个独立的计数单元 每个线程找到自己对应的位置方式类似于 Hash 散列算法，但是这也代表着还是会产生竞争，因此还使用了自旋锁的方式，无限循环加上CAS 来模拟出一个自旋锁来保证线程安全，自旋锁的实现基于一个被 volatile 修饰的整数变量，该变量只会有两种状态：0 和 1，当它被设置为 0 时表示没有加锁，当它被设置为 1 时表示已被其他线程加锁。这个自旋锁用于保护初始化 CounterCell、初始化 CounterCell 数组以及对 CounterCell 数组进行扩容时的安全。 最后的统计就只需要 将每个 CounterCell 和 baseCount 进行相加就行了。]]></content>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络请求框架----OkHttp原理]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6-OkHttp%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一.前言在 Android 中，网络请求是一个必不可少的功能，因此就有许多代表网络请求客户端的组件库，具有代表性的有下面三种： Apache 的 HTTP 客户端组件 HttpClient。 Java JDK 自带的 HttpURLConnection 标准库。 重写应用层代码的 HTTP 组件库。 HttpClient这是 Android 6.0 之前经常会使用的 API ,但是因为不支持 HTTP/2，支持 HTTP/2 的版本还处于 beta 阶段，不适合用于 Android APP 中使用，所以 Google 在 6.0 版本里面删除了 HttpClient 相关 API。 HttpURLConnection这是 Java 自带的一个组件，不需要引入依赖就可以使用，同样这个组件库也无法支持 HTTP/2, 支持的版本也要到 Java 9 后才行。同时这个标准库 封装层次太低，并且支持特性太少，缺乏连接池管理，域名机制控制等特性，因此在 Android 中使用就会相当繁琐。 OkHttp上述两个组件都是不支持 HTTP/ 2 ,但是 HTTP/2 对于移动客户端而言，无论是从握手延迟、响应延迟，还是资源开销看都有相当吸引力，而且 OkHttp 在弱网和无网环境下有自动检测和恢复机制,这使得 OkHttp 成为 Android 最常见的网络请求库。 二.简介OkHttp 是一个支持 HTTP 和 HTTP/2 的封装的网络请求客户端，适用于 Android 和 java 应用程序。OkHttp 有如下优点： 支持 HTTPS/HTTP2/WebSocket 内部维护任务队列线程池，支持 HTTP/2 的并发访问 内部维护连接池，支持 HTTP/1.x 的 keep-Alive 机制，也支持 HTTP/2 的多路复用， 减少连接创建开销。 通过缓存避免重复的请求 请求失败时自动重试主机的其他ip，自动重定向。 三.原理1.初始化OkHttp 的使用初始化有两种方式。 默认方式： 1OkHttpClient mOkHttpClient = new OkHttpClient(); 自定义配置方式： 123456789101112OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout() .writeTimeout() .readTimeout() .cache() .addInterceptor() .connectionPool() .dns() ... ; OkHttpClient mOkHttpClient = builder.build(); 不管是哪种方式，对于 OkHttp 来说都是初始化一些配置，因为这里的参数十分多，所以这里使用的 Builder 设计模式进行简化。Builder 初始化的对象主要有： 123456789101112131415161718192021222324252627282930public OkHttpClient() &#123; this(new Builder()); &#125;public Builder newBuilder() &#123; return new Builder(this); &#125;public static final class Builder &#123; public Builder() &#123; dispatcher = new Dispatcher(); //请求的调度器 protocols = DEFAULT_PROTOCOLS; // 默认支持的协议 connectionSpecs = DEFAULT_CONNECTION_SPECS; // 默认连接配置 eventListenerFactory = EventListener.factory(EventListener.NONE); // 对于请求和回调的监听 proxySelector = ProxySelector.getDefault(); // 代理服务器的选择 cookieJar = CookieJar.NO_COOKIES; // 默认没有 Cookie socketFactory = SocketFactory.getDefault(); // Socket 的工厂 hostnameVerifier = OkHostnameVerifier.INSTANCE; //主机名认证 certificatePinner = CertificatePinner.DEFAULT; // 安全认证相关的配置 proxyAuthenticator = Authenticator.NONE; // 安全认证相关的配置 authenticator = Authenticator.NONE; // 安全认证相关的配置 connectionPool = new ConnectionPool(); //连接池 dns = Dns.SYSTEM; // DNS 域名解析系统 followSslRedirects = true; // 允许SSL重定向 followRedirects = true; // 允许重定向 retryOnConnectionFailure = true; // 允许失败重连 connectTimeout = 10_000; // 连接超时 ， 10 s readTimeout = 10_000; // 读取 超时 ，10 s writeTimeout = 10_000; // 写入超时，10s pingInterval = 0; //ping 间隔时间，这是 WebSocket 长连接的活性检测的间隔时间 &#125; 上面这些配置都是 OkHttpClient 的默认属性，当然也可以使用自己自定义的属性。而且可以看到每一次初始化都会创建新的的 Builder ，因此也会重新创建一个连接池，调度器等耗资源的类，因此在使用 OkHttpClient 通常使用的单例模式，使得整个系统只有一个 请求调度器和连接池，减少资源的消耗。 2.发起请求先看一个请求的创建的方式 123Request.Builder requestBuilder = new Request.Builder().url(url); requestBuilder.method(&quot;GET&quot;, null); Request request = requestBuilder.build(); 可以看到这里同样的是使用 Builder 的模式来创建一个 Request 请求12345678910111213141516public final class Request &#123; final HttpUrl url; final String method; final Headers headers; final RequestBody body; final Object tag; private volatile CacheControl cacheControl; // Lazily initialized. Request(Builder builder) &#123; this.url = builder.url; this.method = builder.method; this.headers = builder.headers.build(); this.body = builder.body; this.tag = builder.tag != null ? builder.tag : this; &#125; Request 主要是对请求的 Url ,请求方法，请求头，请求体，以及缓存首部字段的一个封装而已。对于一个网络请求的， OkHttp 有两种执行的方式： 同步的：executed，这种方式不能在 主线程中调用。 1okHttpClient.newCall(request).execute(); 异步的 enqueue(responseCallback)。12345678910okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;); 3.处理请求在 OkHttp 中一个请求的处理主要是由 dispatcher 分发器负责,先看 Dispatcher 类主要有什么东西。 123456789101112131415161718public final class Dispatcher &#123; private int maxRequests = 64; //最大并发的请求数 为 64 private int maxRequestsPerHost = 5; //每个主机最大请求数为 默认为 5 private Runnable idleCallback; /** Executes calls. Created lazily. */ private ExecutorService executorService; //请求处理的线程池 /** Ready async calls in the order they&apos;ll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //异步处理的准备队列 /** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //异步处理的执行队列 /** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); //同步处理的执行队列&#125; 简单来说就是对于同步请求，使用一个 队列进行保存。对于异步的请求，有一个准备的队列和一个正在执行的队列进行保存。因为同步的方式还是在 主线程中运行，因此没有使用到线程池，而对于异步的方式，OkHttp 使用了线程池对异步请求进行管理。 在一个请求发起之后就是对请求的处理，因为处理请求的方式有同步和异步两种，所以具体的实现也有所不同，下面先看 同步的方式： (1)同步请求的方式1234 // okHttpClient 类中@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 12345678910111213141516171819 // RealCall 类中，实现 Call 接口 final class RealCall implements Call &#123; ...@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); //添加到请求队列中 Response result = getResponseWithInterceptorChain(); //拦截链，对应的一系列方法调用包括请求，得到响应后返回 if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); //结束这个请求 &#125; &#125;&#125; 12345678910111213141516171819 //Call 接口public interface Call extends Cloneable &#123; Request request(); Response execute() throws IOException; void enqueue(Callback responseCallback); boolean isExecuted(); boolean isCanceled(); Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 首先将 Request 封装为一个 RealCall, 这个 RealCall 实现了 Call 接口，在 Call 接口中可以看到里面既有 Request 也有 Response ，显然 Call 接口定义的就是一次 网络请求和其对应的响应的抽象。 在 RealCall 类中一个请求的处理步骤主要是分为三步： client.dispatcher().executed(this); 添加到队列。 getResponseWithInterceptorChain(),发起拦截链，同时得到响应后返回。 client.dispatcher().finished(this);结束这个请求。 dispatcher().executed(this) / client.dispatcher().finished(this)1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; 12345678910111213141516171819/** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call, false); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); if (promoteCalls) promoteCalls(); //对于 executed 方式，这里为false 所以不执行 promoteCalls runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; 对于同步方式，添加队列就是将请求添加到同步执行的队列，然后就调用拦截器链得到请求后就结束这个 Call 。结束的时候就直接从队列中移除。 (1)异步请求的方式12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 可以看到这里将回调的接口封装在 AsyncCall 类里面,这个类继承了 NamedRunnable 抽象类，然后就执行 调度器的分发 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; NamedRunnable 实现了 Runnable 接口，并在 run 方法中调用了抽象方法 execute ，那么也就是说 AsyncCall 的 execute 方法最终会在子线程中执行。12345678910111213141516171819202122232425262728293031 // 实现 Runnable 接口final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; this.responseCallback = responseCallback; &#125; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); //拦截器链 if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); //失败的回调 &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); //成功的回调 &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); //结束这个 Call &#125; &#125; &#125; 在 AsyncCall 的 方法中，首先就是通过拦截器链得到响应，然后对响应进行判断，如果成功就调用 responseCallback.onResponse ，失败就调用就 responseCallback.onFailure 。 在 RealCall 类中一个异步请求的处理步骤主要是分为三步： 在主线程，client.dispatcher().executed(new AsyncCall(responseCallback)); 将 回调接口封装为 AsyncCall 后添加到队列中。 在run 方法中 getResponseWithInterceptorChain(),发起拦截链，同时得到响应后返回。 在run 方法中 ，client.dispatcher().finished(this);结束这个请求。 dispatcher.enqueue(new AsyncCall(responseCallback))1234567891011121314151617synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125; /** Returns the number of running calls that share a host with &#123;@code call&#125;. */ private int runningCallsForHost(AsyncCall call) &#123; int result = 0; for (AsyncCall c : runningAsyncCalls) &#123; if (c.host().equals(call.host())) result++; &#125; return result; &#125; 判断 runningAsyncCalls 正在执行的队列的大小是否小于最大请求数量（最大线程数量、并发数量）并且 所有的 AsyncCall 请求加起来是否小于最大主机请求限制。 如否 将 AsyncCalls 加入到 readyAsyncCalls，的准备队列 如是 加入到 runningAsyncCalls，正在执行的队列中 ，并加入线程池执行。 最后 client.dispatcher().finished12345678910111213141516171819202122232425262728293031323334353637383940/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); if (promoteCalls) promoteCalls(); 因为 为 true 所以还要执行 promoteCalls runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125; &#125; 对于异步请求的结束，首先 判断正在执行的队列 runningAsyncCalls 是否还有请求，有则返回继续请求，没有就判断准备队列 readyAsyncCalls 是否还有请求，没有则返回，有则添加到正在执行的队列,然后执行线程. 4.拦截器链OkHttp 基本上所有的核心功能都是由拦截器链完成的，包括缓存，网络请求获取响应等。在前面的代码中可以看到对于请求的响应的获取都是通过下面这行代码实现的。 1Response response = getResponseWithInterceptorChain(); 下面就看拦截器链的具体实现。 1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 其逻辑大致分为两部分： 创建一系列拦截器，包括用户自定义的拦截器，并将其放入一个拦截器List中。 创建一个拦截器链 RealInterceptorChain, 并执行拦截器链的 proceed 方法. 12345678910111213141516171819public final class RealInterceptorChain implements Interceptor.Chain &#123; ... @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; ... public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, .... // Call the next interceptor in the chain. // 获取下一个拦截器，并调用其 intercept 方法。 RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); .... return response; &#125;&#125; 在拦截器的 intercept 方法里，以 RetryAndFollowUpInterceptor 为例： 123456789101112131415161718192021222324252627public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); // 对请求前的处理 streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); &#125; Response response = null; boolean releaseConnection = true; try &#123; //这里再去调用拦截器链的 proceed ， response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; // 下面就是对 得到响应后的处理，这里就省略。 &#125; 在 RealInterceptorChain 里会去执行拦截器链的 proceed 方法。而在拦截器链中又会执行下一个拦截器的 intercept 方法，在下一个拦截器的 intercept 中又会去执行拦截器链的 proceed ，此时 index + 1 。所以整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。这也是 OkHttp 拦截器的链式执行逻辑。而一个拦截器的 intercept 方法所执行的逻辑大致分为三部分： 在发起请求前对request进行处理 调用下一个拦截器，获取response 对response进行处理，返回给上一个拦截器 这就是 OkHttp 拦截器机制的核心逻辑。所以一个网络请求实际上就是一个个拦截器执行其intercept 方法的过程。而这其中除了用户自定义的拦截器外还有几个核心拦截器完成了网络访问的核心逻辑，按照先后顺序依次是： RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor ConnectIntercetor CallServerInterceptor (1)RetryAndFollowUpInterceptor123456/** * This interceptor recovers from failures and follows redirects as necessary. It may throw an * &#123;@link IOException&#125; if the call was canceled. */public final class RetryAndFollowUpInterceptor implements Interceptor &#123; /** 从英文解释就连可以看出这个拦截器主要负责失败重传和在必要的时候进行重定向，当一个请求由于各种原因失败了，处理以得到新的Request，沿着拦截器链继续新的Request。 (2)BridgeInterceptor1234567/** * Bridges from application code to network code. First it builds a network request from a user * request. Then it proceeds to call the network. Finally it builds a user response from the network * response. */public final class BridgeInterceptor implements Interceptor &#123; 这个拦截器作为应用程序模块代码和网络请求模块代码的桥梁，首先会从使用者的 request 构建一个真正的网络请求，然后将这个请求提交给网络请求模块，最后就从网络请求模块返回的数据构建一个 response 给使用者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); &#125; else &#123; requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); &#125; &#125; if (userRequest.header(&quot;Host&quot;) == null) &#123; requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(&quot;Connection&quot;) == null) &#123; requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); &#125; // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123; transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); &#125; if (userRequest.header(&quot;User-Agent&quot;) == null) &#123; requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); &#125; //到这里网络请求前拦截的动作就已经完成，主要有： // 设置内容长度，内容编码 // 设置gzip压缩 //添加cookie //设置其他请求头首部，如 User-Agent,Host,Keep-alive 等。其中 Keep-Alive 是实现多路复用的必要步骤 //下面就到下一个拦截器去获取真正的网络响应。 Response networkResponse = chain.proceed(requestBuilder.build()); // 获取网络的响应后，在这里也进行拦截，做一些处理，比如压缩，添加响应头等。 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; BridgeInterceptor 作为客户端和网络请求的桥梁，在这里将 Request 和 Response 做一个处理。主要有： 1.在请求前拦截： 设置内容长度，内容编码 设置gzip压缩 添加cookie 设置其他请求头首部，如 User-Agent,Host,Keep-alive 等。其中 Keep-Alive 是实现多路复用的必要步骤 2.调用下一个拦截器去获取响应3.获取响应后再次拦截 压缩 添加/删除响应首部字段 (3)CacheInterceptor12/** Serves requests from the cache and writes responses to the cache. */public final class CacheInterceptor implements Interceptor &#123; CacheInterceptor 主要是负责读取缓存和更新缓存。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 获取定义响应读取的策略，分为仅从网络获取响应，仅从缓存获取响应，或者网络和缓存配合。 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it. &#125; // If we&apos;re forbidden from using the network and the cache is insufficient, fail. //如果指定仅从缓存获取但是缓存没有就返回一个 504 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don&apos;t need the network, we&apos;re done. //如果没有指定从网络获取并且缓存不为空，那么就将缓存返回。 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //去网络获取响应 Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we&apos;re doing a conditional get. //必要的时候更新缓存，并返回 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //如果没有缓存就将这个响应写入缓存。 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; 缓存的主要总结步骤如下： 如果指定仅从缓存获取但是缓存没有就返回一个 504 如果没有指定从网络获取并且缓存不为空，那么就将缓存返回。 去网络获取响应 已经有缓存并且缓存需要更新的时， 更新缓存，并返回 如果没有缓存就将这个响应写入缓存。 缓存使用的是策略模式，将缓存的策略封装在 CacheStrategy ，这个类告诉 CacheInterceptor 是使用缓存还是使用网络请求 。缓存操作的定义是 接口 InternalCache ，主要操作有 put, get, 和 更新等。而具体的实现类说就是 Cache1234567891011121314151617181920212223242526272829303132333435public final class Cache implements Closeable, Flushable &#123; .... final InternalCache internalCache = new InternalCache() &#123; @Override public Response get(Request request) throws IOException &#123; return Cache.this.get(request); &#125; @Override public CacheRequest put(Response response) throws IOException &#123; return Cache.this.put(response); &#125; @Override public void remove(Request request) throws IOException &#123; Cache.this.remove(request); &#125; @Override public void update(Response cached, Response network) &#123; Cache.this.update(cached, network); &#125; @Override public void trackConditionalCacheHit() &#123; Cache.this.trackConditionalCacheHit(); &#125; @Override public void trackResponse(CacheStrategy cacheStrategy) &#123; Cache.this.trackResponse(cacheStrategy); &#125; &#125;;// 缓存的核心类 final DiskLruCache cache; &#125; 可以缓存这里的核心类是 DiskLruCache ，Cache 虽然没有实现 InternalCache 接口吗，当时基本上左右的具体的功能，都是由 Cache 结合 InternalCache 完成。 (4)ConnectIntercetor12/** Opens a connection to the target server and proceeds to the next interceptor. */public final class ConnectInterceptor implements Interceptor &#123; 这个拦截器即打开一个连接到目标服务器，并将这个链接提交到下一个拦截器。 123456789101112@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125; 虽然这个只有这么点代码，但是实际上关于连接池的复用等功能都被上面的类封装起来了。之所以采用复用的原因是客户端和服务器建立 socket 连接需要经历 TCP 的三次握手和四次挥手，是一种比较消耗资源的动作。Http 中有一种 keepAlive connections 的机制，在和客户端通信结束以后可以保持连接指定的时间。OkHttp3 支持 5 个并发 socket 连接，默认的 keepAlive 时间为 5 分钟。这种复用的模式就是 设计模式中的享元模式。 1.StreamAllocation这个类协调三个实体之间的关系。 Connections：连接远程服务器的物理 Socket 连接 Streams : 基于 Connection 的逻辑 Http 请求/响应对一个请求/响应 对应一个 Streams . 在 Http1.x，一个 Streams 对应一个 Connections。在 Http2.0，多个 Streams 可对应一个 Connections，进行并发请求。 Calls : 逻辑 Stream 序列，也就是请求/响应 队列 StreamAllocation 会通过 ConnectPool 获取或者新生成一个 RealConnection 来得到一个连接到 Server 的 Connection 连接，同时会生成一个 HttpCodec 用于下一个 CallServerInterceptor ，以完成最终的请求.在 newStream 方法中123456789public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123; try &#123; 找到一个合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); HttpCodec resultCodec = resultConnection.newCodec(client, this); .... &#125; 2.ConnectionPool12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class ConnectionPool &#123; private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true)); /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; ...... &#125; &#125;; private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); final RouteDatabase routeDatabase = new RouteDatabase(); boolean cleanupRunning; ...... /** *返回符合要求的可重用连接，如果没有返回NULL */ RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; ...... &#125; /* * 去除重复连接。主要针对多路复用场景下，一个 address 只需要一个连接 */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; ...... &#125; /* * 将连接加入连接池 */ void put(RealConnection connection) &#123; ...... &#125; /* * 当有连接空闲时唤起cleanup线程清洗连接池 */ boolean connectionBecameIdle(RealConnection connection) &#123; ...... &#125; /** * 扫描连接池，清除空闲连接 */ long cleanup(long now) &#123; ...... &#125; /* * 标记泄露连接 */ private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; ...... &#125;&#125; ConnectionPool 内部通过一个双端队列 dequeue) 来维护当前所有连接，主要涉及到的操作包括： put：放入新连接 get：从连接池中获取连接 evictAll：关闭所有连接 connectionBecameIdle：连接变空闲后调用清理线程 deduplicate：清除重复的多路复用线程 下面就看看一个是如何找到的： 12RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); 1234567891011121314151617181920212223private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn&apos;t, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; noNewStreams(); continue; &#125; return candidate; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */ private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException(&quot;released&quot;); if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;); if (canceled) throw new IOException(&quot;Canceled&quot;); // Attempt to use an already-allocated connection. RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; // Attempt to get a connection from the pool. Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; return connection; &#125; selectedRoute = route; &#125; // If we need a route, make one. This is a blocking operation. if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); &#125; RealConnection result; synchronized (connectionPool) &#123; if (canceled) throw new IOException(&quot;Canceled&quot;); // Now that we have an IP address, make another attempt at getting a connection from the pool. // This could match due to connection coalescing. Internal.instance.get(connectionPool, address, this, selectedRoute); if (connection != null) return connection; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result); &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; // Pool the connection. Internal.instance.put(connectionPool, result); // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); return result; &#125; 上面找连接的步骤可以总结为： 查看当前 streamAllocation 是否有之前已经分配过的连接，有则直接使用 从连接池中查找可复用的连接，有则返回该连接 配置路由，配置后再次从连接池中查找是否有可复用连接，有则直接返回 新建一个连接，并修改其 StreamAllocation 标记计数，将其放入连接池中 查看连接池是否有重复的多路复用连接，有则清除，一个地址只需要一个连接。 而在连接池中判断一个连接是否可以复用的条件为: 连接没有达到共享上限 非host域必须完全一样 如果此时host域也相同，则符合条件，可以被复用 如果host不相同，在HTTP/2的域名切片场景下一样可以复用. 对于连接的清除，ConnectPool 有一个独立的线程进行清理的工作： 遍历连接池中所有连接，标记泄露连接（即空闲时间即将达到5分钟） 如果被标记的连接满足(空闲 socket 连接超过5个&amp;&amp; keepalive 时间大于5分钟)，就将此 连接从 Deque 中移除，并关闭连接，返回 0，也就是将要执行 wait(0)，提醒立刻再次扫描 如果(目前还可以塞得下5个连接，但是有可能泄漏的连接(即空闲时间即将达到5分钟))，就返回此连接即将到期的剩余时间，供下次清理 如果(全部都是活跃的连接)，就返回默认的keep-alive时间，也就是5分钟后再执行清理。 3.RealConnection描述一个物理 Socket 连接，连接池中维护多个 RealConnection 实例。由于Http/2支持多路复用，一个 RealConnection 可以支持多个网络访问请求，所以 OkHttp 又引入了 StreamAllocation 来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个 Stream 对应一次请求，而一个 Call 对应一组有逻辑关联的 Stream ），一个 RealConnection 对应一个或多个 StreamAllocation ,所以 StreamAllocation 可以看做是 RealConenction 的计数器，当 RealConnection 的引用计数变为 0，且长时间没有被其他请求重新占用就将被释放. 多路复用:报头压缩：HTTP/2 使用 HPACK 压缩格式压缩请求和响应报头数据，减少不必要流量开销.请求与响应复用：HTTP/2 通过引入新的二进制分帧层实现了完整的请求和响应复用，客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端将其重新组装指定数据流优先级：将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系流控制：HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制. 4.HttpCodec针对不同的版本，OkHttp 为我们提供了 HttpCodec1（Http1.x）和 HttpCodec2(Http2).他们就是协议的具体实现类。 (5)CallServerInterceptor(forWebSocket)12/** This is the last interceptor in the chain. It makes a network call to the server. */public final class CallServerInterceptor implements Interceptor &#123; 这是整个拦截链的最后一个拦截器，负责和服务器发送请求和从服务器读取响应，利用 HttpCodec 完成最终请求的发送。 到这里整个拦截链的分析就到这里，大致流程如图，责任链模式在这里就体现得十分清楚：]]></content>
      <tags>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络请求框架----理解HTTPS]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6-%E7%90%86%E8%A7%A3HTTPS%2F</url>
    <content type="text"><![CDATA[一.前言学习过计算机网络的都知道对于计算机网络的体系结构，如果以五层协议为标准可以将整个体系划分为五层，即物理层，数据链路层，网络层，运输层和最后的应用层，应用层的任务是通过应用进程间的交互来完成特定的网络应用，应用层的协议定义的是应用进程间的通信和交互的规则，具体的实现则是由下一层去实现，以 Android 来说就是 Android 客户端应用进程和服务器应用进程的通信。而 HTTP / HTTPs 等协议就是属于应用层的协议。 二. HTTP1.简介HTTP 翻译为超文本传输协议，定义了客户进程如何向服务器请求资源以及服务器如何将资源返回给客户端。HTTP 使用的是面向连接的 TCP 的运输层协议，保证数据的可靠传输，但是 HTTP 是无连接的，也就是说在应用层面交换报文的时候不会先进行连接。 2.HTTP 是无状态的HTTP 是无状态的意思就是说对于同一客户端的每一次请求服务器的处理都是一样的，不会记录客户端的上一次访问，也不记得客户端访问过多少次，因此使得服务器更能支持大量的并发操作。 3.HTTP 从非持续连接到持续连接虽然 HTTP 是无连接，但是 TCP 是面向连接的，所以客户端发起一个请求的时候还是要先建立连接，然后再进行 HTTP 通信，最后再断开连接。 HTTP 1.0在HTTP 协议 1.0 版本和之前的时候， HTTP 都是属于这种非持续连接的方式，即每个请求访问都需要建立连接，释放连接，即使在同一个页面下也是如此，这是因为一个页面通常存在多个请求。非持续的连接不仅会增加了服务器的负担而且对于同一个界面的响应速度也会降低。 HTTP 1.1HTTP 1.1 版本使用了持续连接，持续连接就是客户端和服务器在建立连接后进行通信后，仍然在一段时间内保持连接，这样客户端和服务器后续的请求就不用再进行建立释放的操作。而且持续连接还可以进行非流水线的方式进行通信，就是下一次的客户端请求不用等上一次的服务器的答复就能发送，使得客户端的访问更加高效快速。 4.报文结构HTTP 有两种报文： 请求报文，客端发给服务器请求。 响应报文，服务器针对客户端的请求的响应。 在实际的场景的时候我们看到的是如下的格式： (1) 请求报文请求报文中包含了请求方法，URL, 协议的版本，接着就是首部行，包含各种各样的请求字段，最后就是报文的主体。 方法，表示这次请求的具体操作，一般有如下几种： GET, 获取资源，即简单从服务器获取资源 POST,上传实体，即将信息上传到服务器 HEAD,获得响应报文的首部，通常用于检测 URL 的有效性，和资源是否更新。 OPTIONS，表示查询服务器资源能支持的方法，比如支持 GET,POST就返回 Allow :GET，POST 。 CONNECT,表示要求在服务在与代理服务器通信的时候建立隧道，实现用隧道协议进行 TCP 通信。 URL,统一资源定位符 URL 统一资源定位符，在网络中表示互联网资源的地点。 URI 统一资源标识符,表示某一个互联网的资源。在网络中很多情况下上 URL 和 URI 表示的同一个东西。 版本，协议的版本在 HTTP 中有 HTTP/1.0 HTTP/1.1 HTTP/2 ,当然还可能使其他的协议。 首部字段，是对请求的具体方式的进一步的描述首部字段中包含有通用的字段，即 请求报文或者响应报文都可以有的字段，同时也有请求报文独有的字段。 请求的首部字段： Accept，表示能够处理的媒体类型，即对每种类型的优先级。比如 文本文件 text/html 。 图片文件 image/jpeg, image/gif,image.png。 视频文件 video/mpeg。在后面可使用 q 指点优先接受的媒体类型 范围为 0 ~ 1。 Accept-EnCoding， 允许对资源的压缩解压方式。 Accept-Charset，允许的字符集。 Accept-Language，允许的语言，指处理的自然语言集。 Host，表示请求的资源的所处的服务器和主机名。 Authorization，表示添加用户的认证信息。 User-Agent ，创建请求的客户端和用户代理等信息。 等等。 (2) 响应报文版本，这里指的是协议的版本，如果上述的版本一样，这里不再赘述。状态码/短语，指的是对每一次的请求，服务器做出响应后回将结果放回给客户端，表示成功或失败或更具体地信息。状态码就是对结果状态的一种表示，短语就是添加简单的原因。2xx 以 2 开头的表示请求正常处理完毕 200 OK，表示从客户端发来的请求在服务器端被正常处理了 3xx 表示需要进行附加操作以完成请求（重定向） 301 Moved Permanently ，永久性重定向，该状态表示请求的资源已被分配了新的 URI指的是永久性的移动 302 Found ，临时重定向，表示请求的资源已被分配新的 URI ,但是暂时性的 4xx 表示服务器无法处理请求 400 Bad Request 该状态码表示请求的报文存在语法错误，需要修改内容再次发送请求。 401 Unauthorized，该状态码表示发送的请求需要通过 HTTP 认证的认证信息，例外若需要之前进行过一次请求，则表示用户认证失败 403 ForBidden ，表示对请求的资源的访问被服务器拒绝了 404 Not Found ，无法找到请求的资源，也可以表示服务端拒绝请求且不想说明的理由。 5xx 服务器请求出错 500 Internal Server Error ，服务器内部出现了错误 503 Service Unavailable ，表明服务器正处于超负荷或者正在进行停机维护，无法处理请求。 响应首部字段 Accept-Ranges ：请求对资源的一部分进行请求，结果就放回这一部分的范围。 Age，表示服务器多久前创建了响应 Location，表示请求的资源被重定向后的 URL. Proxy-Authenticate,对代理服务器的认证信息的请求的回答。 (3)通用的首部字段 Cache-Control，缓存指令，能够控制缓存的行为，缓存响应指令有 no-cache ，目的是为了防止从缓存中返回过期的资源，表示客户端不会接收缓存过的响应。no-store 暗示请求或者响应包中包含机密的信息，不能缓存。 Connection，控制不再转发给其他代理的首部字段。 Date，表明HTTP 报文创建的时间。 等等 (4)实体字段 Allow，资源可支持的 HTTP 方法 Content-Encoding，实体的主体部分选用的内容编码方式。 Content-Language，实体主体使用的自然语言。 Content-Length，实体主体的部分的大小，单位是字节。 Content-Type，实体主体对象 的媒体类型 等等 5.Cookie前面说过 HTTP 是状态的协议，因此不会对之前发生过的请求和响应做处理。但是对于需要登录认证的服务端，每次请求都进行登录认证显然不合适，因此 HTTP 引入 Cookie 技术，通过在请求和响应报文中添加 Cookie 信息来管理客户端的状态。 Cookie 的工作方式： 首先客户端第一次访问服务器，服务器会产生一个唯一的标识码，比如 SessionID, 然后把这个标识码添加到响应报文中，以 Set-Cookie 为首部字段。例如 Set-Cookie :1df5f36t61b5y5k2d9w7h3h 客户端收到响应报文后，就将这个标识码进行保存，以后再每次请求这个服务器的时候就把这个标识码添加到 HTTP 请求报文中，以 Cookie 为首部字段 ，比如 Cookie : 1df5f36t61b5y5k2d9w7h3h 服务器收到这个标识码就可以追踪到客户端的上一次活动。 三.网络安全在网络通信过程中，由于网络设备，网线光缆，计算机等都有可能是共有的物品，因此在网络上传输一些隐私信息的时候就需要对数据进行保护。一个安全的计算机网络至少应到达下面三个目标: 保密性，只有发送方可接收方才能读懂信息的内容，信息的截获者就算获取了信息也无法读懂。 端点鉴别，能够识别信息的发送方和接收方的真实身份，确保不是冒充者。 信息的完整性，保证信息在传输的过程中没有被篡改。 1.保密性现在的数据加密技术一般有两种： 对称密钥密码体制 公钥密码体制 (1)对称密钥加密又称共享密钥加密，即发送方和接收方都是用同一把密钥对密文进行加密解密，发送方先把密钥发给接收方，接着通过密钥加密数据，最后把密文发送出去，接收方收到密文后就使用前面收到的密钥进行解密。这种方式显然是有问题的，因为密钥如果被窃取了，后面的密文加密效果就同样失效。 (2)公钥密码体制对称加密在两方之间使用的是同一把密钥，而公钥密码加密使用的是一对不同的密钥。 使用公开密钥加密方式，两个对等方都会有两把密钥，一把是公开的密钥，可以向任何人公开，一把是私有的，不能向外公开。这两把密钥的关系是私有密钥用于解密公开密钥加密的密文。 一方通过对方的公开密钥进行加密，然后发送给另一个方。 另一方收到密文后就用自己的私有密钥进行解密。 通过这种方式就不存在这对称密钥的不安全问题。但是还是存在着一个问题，就是无法确定密钥是否是对方的公开密钥的问题。实际上这个问题和端点鉴别本质上是一样的，就是确认真实性。 2.端点鉴别端点鉴别可以分为两种，一种是对于客户端的认证，一种是对于使用者实体的认证，因为就算客户端是真实可信的，但是使用者还是可能存在这是用他人的计算机进行冒充 (1)客户端认证为了确认通信方，有一种称为证书的手段，可以确认通信方。证书是由值得信任的第三方机构颁发的，用于证明服务器和客户端是实际存在的，而且伪造证书技术十分困难，所以只要持有证书即可判断通信方的真实身份。 对于上述的密钥的问题，对密钥的认证的称为密钥证书。 一般服务器会先向认证机构提出身份确认，并对自己的公开密钥做数字签名 （也就是对密钥进行盖章），然后就可以对外公布这个公开密钥，将这个密钥和证书绑定。 服务器可以将证书发送给客户端，接到证书的客户端就可以使用证书认证自己持有的共有密钥，（验证密钥和数字签名是否匹配）验证通过就可以确定密钥的真实性，即公开密钥是可以信赖的。（通常发送方会先植入常用的认证机关发布的公开密钥，以免去证书的发送过程） (2)使用者认证在 HTTP 中使用了如下几种对用户进行认证的方式： BASIC 认证 DIGEST 认证 SSL 客户端认证 FormBase 认证 1.BASIC 认证BASIC 认证就是使用 Authorization/WWW-Authenticate 首部字段进行认证。 客户端发起请求，服务器返回 401 的状态码和 WWW-Authenticate 字段要求认证 客户端将账号和密码添加到请求到 Authorization 请求头，发送请求。 服务器对信息进行认证，返回成功或者失败。 因为账号和密码是直接在信息中添加的，因此就有泄露的风险。 2.DIGEST 认证DIGEST 认证不直接发送账号和密码，而是使用质询码。 客户端先发送认证请求。 服务器返回一端质询码。 客户端从质询码计算出响应码后返回。 3.SSL 认证SSL 认证就是类似于使用客户端认证的方式，服务器凭借客户端的证书进行认证。 4.基于表单认证客户端会向服务器发送登录信息，按登录的信息结果进行认证，这种方式是通过所密文加密对账号和密码进行保护的，通常使用的认证方式都是属于这种表单认证方式。 3.信息的完整性对于信息的完整性，通常使用的是 MD5 和 SHA 等散列值校验法，这两种算法都是使用密码散列函数。 散列函数：散列函数的输入长度可以很长，但是输出长度是固定，并且较短，散列函数的输出叫做散列值，简称散列。不同的散列值肯定对应步不同的输入，但是不同的输入可能得出相同的散列值，就是说散列函数的输入和输出是多对一的关系。 因为要找到两个不同的报文使得有相同的散列输出基本不可能实现，因此散列函数是一种单向函数，对于 MD5 ,因为现在已经被证明能够找到一对报文有相同的散列值，所以对于 MD5 进行改进推出 SHA . 通过使用各种鉴别算法，就能提高信息的完整性。 4.安全协议目前对于网络安全提供安全服务，被广泛使用的有两个协议： 安全套接字层 SSL 运输层安全 TSL TSL 是对 SSL 的改进，因此通常将 TSL/SSL 统称为 SSL, SSL 安全服务本质上使用的就是上述三种方法，达到网络通信的安全。 三.HTTPS对于 HTTP 协议来说，它并没有对数据进行保护，存在网络安全问题： 通信使用明文，内容可能被窃听。 不验证通信方的身份，因此存在着通信方是冒充者的情况。 无法验证报文的完整性，即数据有可能被篡改。 为了解决上述的问题，在 HTTP 的基础上加上网络安全等技术就是 HTTPS . HTTP + 加密 + 认证 + 完整性保护 = HTTPSHTTP + SSL = HTTPS 以上两种说法都是说明 HTTPS 在网络通信中已经足够安全，使用 HTTPS 通信的时候不再使用 http:// ，而是使用 https:// ，现在的 Chrome 浏览器就可以识别。 HTTPS 不是一种新的协议，只是对于一些接口使用 SSL 代替。 1.HTTPS 采用的是混合加密在前面描述过两种加密的方式，第一种速度快但是不安全，第二种安全但是速度慢，因此为了结合两种优点， HTTPS 使用的是两种加密方式混合使用的方式。 先使用公开密钥的方式安全的交换共享密钥中使用的密钥。 确保交换的密钥是安全的前提下，使用共享密钥进行通信，这样就能共享密钥的安全性，而且提高了通信的速度。 2.HTTPS 的通信机制结合上述的知识，HTTPS 的通信如下： 引用自 上野 宣的《图解 HTTP 》 步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件列表（所使用的加密算法及密钥长度等）。 步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。也就是从客户端的列表选出服务器支持的加密组件然后通知客户端使用哪一种加密。 步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。 步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的SSL握手协商部分结束。 步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。 步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 步骤 8： 服务器同样发送 Change Cipher Spec 报文。 步骤 9： 服务器同样发送 Finished 报文。 步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP请求。 步骤 11： 应用层协议通信，即发送 HTTP 响应。 步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。 大致情况如图：]]></content>
      <tags>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步任务----AsyncTask解析]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-AsyncTask%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一.前言AsyncTask 异步任务，是 Android 中用于异步执行耗时任务的类，封装了 Hanlder ，Message 和 线程池。AsyncTask 的封装使得开发者在开发过程中不用再自己编写相应的 Handler 或者线程执行的方法。 二.简介123456public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; ... @WorkerThread protected abstract Result doInBackground(Params... params); ...&#125; AsyncTask 是一个抽象类,使用的时候需要实现 doInBackground 这个方法，同时需要指三个泛型参数，从名字就基本可以看出这三个参数的作用： Params，用于指定传递给 AsyncTask 的参数类型 。 Progress ，用于在任务进行中返回的任务进度的类型 。 Result，用于指定任务执行完成后返回的类型。 AsyncTask 的执行从开始到结束主要有下面的几个方法： execute，传递这个 Params 参数并开始执行任务，注意每一个 AsyncTask 对象只能执行一次，如果需要重复的任务就需要重复的创建这个对象。 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; onPreExecute，在任务执行之前调用（Pre 之前），运行在 主线程，可以对 UI 做一些任务前的处理比如提示加载框等。 123@MainThreadprotected void onPreExecute() &#123;&#125; doInBackground，在工作线程执行，也就是在子线程执行，接收参数 Params 执行完成后就将 Result 类型的结果返回。 12@WorkerThreadprotected abstract Result doInBackground(Params... params); publishProgress,在工作线程执行，可以在 doInBackground 方法中调用，用于在任务进行的过程中不断更新 UI ,传入的参数就是之前指定的 Progress 类型。 123456@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; .... &#125;&#125; onProgressUpdate 工作在主线程，在 publishProgress 调后，具体的 UI 的更新操作就是在 onProgressUpdate 这里执行，接收从 publishProgress 传过来的 参数并执行相应的更新操作。 123@MainThreadprotected void onProgressUpdate(Progress... values) &#123;&#125; onPostExecute，运行在主线程，在任务执行完成后（Post 之后），任务完成后会返回一个 Result 类型的值，可以在这里获取并执行 Ui 操作。 123@MainThreadprotected void onPostExecute(Result result) &#123;&#125; onCancelled，取消任务的时候会执行，运行在住线程，对 UI 做一些状态的恢复工作。 1234567@MainThreadprotected void onCancelled(Result result) &#123; onCancelled();&#125; @MainThreadprotected void onCancelled() &#123;&#125; 三.原理AsyncTask 暴露出来的方法的生命期就是上面所介绍的，下面就具体看看 AsyncTask 是如何处理异步操作的。 1.创建123456789101112public AsyncTask() &#123; this((Looper) null);&#125;public AsyncTask(@Nullable Handler handler) &#123; this(handler != null ? handler.getLooper() : null);&#125;public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); 可以看到刚开始 new AsyncTask 的时候如果没有指定 Looper 或者指定的 Looper 是主线程的 Looper 就是使用 AsyncTask 封装的 Hanlder ( InternalHandler ) ，否则就根据 指定的 Looper 创建一个 Hander. 12345678910111213141516171819202122232425262728293031323334public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); ... &#125; &#125; &#125;; &#125; 在创建的过程中会初始化一个 WorkerRunnable ，这是一个封装的 Runnable 对象，在这个对象中首先会所处的线程的优先级设置为 Process.THREAD_PRIORITY_BACKGROUND 后台线程，然后就是将 doInBackground 方法封装在这个 workerRunnable ，然后再将这个 Runable 封装到一个 FutureTask 这是一个可以有返回值的线程任务，相对于的 Runable 就是一个 没有返回值的线程任务。 2.execute 开始执行这里首先先介绍几个重要的对象 sPoolWorkQueue,阻塞队列，使用的是 LinkedBlockingQueue 的阻塞队列。 THREAD_POOL_EXECUTOR ，执行任务的线程池，与线程池配套的是 上面的阻塞队列。 SERIAL_EXECUTOR，任务排队的线程池 sDefaultExecutor，默认的线程池，默认为 SERIAL_EXECUTOR sHandler，封装的 InternalHandler ，也就是 Hanlder .123456789101112131415private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR;static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static InternalHandler sHandler; 这里看一下 SerialExecutor 。 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 可以看到这里使用的 ArrayDeque ，这是一种先进先出的队列，所以在 AsyncTask 任务执行就是一个接一个的执行。在任务执行的线程池中不会产生并发执行的过程。 回到 execute 方法 1234567891011121314151617181920212223242526272829@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); //这里执行方法 mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 可以看到 execute 方法执行后会调用 executeOnExecutor，在里面就会先进行一个些判断，如果当前任务是 RUNNING 即运行状态或者 FINISHED 即终止状态就抛出异常，否则就将状态设置为 RUNNING 并开始执行 onPreExecute 方法，最一些任务执行前的操作，最后就将任务提交的 SerialExecutor 线程池。在 SerialExecutor 中12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 前面也说过 提交的任务在这里会添加的 ArrayDeque 的 mTasks 队列中，然后再去 THREAD_POOL_EXECUTOR 中做真正的执行。保证了 任务的执行是串行的过程。 在 THREAD_POOL_EXECUTOR 执行完成后 WorkerRunnable 的 方法后最后就会调用 postResult1234567mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; ... result = doInBackground(mParams); ... postResult(result); &#125;; 跳转到 postResult12345678private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; &#125; 这里就使用 message 和 getHandler 发送消息，直接看 InternalHandler1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 可以看到最后调用的就是 result.mTask.finish(result.mData[0]); ，这个 result.mTask 就是一个封装了最后的结果和 AsyncTask 的对象，也就是将执行的结果 传递给了finish 方法，而且也从工作线程回到了 主线程。12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; 在finish 就会调用 onPostExecute 方法执行最后的显示操作，并将 状态设置为 FINISHED ，一旦设置为 FINISHED 就说明这个 AsyncTask 对象不能再执行 任务。 对于任务的更新操作也是类是的过程，首先通过 getHandler 发送 Message.1234567@WorkerThread protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; 最后就是在 Handler 里面进行处理调用 result.mTask.onProgressUpdate(result.mData); 方法。 同样从工作线程回到了主线程 ，然后就是进度的更新方法 onProgressUpdate 。 就这样 AsyncTask 的原理就介绍到此。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View注解框架----ButterKnife]]></title>
    <url>%2F2018%2F09%2F21%2FView%E6%B3%A8%E8%A7%A3%E6%A1%86%E6%9E%B6-ButterKnife%2F</url>
    <content type="text"><![CDATA[一.简介ButterKnife 是 jake Wharton 的一个用于 View 注解框架，目前已经有 22000+ star , ButterKnife 的用处就是为开发者减少类似于 findViewById, setOnClickListener 等重复的代码，取代之的是通过注解对代码进行标记，让编译器自动生成需要的代码。 那么 ButterKnife 究竟怎么实现的呢？简单地说就是使用了注解，通常我们对注解的处理，又两种方式，一是通过反射处理注解，一种是通过注解处理器，而 ButterKnife 就是通过注解处理器实现对注解的处理，但是在整个框架的其他地方中还是有使用到反射的。 二.反射1.反射的由来java 对象在运行的时候有时因为多态的原因会产生两种类型 ： 编译时类型 运行时类型 比如对于 Person p = new Student，它的编译的时类型就是 Person，而运行时类型就是 Student。对于编译时类型在编译前就可以确定，而对于运行时类型，因为只有在运行的时候才能确定，所以有时不能直接通过对象进行访问。但是有时程序需要调用的是对象在运行时的类型方法，那有该怎么办呢？解决方式有两种： 在编译时和运行的都完全知道类型的具体信息，使用 instanceof 进行，再进行类型转换。 无法知道该对象属于哪些类，程序只能依靠运行时信息确定，就必须使用反射。 2.反射的使用反射就是根据一些类的信息确定一个对象属于哪个类还可以因此生成一个该类的对象。首先就是获取一个类的 Class 对象，每一个类都有一个 Class 对象，保存着这个类的信息。 (1)获取 Class 对象 Class forName（”全限定类名”）。 通过某个类的 Class 属性，获得该类对应的 Class 对象。比如 String.class 调用某个对象的 getClass 方法。 通过类加载器，Class.loadClass(className) (2)从Class 中获取信息 getConstructor 等，获取构造器 getMethod 等，获取 Class 对应类的方法 getField 等，获取类的成员变量 getAnnotation 等，获取 class 上的 Annotation 就是注解信息。 等等 (3)通过反射生成并操作一个对象1.创建一个对象 Class newInstance，要求有对应类有默认构造器 获得制定的构造器，再调用构造器的 newInstance ，这种方式可以可以选择使用指定的构造器器创建实例。 2.调用方法 每个 Method 有一个 invoke （Object ,Object…）方法，Object 是方法的主调就是方法的调用对象，Object… 是方法的参数 3.访问成员变量 通过 getFields/getField 可以对成员变量进行访问，set/get 方法。 在访问成员变量和调用方法的时候需要对他们的访问权限做一些处理，setAccessible(boolean flag) ： true，指示在使用方法或者成员变量的时候取消 java 的 访问权限检查。 false，指示 Method 在使用的时候 实施 java 的访问权限检查。 三.注解 Annotation注解就是对部分代码进行标记，然后可以在编译，类加载，运行的时候被读取，并执行相应的处理， 从而对源文件补充一些信息。 1.基本的 Annotation @Override ，指定一个方法必须重写父类的方法，就是告诉编译器，检查这个方法，保证父类有一个父类重写的方法，否则编译就出错。 @Deprecated，标记过时的方法等 @SupperssWarnings，指示被修饰的程序元素，取消显示指定的编译器警告，要在括号内使用 name = value ,为该 Annotation 的成员变量设置值。 等等 2.自定义的 Annotation定义一个 Annotation 与接口类似，不过使用的是 @interface 而不是 interface 。一个 Annotation，可以带成员变量 且以无形参的方法来声明，其方法和返回值定义了成员变量的名字和类型。也可以设置默认值 default . 自定义的 Annotation 可以分为两类： 包含成员变量，可以接受更多的元数据，也称为元数据 Annotation。 没有成员包含成员变量，成为标记的 Annotation 。 2.元 Annotation元 Annotation 就是对注解进行注解，换句话说就是对自定义的注解补充一些信息。 1.@Retention只能用于修饰 Annotation 定义，也就是在自定义一个注解的时候修饰在 @interface 上方。Retention 指定被修饰的 Annotation 可以保留多长的时间，具体策略需要 指定 value 成员变量，有三种可选的时间长度策略。 RetentionPolicy.Class 记录在 class 文件中，即运行时，在 JVM 不可获取 Annotation。 RetentionPolicy.Runtime 可以在 运行的时候也获得，程序可以通过反射的获取该 Annotation。 RetentionPolicy.SOURCE 只保留在源代码中，编译的时候就直接丢弃。 2.@Target用于指定修饰的 Annotation 能用于修饰哪些程序元素，包含一个 value 变量，同样只能修饰一个 Annotation 定义。具体有以下策略 ElementType.ANNOTATION_TYPE，指定定义的 Annotation 只能修饰 Annotation。 ElementType.CONSTRUCTOR指定定义的 Annotation 只能修饰构造器 ElementType.FIELD指定定义的 Annotation 只能修饰 成员变量 ElementType.LOCAL_VARIABLE指定定义的 Annotation 只能修饰 局部变量 ElementType.METHOD指定修饰的 Annotation 只能修饰方法定义 ElementType.PACKAGE指定修饰的 Annotation 只能修饰包定义 ElementType.Type指定修饰的 Annotation 可以修饰类接口或者枚举定义 3.@Inherited指定修饰的 Annotation 具有继承性，则继承的类都具有默认定义的 Annotation。 3.提取 Annotation只有 使用 @Retention（RetentionPolicy.RUNTIME ）修饰，JVM 才会在 装载 class 的时候提取 Annotation ，因为注解可以修饰类，方法等，因此注解提取的信息是一个 AnnotationElement，这是所有程序元素的（class , Method , Constructor ） 的父接口。也可以通过 getAnnotation 等直接提取出 Annotation 信息。 4.编译时注解 Annotation前面说过注解信息的提取实在 JVM 装载 class 的时候提取的，因此 @Retention 的 参数就设置为 RetentionPolicy.RUNTIME ，但是这多少对 JVM 的性能有所消耗，那有什么优化的方法吗？答案就是使用 编译时处理 Annotation 技术，Annotation Processing Tool 简称 APT。 APT 的原理就是通过继承 继承 AbstractProcessor 类实现一个 APT 工具，并装在到编译类库中，编译的时候就会使用 APT 工具处理 Annotation， 可以根据源文件中的 Annotation 生成额外的源文件和其他文件，APT 还会编译生成的代码文件和原来的源文件将他们一起生成 class 文件，这些附属文件的内容也都与源代码的相关。而对注解的信息的处理通常就放在生成的文件中，在运行时就不用再提取，直接关联并执行处理即可。 三.ButterKnife下面以 findViewById 和 setOnClickListener 对应的 @BindView 和 @ OnClick 为例简单介绍 ButterKnife 宏观实现。 1.定义注解在 ButterKnife 源码中 butterknife-annotations 库主要用来存放自定义注解。可注解的类型如图所示： @BindView 的注解：123456789101112/** * Bind a field to the view for the specified ID. The view will automatically be cast to the field * type. * &lt;pre&gt;&lt;code&gt; * &#123;@literal @&#125;BindView(R.id.title) TextView title; * &lt;/code&gt;&lt;/pre&gt; */@Retention(RUNTIME) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; BindView 有两个注解修饰，从前面的关于注解的知识就可以知道 @Retention(RUNTIME) 表示在保留注解信息到运行的时候， @Target(FIELD) 表示这个注解只能修饰成员变量。 @OnClick 的注解12345678910111213141516171819202122232425262728/** * Bind a method to an &#123;@link OnClickListener OnClickListener&#125; on the view for each ID specified. * &lt;pre&gt;&lt;code&gt; * &#123;@literal @&#125;OnClick(R.id.example) void onClick() &#123; * Toast.makeText(this, &quot;Clicked!&quot;, Toast.LENGTH_SHORT).show(); * &#125; * &lt;/code&gt;&lt;/pre&gt; * Any number of parameters from * &#123;@link OnClickListener#onClick(android.view.View) onClick&#125; may be used on the * method. * * @see OnClickListener */@Target(METHOD)@Retention(RUNTIME)@ListenerClass( targetType = &quot;android.view.View&quot;, setter = &quot;setOnClickListener&quot;, type = &quot;butterknife.internal.DebouncingOnClickListener&quot;, method = @ListenerMethod( name = &quot;doClick&quot;, parameters = &quot;android.view.View&quot; ))public @interface OnClick &#123; /** View IDs to which the method will be bound. */ @IdRes int[] value() default &#123; View.NO_ID &#125;;&#125; BindView 有三个注解修饰， @Retention(RUNTIME) 表示在保留注解信息到运行的时候， @Target(METHOD) 表示这个注解只能方法，@ListenerClass 就是对方法进一步描述，比如调用者类型 targetType，调用方法 setter，方法监听 type，最后执行的方法和方法参数 name ，parameters。 2.注解处理器ButterKnifeProcessor 注解处理器是 APT 中对注解处理的关键类，在 ButterKnife 中注解处理器位于 butterknife - compiler 包中。 ButterKnifeProcessor 继承自 AbstractProcessor ，而 AbstractProcessor 实现了 Processor 接口，这个接口主要有两个重要的方法。 1234567891011public interface Processor &#123; ... void init(ProcessingEnvironment processingEnv); ... boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv); ...&#125; init 方法 ： 12345678910111213141516171819202122232425@Override public synchronized void init(ProcessingEnvironment env) &#123; super.init(env); String sdk = env.getOptions().get(OPTION_SDK_INT); if (sdk != null) &#123; try &#123; this.sdk = Integer.parseInt(sdk); &#125; catch (NumberFormatException e) &#123; env.getMessager() .printMessage(Kind.WARNING, &quot;Unable to parse supplied minSdk option &apos;&quot; + sdk + &quot;&apos;. Falling back to API 1 support.&quot;); &#125; &#125; debuggable = !&quot;false&quot;.equals(env.getOptions().get(OPTION_DEBUGGABLE)); useAndroidX = hasAndroidX(env.getElementUtils()); typeUtils = env.getTypeUtils(); filer = env.getFiler(); try &#123; trees = Trees.instance(processingEnv); &#125; catch (IllegalArgumentException ignored) &#123; &#125; &#125; 这个方法主要的作用是： 获取java SDK 的版本 获取 ElementUtils，用于处理 Element ，Element 就是 Java 中的包，类等元素。 获取 TypeUtils，用于处理 javaType,Type 就是 java 的类型元素，比如有原始类型（普通的类型），参数化类型（比如List），数组类型，原生类型（int ,long） 等。 获取 Filer ，用于最后生成相关的文件。 process 方法： 1234567891011121314151617@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk, debuggable, useAndroidX); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage()); &#125; &#125; return false; &#125; 在 brewJava 方法中 有如下代码： 1234567891011121314151617181920static Builder newBuilder(TypeElement enclosingElement) &#123; TypeMirror typeMirror = enclosingElement.asType(); boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE); boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE); boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE); TypeName targetType = TypeName.get(typeMirror); if (targetType instanceof ParameterizedTypeName) &#123; targetType = ((ParameterizedTypeName) targetType).rawType; &#125; String packageName = getPackage(enclosingElement).getQualifiedName().toString(); String className = enclosingElement.getQualifiedName().toString().substring( packageName.length() + 1).replace(&apos;.&apos;, &apos;$&apos;); ClassName bindingClassName = ClassName.get(packageName, className + &quot;_ViewBinding&quot;); //注意这段命名 boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL); return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog); &#125; 对于 process 方法，主要做了如下几件事： 调用 findAndParseTargets ，扫描所有的 ButterKnife 注解。 调用 brewJava 生成 JavaFile。 最后生成一个 对应的 class 文件。这个class 文件名可以在 brewJava 的方法中可以看到，对应着 bindingClassName ，所以最后生成的 class 名字就为 xxxx_ViewBinding. 为了验证，在 MainActicity 中使用 ButterKnife 注解，然后运行一下，最后可以在 build-intermediates-classes 下找到对应的 MainActivity_ViewBinding。 2.绑定 bind 方法在经过前面两个步骤后，对于 ButterKnife 的使用也就是一句 bind 方法。 1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; 直接看 bing 方法的具体实现 12345@NonNull @UiThread public static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView); &#125; 对于 bind 方法，首先就是获取 目前 Window 的一个 根视图 DecorView ，这里可以比较一下 findViewById 的实现中有这么一段 123public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback); &#125; 通过比较就可以看出，对于注解来说最后的实现还是一样的。下面接着看 createBinding 1234567891011private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); try &#123; return constructor.newInstance(target, source); &#125; catch ... &#125; 在这里 会先去获取一个对象的构造器 ，然后调用这个构造器去实例化一个对象 。获取构造器的方法对应着 findBindingConstructorForClass1234567891011121314private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls); String clsName = cls.getName(); try &#123; Class&lt;?&gt; bindingClass = Class.forName(clsName + &quot;_ViewBinding&quot;); bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); ... BINDINGS.put(cls, bindingCtor); return bindingCtor;&#125;&#125; 在这个方法中，可以看到这个构造器的类就是以 ++clsName + “_ViewBinding”++，为名字的，以 MainActivity 为例就是对应着前面的 MainActivity_ViewBinding 。 最后是通过构造器的 newInstance(target, source) 方法创建了一个对象，并将 Context 对象（target） 和 DecorView (source) 传过去。 以 @BindView 和 @OnClick 为例，最后看生成的 MainActivity_ViewBinding 类。1234567891011121314151617181920212223242526272829303132public class MainActivity_ViewBinding&lt;T extends MainActivity&gt; implements Unbinder &#123; protected T target; private View view2131165218; @UiThread public MainActivity_ViewBinding(final T target, View source) &#123; this.target = target; View view = Utils.findRequiredView(source, 2131165218, &quot;field &apos;mButtonOne&apos; and method &apos;click&apos;&quot;); target.mButtonOne = (Button)Utils.castView(view, 2131165218, &quot;field &apos;mButtonOne&apos;&quot;, Button.class); this.view2131165218 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123; public void doClick(View p0) &#123; target.click(); &#125; &#125;); target.mButtonTwo = (Button)Utils.findRequiredViewAsType(source, 2131165219, &quot;field &apos;mButtonTwo&apos;&quot;, Button.class); &#125; @CallSuper public void unbind() &#123; T target = this.target; if(target == null) &#123; throw new IllegalStateException(&quot;Bindings already cleared.&quot;); &#125; else &#123; target.mButtonOne = null; target.mButtonTwo = null; this.view2131165218.setOnClickListener((OnClickListener)null); this.view2131165218 = null; this.target = null; &#125; &#125;&#125; 到这里就很清楚了，所有的 findViewById 和 setOnClickListener 等操作最后都是在这里实现了。 所有的参数都是从构造器里传进来的，进行绑定。 ButterKnife 实现的大致流程： 自定义注解 实现注解处理器 使用注解进行标记，在编译的时候通过注解处理器生成对应的 xx_ViewBinding 类 运行的时候，调用 bind 进行绑定，通过反射获取 对应的 xx_ViewBind 类的构造器，将 Context 对象和 DecorView 传递。 在 xx_ViewBinding 实现类似于 findViewId 或者 setOnClickListener 等方法。 总的来说，ButterKnife 在注解的处理上使用的是 注解处理器，在编译的时候将注解处理好，从而减少运行的时候对虚拟机性能的消耗。 最后为了更好地理解整个过程，通过学习 使用编译时注解简单实现类似 ButterKnife 的效果 Android 进阶 教你打造 Android 中的 IOC 框架 Android 打造编译时注解解析框架 用反射和编译时注解连两种不同的方式简单的实现了相同的效果。 github 地址]]></content>
      <tags>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片加载与图片加载框架 Glide]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6-Glide%2F</url>
    <content type="text"><![CDATA[一.前言在 Android 开发中经常会遇到的一个小功能就是加载图片，然后显示在我们指定的 View 上，我们知道对于 Android 应用程序，显示图片的 View 不会太大，而图片则有不同的大小，况且应用程序的也都有一定的内存限制，如果不对图片进行一定的处理，当加载大量图片的时候很容易就 产生 OOM,因此对图片进行压缩达到需要显示的大小左右，在视觉上的差别不会太大，但是可以节约大量的内存空间。 二.图片加载1.加载大图片BitmapFactory 提供了多个对图片的解析方法解析方法，这些方法会参与已经构建的 bitmap 对象分配内存，如果没有对图片进行处理，Bitmap 占用的内存就会非常大，这时就容易导致 OOM。 压缩方法：通过将 BitmapFactory.Options 参数的 inJustDecodeBounds 属性设置为 true 就可以让解析方法禁止为 bitmap 分配内存，这是 bitmap 对象就为 null, 但是 Option 对象中的 Width Height ，outMineType 属性都会被赋值，这就可以在加载图片的时候就获取图片的长宽，和 MIME 类型 根据显示大小和 图片大小计算 压缩比例 inSampleSIze 压缩步骤： inJustDecodeBounds 属性设为 false 计算图片大小 根据显示大小和 图片大小计算 压缩比例 inSampleSIze 设为 true 解析图片 ，返回 Bitmap 。 2.图片的存储在 Android 手机中图片的存储一般为有两种方式，内存和外存 （比如 SD 卡） 内存：每个应用程序在运行的时候会申请属于自己一段内存区域，对内存区域的读写相对的比外存要快得多，应用程序在退出后就会回收内存空间，即在内存中保存 Bitmap 并不是一种持久的保存。 外存：图片的外存一般是以文件的形式存在，因此读取和写入就涉及一些 IO 操作，速度没有内存块，但是是一种持久的数据保存。 3.图片缓存为了避免重复的去从网络，文件加载图片，内存缓存可以对图片进行缓存，从内存缓存中读取图片要快得多，核心类是 LruCache ，内存缓存支持一种最少使用算法，算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。通过这样就可以提高内存缓存的效率。 4.基本流程实际上对于所有的图片加载的框架都有一个固定的流程，只不过在具体的模块上不同的框架有不同的处理或者优化过程而已，下面就是图片加载框架一个十分抽象的流程模型。 二.Glide1.简介Glide 是 Bump Technologies 在 2013 年创建的开源项目，目前已经更新到 4.x 版本，实际上在 3.x 版本的时候就已经很成熟了，本篇基于3.x 版本的源码。Glide 是 Google 基于 Picasso 开发，优化的，因此这两个框架有很多相识的地方。因为 Glide 具有加载速度快和内存开销小等优点，更加适合移动系统， 所以这也是 Google 推荐使用的图片处理框架。 2.原理关于 Glide 的使用因其易用性，且已经有很多参考资料这里就不再赘述，下面着重于 Glide 的几个优点并结合源码进行说明。 (1)生命周期的管理Glide 和其他图片加载框架一个不同的地方就是具有对加载生命周期的管理，通常是结合 Activity 和 Fragment 的生命周期，实现加载过程跟随其生命周期的开始而开始，销毁而销毁，做到对资源的及时释放同时也降低的对内存的占用，避免和内存泄露的风险。 具体从 with 方法开始： 12345678910111213141516171819202122232425public static RequestManager with(Context context) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(context); &#125; public static RequestManager with(Activity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity); &#125; public static RequestManager with(FragmentActivity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity); &#125; @TargetApi(Build.VERSION_CODES.HONEYCOMB) public static RequestManager with(android.app.Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment); &#125; public static RequestManager with(Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment); &#125; 这里有很多重载的方法，主要是对两类 Context 进行不同的处理 Application Context,如果是 Application 那么 图片加载的生命周期和应用程序一样，所以不推荐直接使用 Application Context 。 非 Application Context，向当前的 Activity 创建一个 隐藏的 Fragment ,绑定 图片加载的生命周期，这样和在 Activity 中 Fragments的生命周期是一样的。 下面以 Activity 为例12345678910111213public RequestManager get(Activity activity) &#123; if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; return get(activity.getApplicationContext()); &#125; else &#123; //判断activity是否已经是销毁状态 assertNotDestroyed(activity); //获取FragmentManager 对象 android.app.FragmentManager fm = activity.getFragmentManager(); //进行生命周期的绑定 return fragmentGet(activity, fm); &#125; &#125; 具体接着看 fragmentGet 12345678@TargetApi(Build.VERSION_CODES.HONEYCOMB)RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; //获取RequestManagerFragment 这就具体绑定的 Fragment RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); ... return requestManager;&#125; 在 RequestManagerFragment 的具体实现中就是 123456789101112131415161718192021222324public class RequestManagerFragment extends Fragment &#123; private final ActivityFragmentLifecycle lifecycle; // Glide 生命周期的管理 //... @Override public void onStart() &#123; super.onStart(); //关联 lifecycle 相应 onStart 方法 lifecycle.onStart(); &#125; @Override public void onStop() &#123; super.onStop(); //关联 lifecycle 相应 onStop 方法 lifecycle.onStop(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); //关联 lifecycle 相应 onDestroy 方法 lifecycle.onDestroy(); &#125;&#125; 总结：可以看到对于 Glide 生命周期的管理，就是在 with 方法将 Context 类型的对象传进来的时候，根据不同的 Context 绑定其生命周期，比如 Activity 的就是在 Activity 上 创建一个隐形的 Fragment ,因为 Fragment 的生命周期是由 Activity 管理的，所以将 Glide 的回调接口与 Fragment 的进行绑定，也就间接形成了 Activity 的绑定。 (2)高效的缓存策略Glide 有着高效的缓存策略，这使得 Glide 在运行起来相对的流畅，而且不会占用大量的内存。图片加载一般会有两种缓存，一是内存缓存，二是本地缓存，而 Glide 还对增加了一个 Bitmap 对象缓存。 1.内存缓存内存缓存的主要作用是防止应用重复将图片数据读取到内存当中。内存缓存的核心类就是 LruCache，而且使用近期最少使用算法，这个算法的核心就是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 // load 方法public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; ... //得到图片的 key EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); //从内存中获取缓存图片 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; //不为 null 显示图片 cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key); &#125; return null; &#125; //从 弱引用的缓存中去除 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; //不为 null 显示图片 cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key); &#125; return null; &#125; //没有就从网络上或者文件中加载图片 EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key); &#125; return new LoadStatus(cb, current); &#125; EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(&quot;Started new load&quot;, startTime, key); &#125; return new LoadStatus(cb, engineJob); &#125; 我们都知道 Glide 的图片加载是从 load 方法开始的，最终会到 Engine 的 load 去实现真正的内存缓存。可以看到关于内存缓存的方法有两个就是 loadFromCache，保存图片的是 LruCache 内部就是一个前引用的 loadFromActiveResources, 保存图片的是 activeResources ，一个弱引用的 HashMap 。 下面看具体的方法和两者的关系 123456789101112131415161718192021222324252627282930313233343536373839404142private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached; &#125; private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; Resource&lt;?&gt; cached = cache.remove(key); final EngineResource result; if (cached == null) &#123; result = null; &#125; else if (cached instanceof EngineResource) &#123; result = (EngineResource) cached; &#125; else &#123; result = new EngineResource(cached, true /*isCacheable*/); &#125; return result; &#125; private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123; if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; active = null; //注意这里是弱引用 WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key); if (activeRef != null) &#123; active = activeRef.get(); if (active != null) &#123; active.acquire(); &#125; else &#123; activeResources.remove(key); &#125; &#125; return active; &#125; 可以看到在 loadFromCache 中首先会去从 LruResourceCache 中获取到缓存图片之后会将它从缓存中移除，然后添加到 activeResources 当中一个弱引用的 HashMap，用来缓存正在使用中的图片。可能你会觉得直接取出来不久行了，为什么要多此一举？实际上要采用的这样的方式是因为 LruCache 内部是一个强引用的，而对于 activeResources 是一个弱引用的队列。一张图片在使用的时候被回收的概率非常小，因此使用弱引用可以避免正在使用的图片过多而造成内存溢出。 上面是读取的操作，写入的时候就把在使用的图片就放到 activeResources 弱引用缓存当中，如果图片不再使用就将缓存图片从 activeResources 中移除，然后再将它 put 到 LruResourceCache 当中。 2.本地缓存本地缓存也叫硬盘缓存，主要作用是防止应用重复从网络或其他地方重复下载和读取数据。在 3.x 版本的 Glide 中，本地缓存可以有四个设置参数 NONE，表示不缓存任何内容 SOURCE，表示只缓存原始图片 RESULT，表示只缓存转换过后的图片（默认选项） ALL， 表示既缓存原始图片，也缓存转换过后的图片 而在 4.x 版本中又增加了一个可以根据图片的资源智能地选择一个加载的策略。 在硬盘缓存读取的过程中，如果是缓存原始的图片，也就是没有经过目标View .就先进行转换解码再返回，如果是已经根据目标 View 转换过的就直接将数据解码返回。 本地缓存实际上就是将图片进行压缩然后以文件的形式存储，Glide 默认使用应用的私有路径，当然也可以更改为其他指定的路径。 3.Bitmap 对象池Bitmap 对象是在图片处理的过程中经常见到的对象，之前也说过这个对象十分的消耗内存，而且相对于图片加载这个场景需要对图片频繁的使用/收回（就是显示与不显示），就需要对这些对象进行一个缓存。Glide 对 Bitmap 也 使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能。12345678910111213141516171819202122public interface BitmapPool &#123; long getMaxSize(); void setSizeMultiplier(float sizeMultiplier); void put(Bitmap bitmap); Bitmap get(int width, int height, Bitmap.Config config); void clearMemory(); void trimMemory(int level);&#125; 上面就是一个 Bitmap 对象池定义的接口12345678910111213141516171819202122232425@Override @NonNull public Bitmap get(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result != null) &#123; // Bitmaps in the pool contain random data that in some cases must be cleared for an image // to be rendered correctly. we shouldn&apos;t force all consumers to independently erase the // contents individually, so we do so here. See issue #131. result.eraseColor(Color.TRANSPARENT); &#125; else &#123; result = createBitmap(width, height, config); &#125; return result; &#125; @NonNull @Override public Bitmap getDirty(int width, int height, Bitmap.Config config) &#123; Bitmap result = getDirtyOrNull(width, height, config); if (result == null) &#123; result = createBitmap(width, height, config); &#125; return result; &#125; 可以看到当需要一个 Bitmap 对象的时候，会根据图片的这些参数，从 Bitmap 池里找到一个合适的 Bitmap 对象，如果没有就重新创建一个。BitmapPool 也会根据 LRU 算法和缓存池的尺寸来释放一些老旧资源。从而达到性能的最优。 通过这种方式可以以最小的内存开销达到较高的性能，而且有效的降低的内存抖动，即在短时间内频繁的分配大量的内存。因此也降低了系统回收的频率。]]></content>
      <tags>
        <tag>Android 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式----观察者模式在 Android 中的影子]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8-Android-%E4%B8%AD%E7%9A%84%E5%BD%B1%E5%AD%90%2F</url>
    <content type="text"><![CDATA[一.简介观察者模式的实现就是有两个角色，一个是观察者( 比如有观察者 a, b , c )，一个是被观察者(比如有被观察者 d ),他们之间存在这样的一种关系，被观察者一旦某些状态改变，就会通知观察者甚至引起被观察者的一些行为的产生。比如 前面说的 a , b , c 他们观察这 d 的 大小写变化，一旦 d 变成了 D ,就会通知 被观察者 a, b, c , 而被观察者就可以因此得知 d 的改变，也可以因此产生一些行为比如 自己也变大写。 《Android 源码设计模式》中的定义是：定义对象一种一对多的依赖关系，使得每当一个对象改变状态，则所有的依赖于它的对象会得到通知并自动更新,通常为一种发布 –订阅的系统。 二.使用场景 1.关联行为场景，这种行为是可以拆分的，比如上文的大小写的行为。 2.事件多级触发，比如 a ,b , c, 按顺序触发变成大写的操作。 3.跨系统的消息交换场景，消息队列，事件总线 EventBus 等，比如 Android 中的广播机制。 三.在 Java 中的实现例子 Observer ，观察者，在 Java 9 后废弃 Observable ，被观察者 ，在Java 9 后废弃 虽然上面两个 接口已经废弃但是这并不影响体会 观察者模式的应用，因为这并不是观察者模式的一种唯一写法。实际上，作为一种设计模式，精华的其设计思想而不是实现细节。 123456789101112131415161718192021222324252627282930313233343536373839404142//码农是观察者，观察一些 IT 信息public class CoderObserver implements Observer &#123; public String name; public CoderObserver(String name) &#123; this.name = name; &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println(name+&quot;更新&quot;+arg); &#125; @Override public String toString() &#123; return &quot;码农&quot;+name; &#125;&#125;//IT 信息是被观察者，一旦有信息就会通知观察者public class MessageObservable extends Observable &#123; public void postMessage(String content) &#123; setChanged(); notifyObservers(content); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; MessageObservable messageObservable = new MessageObservable(); CoderObserver coderObserver = new CoderObserver(&quot;No0&quot;); CoderObserver coderObserver1 = new CoderObserver(&quot;No1&quot;); CoderObserver coderObserver2 = new CoderObserver(&quot;No2&quot;); messageObservable.addObserver(coderObserver); messageObservable.addObserver(coderObserver1); messageObservable.addObserver(coderObserver2); messageObservable.postMessage(&quot;新的消息发布&quot;); &#125;&#125; 执行结果 1234No2更新新的消息发布No1更新新的消息发布No0更新新的消息发布 四.Android 中的体现观察模式在 Android 中是一种常见的设计模式。 ListView/RecycklerView 中 的 Adapter， 对于 notifyDataSetChanged 这个方法每次调用都会通知各个item 刷新数据。就是一个观察者模式，其中数据是一个被观察者，每个 item 就是一个观察者。 广播的发布和广播接收者的接收 也是一个观察者模式的体现，或者说成一种订阅-发布更加合适，每一个订阅者订阅自己想要的广播，每一个广播都是一个发布者，且通过系统进行中转/转发，从而实现了观察者这种模式，因为这种信息的传递时跨进程的，因此称这种方式为跨系统的消息交换场景。详见Android 广播的流程 观察者一些重要的实践在于一些开源的框架，EventBus ，Otto 等，简化了组件之间的交互，从而降低了耦合。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式----单例模式的实现以及实现原理]]></title>
    <url>%2F2018%2F08%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一.简介单例模式是一个十分常见的设计模式，一个对象实例如果在创建的过程十分消耗资源，且整个 app 系统只需要拥有一个对象的时候，就可以使用单例模式，在单例模式下，一个类只有一个实例并且在实例化后可以向系统的各个地方提供这个实例，不再创建新的实例。 二.面对的问题单例模式的实现关键就是确保这个类在整个系统运行过程中有且只有一个实例，因为在 Android 系统中存在者多线程，序列化等情况，在这些情况下很容易产生类多次实例化的情况，因此在实现单例模式的时候就需要特别注意这个问题。 实现单例模式的关键点 构造函数不对外开放，即为 private 而不是 public 通过一个静态方法或者枚举类型返回单例对象 确保在多线程的环境下确保有且只有一个对象 确保在反序列化的时候不会重新构建新的对象 三.实现方式1.非懒加载模式 (线程安全)12345678910111213141516 /** * 非懒加载模式 */private Singleton() &#123; &#125; private static final Singleton instance = new Singleton(); public static Singleton getInstance() &#123; return instance; &#125; private Object readResolve() throws ObjectStreamException&#123; return instance; &#125; 由于 instance 在类初始化过程已经被赋值且是 final 修饰，因此就不存在线程安全的问题，但是这种情况不管这个单例有没有使用都会对 instance 进行初始化。序列化问题则通过添加 readResolve 方法解决，通过在这个返回 instance 本身就可以保证在反序列化的时候是同一个实例。 2.懒汉模式 （粗暴地解决线程同步问题）懒汉模式就是声明一个静态的变量，在获取的时候对方法进行同步，并且在第一次调用的时候进行初始化。 1234567891011121314/** * 懒汉模式 */private static Singleton instance;private Singleton() &#123;&#125;public static synchronized Singleton getInstance()&#123; if (instance==null)&#123; instance = new Singleton(); &#125; return instance;&#125; 这种方式每次调用的时候都进行同步，因此在不涉及线程安全的情况时，进行同步就多余了。而对于序列化的解决和第一种方式一样。 3.双检测锁模式 Double Check Lock ，DCL (不是很优雅的优化线程同步问题)123456789101112131415161718/** * DCL 模式 */ private static volatile Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 首先看到代码中通过两次检测 instance 是否为 null，第一次 来避免不必要的同步，而第二次检测时为了尽量保证线程同步，之所以说是尽量使因为这种情况还不能绝对地保证线程同步。 理解上面这句话首先要明白在程序运行的时候， instance = new Singleton();这句代码会被编译器编译成多条指令，CPU 每次执行时只能执行一条指令，这些指令大致完成 3 件事; 1.给实例分配内存 2.调用构造函数，初始化成员字段 3.将 1 中内存空间的地址赋值给 instance，经过 3 后 instance 才不为 null 但是由于虚拟机的原因实际上上面的指令不一定是 1-&gt;2-&gt;3, 有可能是 1—&gt;3-&gt;2.因此就产生了一个问题: 首先 线程 A 获得对象锁后，执行到 instance = new Singleton(),这时如果 3 先执行，还未执行 2 的时候,即 instance 已经不为 null, 但是还未初始化。 接着线程 B 进入方法，在进行第一个 null 判断（在同步代码块外面），instance 不为 null, 所有直接返回，但是实际上 instance 还未初始化，所以可能出错。 在 JDK1.5 引入了 volatile 后就可以解决这个，因为volatile 声明的变量禁止了指令的重新排序，所以就不存在上述的问题。 而对于序列化的解决和第一种方式一样。 4.静态内部类模式(线程安全)123456789101112131415/** * 静态内部类模式 */private Singleton() &#123;&#125;public static Singleton getInstance()&#123; return SingleHolder.instance;&#125;private static class SingleHolder&#123; private static final Singleton instance = new Singleton();&#125; 这种实现方式实际上就是对第一种方式的优化，解决了不能懒加载的问题。对于静态内部类，并不是在外部类加载的就进行初始化，而是在使用到的时候才进行类加载，因此将 instance 放在静态内部类中，只在第一次调用 getInstance 的时候才会进行初始化，解决了线程同步问题且实现了懒加载。 而对于序列化的解决和第一种方式一样。 5.单元素枚举单例（最佳）因为枚举类的实例实际上都是线程安全的，且在序列化的过程中也都是同一个对象，不用像前面一样添加方法，因此可以说枚举单例是在任何情况下都只有一个对象。 1234567891011 /** * 单元素枚举模式 */public enum SingleEnum &#123; INSTANCE ; /** * doSomething */ &#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM----编译优化]]></title>
    <url>%2F2018%2F08%2F12%2FJVM-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一.简介Java 语言的编译期大致可以分为三种： 前端编译器，把.java 文件编译成class 文件 后端运行期编译器 JIT 编译器，把字节码转变为机器码的过程 静态提前编译器 AOT ，直接把 .java 文件编译成 机器码 不同的编译时期，为了提高代码的运行效率，JVM 会进行一定的编译优化。 二.早期优化早期编译主要是第一种编译，即把 .java 文件编译成 class 文件，这个过程的编译可以分为三个部分; 解析与填充符号表. 插入式注解处理器的注解处理过程. 分析与字节码生成过程 1.解析与填充符号表解析分为词法解析，和语法解析 (1).词法解析将源代码中的字符流转变为标记集合，一个标记就是一个关键字，变量名，字面量，或者运算符. 比如1int a = 1 + b; 这部分的标记集合的元素就是：int , a , = ,1 , + ,b (2).语法分析将标记集合构造成抽象语法树的过程，抽象语法树就是程序代码语法结构的树形表示，每个节点都是一种语法的结构。 (3)填充符号表符号表，是一组符号地址和符号信息构成的表格. 2.插入式注解处理器的注解处理过程注解处理器可以读取，修改，添加抽象语法树种的任何元素，如果修改了编译器就回到解析过程重新开始处理直到没有注解处理器对语法树进行修改，每次循环称为一个 Round,通过注解处理器就可以干涉编译器的行为. 3.分析与字节码生成过程分析主要是程序的语义分析，对抽象语法树中进行上下文性质的审查，如类型审查等。包括下面三种; 标注检查 数据及控制流分析 解语法糖 (1)标注检查检查变量是否被声明，赋值之间的数据类型等，还有变量折叠 比如 int a = 1 + 2 ; 就会折叠成 int a = 3; (2)数据及控制流分析对程序上下文逻辑进行更进一步的验证，使用前是否赋值，方法是否有返回值等. (3)解语法糖语法糖，也称糖衣语法.语法糖虽然不会提供实际性的功能改进，但是可以提高效率，提升语法的严谨性，减少编码出错的机会.虚拟机运行时不支持这些语法在编译阶段会还原简单的基础语法结构，并在相应的地方插入强制类型转换.Java 中的语法糖常见的有泛型，集合的遍历，变长参数，自动装箱和拆箱，条件编译等。 泛型，java 语言中泛型实现方法称为类型擦除，这种泛型称为伪泛型，因此对于 List 和 List 是同一个类。 自动装箱拆箱，转换为对应的包装方法和还原方法。 遍历循环，则把代码还原成了迭代器的实现。 条件编译，对于 if while 等条件分支中不成立的代码块消除掉。 (4)字节码生成这一步就是把前面的步骤生成的信息转化为字节码写到磁盘中并进行少量的代码添加和转换工作，比如实力构造器 和类构造器 三.晚期优化晚期优化主要是对一些热点代码进行优化。当虚拟机发现某个方法或代码块运行特别频繁时就会把这些代码认定为热点代码。在运行时候虚拟机会将这些代码编译成与本地平台相关的机器码，这个编译器叫即时编译器。而对于之前的一般的编译是通过解释器进行解释执行。两个各有区别，但也会相互配合工作。 1.解释器和即时编译器当程序需要迅速启动和执行的时候，解释器可以省去编译时间，立即执行，解释执行可以节约内存。在程序运行的时候，编译器可以把越来越多的代码编译成本地代码，提高执行效率。 解释器和编译器可以配合工作，可以从解释器转到即时编译器，也可以从编译器逆优化到解释器。程序的执行一般先是解释器执行编译，在某些情况下解释器可启动即时编译器来进行一些优化编译，通常会为即时编译设置一个“逃生门”，这个逃生门的作用就是一旦一些优化不可执行编译的时候，即时编可以退回到解释器编译器，也叫逆优化。 1.即时编译器即时编译器 （JIT 编译器），可以分为 Client 编译器和 Server 编译器，简称 C1 编译器和 C2 编译器。JVM 会根据不同的平台选取不同的编译器，以实现效率的提高。 2.分层编译为了让解释器和即时编译器能够实现效率最大化，一般将代码分为几个层次进行编译。 第 0 层，程序解释执行。 第 1 层 C1 编译将字节码编译为本地代码，进行简单的优化。 第 2 层或以上 称 C2 编译，将字节码编译为 本地代码，会启用一些编译时较长的优化。 3.热点代码热点代码通常由两种; 被多次调用的方法,编译时以整个方法做为编译对象，属于 JIT 编译方式。 被多次执行的循环体，以循环体所在方法为对象，因为发生在方法中，所以称为栈上替换编译，OSP 编译。 判断是否为热点代码也有两种方式： 基于采样的热点探测，周期性检查各个线程的栈顶 基于计数器热点探测，使用方法调用计数器和回边计数器，当超过一定值时就出发 JIT 编译。 方法调用计数器，计数不是方法调用的绝对值，而是一段时间中的次数，且这个次数没有超过阈值的时候会衰减。 回边计数器（循环体执行次数），计数的是执行的绝对次数。 这个是否进行热点代码优化判断过程如图： 提交编译请求后，解释方式会继续执行，而编译器的执行会在一个子线程中进行。 对于 C1，编译的过程可分为三个阶段： 第一阶段，将字节码狗造成高级中间代码 HIR,以静态分配的形式存在 SSA,进行一个方法内联，常量传播优化。 第二阶段，从 HIR 产生低级中间代码 LIR。 最后使用线性算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，后产生机器代码。 2.编译优化对于这部分的优化实际上有很多方式，经典的有有如下几种： (1).公共子表达式消除如果一个表达式 A 已经计算过了，并且从先前的计算到现在的 A 中所有的变量的值都没有变化，那么这个 A 就可以成为子表达式。比如; 12345int a = b * c + (3 + b * c );//优化int a = A + (3 + A);//优化int a = 2 * A + 3; (2)数组边界检查消除当访问一个数组的时候，经常会对数组的边界进行检查。而可以采取的优化就是在数据流分析时确定对数组的访问不会超过 数组范围就不再每次进行数组越界检查。 (3)方法内联就是将一些没用的代码剔除，或者对于没有必要的方法跳转，将目标方法中的代码 “复制”到发起调用的方法之中，避免真实的方法调用。因为 Java 中的多态性的存在因此，内联有时不能确定目标方法，对应的情况如下： 如果是非虚方法，直接进行内联。 如果是虚方法 只有一个版本，进行守护内联属于激进优化，要设置”逃生门“，没有变化时继续内联，若是加载了一个有变化的新类就直接抛弃退回解释执行。 如果有多个版本，就做内联缓存，在未发生内联的时候，缓存为空，第一次调用方法时，记录方法的调用者，后面每次调用就进行判断，一致就继续进行，不一致就取消内联。 (3).逃逸分析分析对象的动态作用域，当一个对象在方法中被定义后可能被外部方法所引用，例如传参，这称为方法逃逸，还有被其他线程访问的线程逃逸。 如果一个对象不会逃逸那么可以进行如下优化; 栈上分配,在栈上分配内存. 同步消除,消除没有必要的线程同步。 标量替换，标量是指一个数据不能再分解，比如数据类型，而聚合量就是由多个标量组成的，如果一个对象可以被分解，且不会逃逸，就直接使用标量代替对对象的成员变量，而不直接创建这个对象。]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM----执行子系统]]></title>
    <url>%2F2018%2F08%2F10%2FJVM-%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一.简介Java 虚拟机和字节码的存储格式是实现语言的平台无关性的基础，也就是说 Java 虚拟机并不是 Java 语言所特有的，虚拟机可以和任何能编译成 Class 文件的语言关联，因此只要遵循 Class 文件的语法和结构化的约束，就可以在 虚拟机上运行。 二.Class 文件1.简介不管是哪一种语言，Java 虚拟机最终执行的都是 “Class 文件”，任何一个 “Class 文件” 都对应着唯一一个类或者接口的定义的信息，这个” class 文件” 可以是编译器生成的，也可以是通过类加载器直接生成的。这里的双引号要表明的是 “Class 文件”并不一定是以常见文件的形式存在，因为一个类或者接口可以从类加载器生成，但是所有的类和接口最终都会在方法区保存。 2.文件结构Class 文件的中采用一种伪结构来存储数据，这种结构只有两种数据类型： 无符号数，用于代表基本的数据类型，可以描述数字，UTF-8 字符等，以 u1 ，u2 , u4 ，u8 代表 1 个字节，2 个字节，4 个字节， 8 个字节的无符号数。 表，由多个无符号数组成，或者由其他表构成的复合数据类型，常以 “_info” 结尾。 Class 文件的格式 123456789101112131415161718ClassFile &#123; u4 magic; //魔数，固定值 0xCAFEBABE u2 minor_version; //次版本号 u2 major_version; //主版本号 u2 constant_pool_count; //常量的个数 cp_info constant_pool[constant_pool_count-1]; //具体的常量池内容 u2 access_flags; //访问标识 u2 this_class; //当前类索引 u2 super_class; //父类索引 u2 interfaces_count; //接口的个数 u2 interfaces[interfaces_count]; //具体的接口内容 u2 fields_count; //字段的个数 field_info fields[fields_count]; //具体的字段内容 u2 methods_count; //方法的个数 method_info methods[methods_count]; //具体的方法内容 u2 attributes_count; //属性的个数 attribute_info attributes[attributes_count]; //具体的属性内容&#125; (1)魔数确定一个文件是否为一个能被虚拟机接受的 Class 文件。固定值是 0xCAFEBABE，CafeBabe 咖啡宝贝，Java 咖啡 … (2)主次版本号Java 的版本号。高版本的JDK 能向下兼容以前版本的 Class 文件。 (3)常量池常量池是 Class 文件中最重要的资源，占据的文件空间最大，长度不固定。主要存放两大类的常量，字面量，和符号引用。 字面量，通常一个类中引用的一些字符串，或者声明为final 的常量值。 符号引用，一个类中的方法或者字段都有一个对应的内存入口地址，但是 Class 文件并不会直接保存这些地址，而是在运行时通过符号引用去解析定位到具体的内存入口地址，因而 Java 就可以产生运行时类型等一些动态特性，符号引用主要有三种产量： 1.类和接口的全限定名，java.lang.Object 对应的全限定名为 java/lang/Object2.字段的简单名称和字段的描述符，简单名称就是名字，比如 int i ,那么简单名就是 i,字段的描述符就是描述字段的数据类型，通过一种简略的方式，比如 byte 就用 B 代替，char 就用 C 代替，对象类型就用 “L+classname +; ” ，数组类型就 “[+ 元素类型”3.方法的简单名称和方法的描述符，简单名同样是名字，比如 get(), 简单名就是 get ,方法的描述符就是方法的参数列表(数量、类型以及顺序)和返回值，比如 ++Object m(byte i, char d, Thread t) {..} ==&gt; BCLjava/lang/Thread;)Ljava/lang/Object;++ (4)访问标志用于识别一些类或者接口层次的访问信息，包括这个class 是类还是接口，是否有public , abstract ，final 等标识。 (5)类索引，父类索引，接口索引集合 类索引,确定这个类的全限定名 父类索引,确定父类的全限定名 接口索引集合,即接口的个数和具体的接口内容，描述实现了哪些接口 (6)字段表集合用于描述接口或者类中声明的变量，不包括从父类继承的，字段包括类变量和实例变量字段，所有的字段通过字段个数，和字段表集合表示，一个字段表的结构如下1234567field_info &#123; u2 access_flags; //访问标识 u2 name_index; //字段简单名索引， u2 descriptor_index; //字段描述描述符索引 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表的具体内容&#125; 访问标识，字段表确定的是字段有什么修饰，public ,private 等 字段简单名索引，字段描述描述符索引就是对常量池中字段的简单名和字段描述符的引用 属性（通过属性个数和属性表集合表示），包含字段的一些额外信息，比如 ConstantValue 属性就是赋予字段的初始值，没有就默认为 0 . (7)方法表集合用于描述接口或者类中声明的变量，不包括从父类继承的，字段包括类变量和实例变量1234567method_info &#123; u2 access_flags; //访问标识 u2 name_index; //方法简单名称索引 u2 descriptor_index; //方法描述符符索引 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表的具体内容&#125; 访问标识，字段表确定的是字段有什么修饰，public ,private 等 方法简单名索引，方法描述描述符索引就是对常量池中方法的简单名和方法描述符的引用 属性表，包含方法的一些额外信息，比如 Code 属性就是方法中代码的具体内容。Exceptions 属性是方法抛出的异常。 (8)属性表集合一个字段中有 ConstantValue 属性，一个方法中有 Code，Exceptions 等属性，同样在一个类或者接口中也有一些额外的信息。 三.类加载机制类加载机制就是 虚拟机把描述类或接口的数据从 Class 文件记载到内存，并对数据进行校验，转换解析和初始化最终形成可以被虚拟机直接使用的 Java 类型。有了类加载，在运行期间通过类型的动态加载和动态链接就可以实现了 Java 语言的动态扩展。 1.类加载的过程类加载包括七个阶段 类加载的过程并不是严格按照上面的顺序进行，有可能一个过程未全部完成就可以进入下一个过程，并且解析阶段能在初始化前也可能在初始化后，但是初始化的时候，加载验证准备是一定完成了的。 (1)加载 通过一个类的全限定名来获取这个类的二进制流，一个 “Class 文件”可以从多个渠道获取，不一定是编写的 Java 程序，通常由一下渠道： 从 zip ，jar, 等包读取 从网络获取 运行时计算生成，动态代理技术 由其他文件生成 从数据库中读取等 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.class 对象，作为方法区这个类的各种数据的访问接口，这个对象是存放在方法区的，不是 Java 堆。 对于数组，数组的元素是通过类加载器创建的，但是对于数组对象本身，是由虚拟机创建的。 (2)连接-验证class 文件可以从各个途径而来，因此仅仅靠编译器验证是不够的，大致的验证的类型有; 文件格式验证,检查 Class 文件格式的规范 元数据验证,主要检查类的继承关系，修饰等 字节码验证，检查程序语法，逻辑等。 符号引用验证，对类引用到的本类以外的信息进行匹配校验确保解析动作能够正常执行。 (3)连接-准备构造与这个类相关联的一个方法表，每个元素都是当前类和父类非私有实例方法的引用。 为类的静态变量分配内存并设置初始值的阶段，这些变量使用的内存都在方法区。对于 static 修饰的，初始化为 0 ，false ,null 等，而对于 static final 则可以初始化为 前面所说的字段表中的属性 ConstantValue ,也就是指定的初始值。12public static int i; 初始化为 0 public static final int j = 1; 初始为 1 ，1 存放在字段表中的 ConstantValue 属性。 (4)连接-解析解析阶段将常量池中的符号引用替换为直接引用的过程。符号引用是以一组符号来描述所引用的目标，就是前面说的类和接口，字段，方法的符号引用。直接引用是可以直接指向目标的指针。之前说过解析可能在初始化前也可能初始化后，就是因为对于一些需要呈现多态特性的类型比如重写方法，有可能在运行的时候才能确定其最终的目标类或者目标方法，这个过程就是通过解析完成的，将未确定的变为确定的。 1.类或接口解析 是数组类型，先加载数组元素的类型，然后虚拟机再生成一个数组对象 不是数组类型将需要解析的类的全限定名传递给当前类的类加载器去加载这个类 解析完成之前还需要进行符号引用验证确定是否有访问权限。 2.字段解析 先解析字段所属的类 先对字段所属的类进行查找，是否包含简单名称和字段描述匹配的字段 没有就从实现的接口按继承关系查找 没有就按继承关系从 父类查找 查找失败就抛出异常，查找成功就放回引用，对这个字段进行权限验证。 3.方法解析类方法解析 先解析方法所属的类 判断方法是不是类中方法，不是就抛出异常 在方法所属的类中查找 没有就从父类中查找 没有就从继承接口中查找，找到就证明这是一个抽象类，并抛出异常 查找失败同样抛出异常，成功就直接返回引用。 接口方法解析 先解析方法所属的接口 判断方法是不是接口方法，不是就抛出异常 在方法所属的接口中查找 没有就从父接口中查找 查找失败同样抛出异常，成功就直接返回引用。 (5)初始化初始化就是就职执行一些静态变量的赋值或者静态语句块中的语句，也就是 &lt; clinit &gt; 方法 “class init”。编译器会收集类变量赋值和静态语句块语句，按顺序执行，因此在这个过程中静态语句块但是可以对后定义 static 变量赋值,但是不能访问。 虚拟机保证子类的&lt; clinit &gt; 执行之前，父类的&lt; clinit &gt;已经执行 执行接口的 &lt; clinit &gt;不会执行父接口的&lt; clinit &gt;，接口的实现类也不会执行接口的 &lt; clinit &gt; 如果一个类或者接口没有静态语句块或者类变量赋值操作可以不生成 &lt; clinit &gt; 虚拟机保证 在多线程的环境下能被正确的加锁，同步 1234567public class Test&#123; static &#123; i = 0;//可以赋值 System.out.println(i); //不能访问 &#125; static int i = 1; &#125; 2.类加载器类加载器的作用就是通过一个类的全限定名，来获取描述此类的二进制字节流。 类加载器的种类 启动类加载器，负责加载lib 库中，或者指定路径中的类，启动类加载器无法被 java 程序直接应用。 扩展类加载器，负责加载lib/ext 或者指定的路径。 应用程序类加载器，系统类加载器，负责加载用户路径上指定的类库。 对于这三种类加载器的使用使用了双亲委派模式: 如果一个类加载器收到类加载的请求，首先不会尝试加载这个类，而是交给父类，如果父加载器无法完成，子加载器才会尝试自己加载. 类随着加载器一起具备了一种有优先级的层次关系，因此 Object 总是同一个类的加载器加载，因此在各个环境中都是同一个类. 对于同一个类的比较，只有在同一个类的加载器前提下才能讨论是不是同一个类。也就是两个类即使名字一样，来自同一个 Class 文件，只要是被不同的类加载器加载，那么这两个类就一定不相等。 四.执行子系统java 程序的执行实际上也就是一个个方法的执行过程，从 main 方法开始，运行，输出结果，对于虚拟机也是如此，Java 虚拟机的执行引擎就是输入字节码文件，处理字节码过程，输出执行的过程。方法的执行相关的数据结构就是虚拟机栈（或本地方法栈）。 1.运行时栈帧结构栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构是虚拟机栈的栈元素，方法的开始到执行完成都对应着一个栈帧的入栈和出栈。 局部变量表，用于存放方法参数和方法内部定义的局部变量，以变量槽（Slot）为单位,一个变量槽可以存放一个 32 位的数据类型，boolean ,byte，char 等。在方法执行的时候，虚拟机使用局部变量表完成参数值到参数变量表的传递。 操作数栈，是一个后入先出的结构，在方法执行的时候各种指令字节码会往这个操作数栈入栈或者出栈。 动态链接，每个栈帧包含了一个指向运行时常量池中该方法符号引用的引用，这个引用是为了方法调用的动态连接。一个符号引用在运行时被转换为直接引用，因此通过动态连接就可以找到具体的方法。 方法返回地址，当一个方法正常返回时有可能有或者返回值，返回地址可以是程序计数器的值。当有异常抛出的时候不会产生返回值，返回地址由异常处理器确定。 2.方法的调用方法调用的过程就是确定被调用方法的具体版本，因为 java 中存在着重写，重载，因此有可能在运行期间才能确定一个目标方法的直接引用。可以将方法的直接引用的确定划分为两个中情况：解析和分派。 解析，指的是在编译器就可以确定直接引用的方法，该方法在 java 程序中可以唯一确定，即不是重载，重写方法。 分派，可分为两种静态分派和动态分派 静态分派，对应重载方法，虽然是重载方法，但是该方法的直接引用可以根据传递的参数就直接确定目标方法，因此，对于重载方法，静态分派的过程实际也是在编译器就可以确定直接引用的方法的过程。 动态分配，对于重写的方法，因为对调用者进行类型判断，所以只有在方法执行的时候根据实际类型去确定方法的引用。 对于解析和静态指派也叫做静态绑定，而动态分配也叫动态绑定。 1.方法的指令在 Java 虚拟机中，一共有 5 条方法调用的字节码指令： 虚方法：除了静态方法，私有实例方法，实例构造器，父类方法，final 修饰的方法以外的方法称为虚方法。 2.解析只要能被 invokestatic，invokespecial 调用的方法都可以在解析过程中完成将符号引用解析为直接引用，除此之外还有被 final 修饰的方法，虽然 final 修饰的方法是通过 invokesvirtual 指令调用的，但是 final 方法不能被继承，因此也是可以唯一确定的。总的来说，解析过程的方法包括：静态方法，私有实例方法，实例构造器，super 父类方法 以及final 修饰的方法。 3.静态分派（确定重载方法） 重载即同一个类中或者子类中多个名字相同，但参数类型不同相同的方法 重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入的参数的声明的类型来选取重载方法。具体规则如下： 1.在重载方法中，不考虑基本类型的自动装拆箱和可变长参数，进行选取； 2.如果没有，就允许自动装拆箱但不允许可变长参数下选取； 3.如果没有，就允许自动装拆箱以及可变长参数下选取。 如果在同一阶段有多个适配方法方法就根据继承关系选取最为贴切的方法。 4.动态分派（确定重写方法）Java 中非私有实例方法会被编译成 invokevirtual 指令，而接口方法被编译成 invokeinterface 指令，对于这两种指令，java 虚拟机都要确定调用者的动态类型，来确定目标方法。对于静态绑定，直接引用指向的是一个具体的目标方法，而对于动态绑定，直接引用指向的是一个方法表的索引。 在前面类加载中连接 -准备过程说过，在类加载时会构造一个方法表，在这个方法表中，子类的方法表包含父类方法表中所有方法，且子类方法表中的索引值与重写的父类方法中的索引相同，对于重写的方法的入口地址，子类中重写的方法的地址是子类实现的方法的入口地址。例如： 父类 A 中的方法表| 索引 | 方法 | 地址 || —- | ———————— | —- || 0 | A.toString() | 0000 || 1 | A. name() 这是个抽象方法 | 0001 | 子类 a1 中的方法表| 索引 | 方法 | 地址 || —- | ———— | —- || 0 | A.toString() | 0000 || 1 | a1. name() | 0002 | 子类 a2 中的方法表| 索引 | 方法 | 地址 || —- | ————— | —- || 0 | A.toString() | 0000 || 1 | a2. name() | 0003 || 2 | a2.changeName() | 0004 | 对于重写方法的确定实际上就是在执行指令的时候访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值对应的目标方法。进而将符号引用替换为对应的索引，根据索引和对应的调用类型，就可以确定方法的地址。]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM----自动内存管理机制]]></title>
    <url>%2F2018%2F08%2F08%2FJVM-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.简介Java 虚拟机，简称 JVM, 是一个虚构的计算机，可模拟实际计算机操作系统上的功能并运行在不同的操作系统上，因此只要 Java 语言编译生成在 JVM 运行的字节码，JVM 就可以根据运行的对应的系统将字节码解释成具体系统平台的机器指令，从而实现跨平台运行。 二.内存区域当执行一个 Java 程序的时候，首先会将 Java 文件编译成 class 文件， 这就是一个字节码文件，然后通过类加载器将 Class 文件加载到虚拟机中运行。 JVM 将运行时的内存区域划分为几个部分： 1.程序计数器程序计数器是线程执行字节码的指示器，每个线程有一个独立的程序计数器，是一块较小的内存空间，存放着正在执行的字节码指令或者下一条需要执行的字节码指令。如果是一个 Java 方法，则记录正在执行的虚拟机字节码指令的地址，如果是一个 Native 则这个计数器的值就为空。 程序计数器是唯一一个没有规定任何 OutOfMemoryError (内存溢出) 的区域。 2.虚拟机栈虚拟机栈是 Java 方法执行时的内存模型，与线程的生命周期相同，同样是线程独有的，在执行一个一个方法的时候就会创建一个栈帧，这个栈帧包含了局部变量表，操作数栈，方法出口等信息，方法调用和执行完成就是一个栈帧在虚拟机栈中的入栈和出栈过程。 虚拟机栈中规定的异常状况有两种： 线程请求的栈深度大于虚拟机允许的深度就抛出 StackOverflowError 虚拟机栈内存可以动态扩展，如果扩展的时候不能申请到足够的内存就抛出 OutOfMemoryError 3.本地方法栈本地方法栈的作用和虚拟机栈类似，只不过本地方法栈是 Native 方法执行的内存模型，而虚拟机栈是 Java 方法的内存模型。 4.方法区方法区市一个线程共享的内存区域，用于存储被虚拟机加载后的类的信息，常量，静态变量等数据，通常定义在 Class 文件中 运行时常量池这个方法区的一部分，用于存放编译期生成的符号引用，字面量，运行时常量具有动态性，运行期间可以将新的常量放入常量池，而 Class 文件不具备这个特性。 方法区中的异常：当方法区，包括常量池，无法申请到足够的内存的时候就会抛出 OutMemoryError 异常。 5.堆Java 堆是也是所有线程的共享的一块区域，，用于存放对象的实例，即几乎所有的对象都在这里分配内存。同时 Java 堆也是垃圾收集器管理的主要的区域，因此也叫 GC 堆（Garbage Collected Heap ）,由于垃圾收集器可以采用不同的方式，对 Java 堆还进行了进一步的划分。可分为新生代/老年代，或者划分为 Eden 空间/From Survivor空间/To Survivor 空间。 Java 堆在物理上可以不连续，只要逻辑连续，同时可以设置固定大小，也可以设置为可扩展 设置 Xmx 最大值 设置 Xms 最小值 如果一个实例在堆中没有完成分配，且堆也没有办法进行扩展，就抛出 OutOfMemoryError 异常。 二.对象的创建1.对象的内存布局前面说过实例对象是存储在 java 堆中的，而在具体的内存区域中，一个对象的存储又可以划分 3 个区域：对象头，实例数据，对齐填充。 对象头，包含了两个部分的内容，一个是对象自身的运行数据，包括哈希码，GC 分代，锁状态等，这部分称为 Mark Word。另一个部分是类型指针，指向类元数据，可以确定对象是哪个类的实例。 实例数据，这是一个对象存储的真正的信息，包括继承父类的和自己本身的。 对齐填充，起着占位符的作用，为了对象的起始地址是 8 个字节的整数倍。 2.对象的创建过程一个对象的创建通常是由 new 开始的，具体的过程可分为下面几个部分： 1.首先，会检查 new 指令的参数能否在方法区的常量池中找到对应类的符号引用，并检查这个符号引用的类是否被加载，解析和初始化过，没有就进行这三个步骤。 2.一个类加载后需要的内存大小就可以确定，接着会为这个对象分配内存，内存分配完成后会首先初始化为 0 .根据 Java 堆中内存是不是规整的有两种不同的内存划分方式： 堆内存是规整的，使用指针碰撞的方式。即用过内存放在一边，没有通过的放在一边，中间使用一个指针作为分界点，分配时通过指针移动一段合适的距离划分新的内存空间。 堆内存不是规整的，使用空闲列表。即通过一个列表记录哪些内存是可以用的，从表中找到一块区域直接划分并更新列表。 3.设置对象信息，主要是对象头中的信息，包括这个对象属于哪个类的实例，类的元数据的信息，对象的哈希码，GC 分代年龄，锁信息等。 4.执行数据的初始化，即 init 方法。 3.对象的访问对象在内存分配完成后就可以使用在 栈中的引用类型 （reference 数据）来操作具体的对象，这种访问方式可以分为来个两种方式，使用句柄和使用直接指针。 使用句柄，会在 Java 堆中划分一份区域为句柄池，作为 reference 数据和真正的对象的一个桥梁。使用句柄的优势是即使对象的内存地址被移动，只会改变句柄中的实例数据的指针，而reference 不会改变。 使用直接指针，就是指reference 直接指向对象的地址，它的优势是可以减少开销，速度比较快。 三.垃圾收集1.简介在 Java 语言中，不需要直接控制内存的回收，Java 程序的内存分配和回收都是由 JRE 在后台自动进行的 JRE 会负责回收那些不再使用的内存，这种机制称为垃圾回收（Garbage Collection ,GC ）通常在CPU 空闲或者内存不足的时候就会进行回收。垃圾回收机制能自动释放内存空间，减轻了编写 Java 程序的负担，（C/C++ 需要显示进行垃圾回收），同时垃圾回收保证了程序的完成性，垃圾回收是 java 语言安全性策略的一个重要的部分。 2.回收的对象在进行一次垃圾回收的时候首先就是要找到所有的对象，并判断对象是否可进行回收。通常由两种算法; (1).引用计数算法这种算法是通过给对象增加一个引用的计数器，只要有一个指针指向这个对象，这个计数器就加 1 ，这个引用失效就减 1.如果一个对象的计数为 0 的时候就可以进行回收。 这个算法存在的问题就是当两个对象互相含有对方的引用，但是又没有被其他对象引用的时候，计数器就不为 0 ，又不能被垃圾回收 123graph LRA--&gt;BB--&gt; A (2)可达性算法这个算法首先会记录一系列 GC Root 对象，这些对象通常就是还有被使用的对象，然后以这些对象为起点向下搜索，搜索的对象的路径称为引用链，如果一些对象到 GC Root 之间没有任何引用链，那么这个对象就可以回收。 (3)对象的引用对象被定义为两种状态：没有引用可回收，有引用不可回收，会显得内存回收不够灵活，因此希望对象如果在内存足够的时候在 GC 时 继续保留在内存中，如果进行 GC 后内存还是不足就直接回收。针对这种情况，对对象的引用进行了扩充。将一个引用划分为强引用，软引用，弱引用，虚引用。 强引用，只要强引用存在就不会回收掉引用的对象 软引用：在系统将发生内存溢出前会将这些对象列入第二次回收的范围 弱引用：无论内存是否足够都会回收 虚引用：虚引用不会对对象回收产生影响，它的作用是在回收时受到一个系统通知。 (4).对象的死亡一个对象的死亡是经过两次标记过程的，即在进行可达性算法的时候会即使不可达也不一定就立即回收。 3.垃圾收集算法JVM 并没有明确指定使用哪种算法，但是任何一种算法的作用都是发现无用的对象，回收被无用对对象占用的内存空间，使得空间能够再次被使用。 1.对象的划分在 Java 堆中通常根据对象的使用频率将对象划分为不同的区域。每一个对象有一个年龄计数器，发生一次 GC 且存活就将计数器加 1 .对于长期存活的对象就可从新生代进入老年代。对于新生代和老年代就可以采取不同的垃圾回收 Minor GC ，新生代的垃圾回收，执行比较频繁，速度比较快 Major GC/ Full GC,老年代的垃圾回收，通常老年代的会伴随着新生代回收。 2.垃圾收集算法(1)标记-清除算法对对象的内存进行标记，然后清除。这种算法有两个明显的问题： 标记和清除的效率比较低 清除后产生大量的不连续的碎片空间，在分配一些需要大内存的对像的时候可能会因为内存不够导致再一次的 GC. (2)复制算法在新生代的对象很多都有着较低的生命期，因此将内存按 8 ：1： 1 划分为 一个Eden 和两个 Survivor ，回收时将Eden 和 Survivor 存活的复制到另一个 Survivor 。如果另一个Survivor 的空间不够就需要向老年代进行分配担保，处于From Survivor 的新生代可进入老年代。 (3)标记整理存活的对象向一方移动，然后清理掉端边界的内容。 (4)分代-收集分代收集也就是对新生代和老年代采用不同的垃圾收集算法。 3.查找 GC RootJava 虚拟机中使用 Oopmap 的数据结构记录对象的引用，通过 Oopmap 就可以找到所有的 GC Root 。JVM 只在指令中产生 Safepoint（安全点） 的地方进行一次记录，可避免对每条指令进行记录导致 Oopmap 多次变化。对于执行的线程中的到达安全点，主要有抢先式和主动式两种，而对于没有运行的不代码，就设置为安全区域，Safe Region ，其中的引用关系不会变化，所以可以直接GC 可以不用响应JVM 的中断。 4.垃圾收集器垃圾收集器是对收集算法的具体实现，在JVM 中包含的收集器有下面几种： 1.Serial 收集器 单线程收集器，进行垃圾收集的时候会暂停所有的工作线程 简单高效，在内存较少的场景中，线程停顿时间是可以接受的 采取复制算法 2.ParNew 收集器 多线程版本的Serial ,在进行垃圾回收的时候是通过多个线程进行的 采取复制算法 3.Parallel Scavenge 收集器 多线程的收集器，可达到一个可控的吞吐量，高效的利用 CPU 时间，适用在后台运算而不需要太多交互的任务 采取复制算法 4.Parallel Old 收集器 Parallel Scavenge 的老年代版本，使用多线程和“标记-整理”算法 适用于注重吞吐量以及 CPU 资源敏感的场合 5.Serial Old 收集器 Serial 的老年代版本 6.CMS 收集器 是一种以获取最短回收停顿时间为目标的收集器，适用于响应速度快，系统停顿时间最短。 运作过程： 初始标记，标记 GC 能直接关联到的对象，需要停止其他线程。 并发标记，根节点枚举的过程。 重新标记，修正并发标记期间用户程序继续运作而导致标记产生变动的那个部分对象的标记，需要停止其他线程。 并发清除 缺点： 在并发阶段需要暂用一部分 CPU 资源，从而导致应用程序变慢，总吞吐量会降低。 在并发清理阶段，用户线程产生的新的垃圾不会被回收，且需要留一部分的空间给用户空间运行。 使用标记-清除算法，且通过内存碎片整理的方式，合并内存碎片，这个过程不能并发，会延长停顿时间。 7.G1 收集器特点： 并行与并发，充分利用多 CPU多核环境 。 分代收集，管理整个 GC 堆但是可以采用不同的方式去处理不同的对象 空间整合，在整体上 使用 标记整理，在局部采用复制，不会产生内存空间碎片。 可预测的停顿，可指定在一个时间片段内 GC 消耗的时间。 高效，将内存划分为几个区域，跟踪区域垃圾堆积的价值大小，维护一张优先表，优先回收。 过程： 初始标记，GC 关联对象。 并发标记，找出存活对象。 最终标记，修正并发标记期间用户程序继续运作而导致标记产生变动的那个部分对象的标记。 筛选标记，对区域进行筛选，并回收。 4.内存分配与回收策略 优先在新生代 Eden 区分配，当 Eden 没有足够的空间的时候就会发起一次 Minor GC 数组或者长字符串等大对象直接进入老年代 长期存活的对象根据对象年龄计数器的数值动态晋升到老年代。 空间分配担保：]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Context]]></title>
    <url>%2F2018%2F08%2F02%2FAndroid-Context%2F</url>
    <content type="text"><![CDATA[一.简介 Context 翻译为上下文环境，是一个应用程序环境信息的接口。 如果以 Android 系统角度来看可以理解为某一与操作系统的交互的具体场景，比如 Activity 的具体功能，Service 的后台运行等。如果以程序的角度看，Context 是一个抽象类，维持 Android 程序中各组件能够正常工作的一个核心功能类。通过 Context 可以获取应用程序的资源和类，也可以进行一些应用程序的操作。 Context 的设计采用了代理模式，它的功能的具体实现类是 ContextImpl ，而间接的实现类是 Activity ，Service 和 Application。因此一个应用程序 Context 的实例的对象的个数就是 Activity ， Service 和一个 Application 这三者的总数。它们的具体关系如图: 可以看到在代理模式中 ContextWrapper 的变量 mBase 是一个 ContextImpl 类型，通常Activity ， Service 和 Application 中的操作最终都会通过 mBase 交给 ContextImpl 去实现，最后在通过 mOuterContext 对结果进行放回，显然这个变量实际上就是Context 的三个具体的实现。下面就看这三种 Context 是如何创建并与 ContextImpl 关联的。 二.创建 Context1.Application Context一个应用程序启动时候总是会创建 Application，具体是由 LoadedApk 实现。 123456789101112131415Application app = r.loadedApk.makeApplication(false, mInstrumentation);// LoadedApk 中public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; ... Application app = null; ... ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); 在这里可以看到一个大致的框架，这里可以分为三个步骤去看; 首先会去创建 Application 的 ContextImpl 然后把这个 ContextImpl 作为一个参数传到 newApplcation 方法中去创建 Application 最后将 ContextImpl 和 Application 关联。 第一步想看 ContextImpl 的静态方法 createAppContext1234567static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk loadedApk) &#123; ... ContextImpl context = new ContextImpl(null, mainThread, loadedApk, null, null, null, 0, null); context.setResources(loadedApk.getResources()); return context; &#125; 很明显就是创建 ContextImp,并设置应用的资源。接着看第二步，创建 Application。 1234567891011121314151617181920 //在 Instrumentation 类中 static public Application newApplication(Class&lt;?&gt; clazz, Context context) ... Application app = (Application)clazz.newInstance(); app.attach(context);//这里的Context 就是ContextImpl return app; &#125; // 在 Application 中/* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mLoadedApk; &#125; // 在 ContextWrapper 类中protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; 可以看到首先就是通过类加载去创建 Application，然后就将 ContextImpl 赋值给 mBase ，这样 Application 和 ContextImpl 的关联就建立。最后看第三步。12345 appContext.setOuterContext(app); //在 ContextImpl 中final void setOuterContext(Context context) &#123; mOuterContext = context; &#125; 将返回的 Application 赋值给 ContextImpl 的变量 mOuterContext，这样 Context 的代理模式完成关联，Application Context 也创建完毕。 流程如图： 2.Activity ContextActivity Context 的创建可以定位到 Activity 启动过程，在 ActivityThread 中。123456789101112131415161718 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... ContextImpl appContext = ContextImpl 作为参数关联ContextImpl(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); ... appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent,r.embeddedID, r.lastNonConfigurationInstances, config,r.referrer, r.voiceInteractor, window, r.configCallback); &#125; 整个过程和 Application 比较相似，不过有一点不同，这里分为 4 步来看: 创建 ContextImpl 对象 创建 Activity 实例 ContextImpl 关联 Activity Activity 关联 ContextImpl 先看第一步过程123456789101112private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123; ... ContextImpl appContext = ContextImpl.createActivityContext( this, r.loadedApk, r.activityInfo, r.token, displayId, r.overrideConfig); ... static ContextImpl createActivityContext(ActivityThread mainThread, ... ContextImpl context = new ContextImpl(null, mainThread, loadedApk, activityInfo.splitName, activityToken, null, 0, classLoader); ... 与 application 不同的是，这里创建的是对应的 Activity 的 ContextImpl ，具有不一样的功能实现。接着实例化 Activity 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 同样也是通过类加载创建 Activity。在第三四步中12345678910111213141516171819202122232425262728293031//第三步，在ContextImpl 中final void setOuterContext(Context context) &#123; mOuterContext = context;&#125;//第四步，在 Activity中 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; ... attachBaseContext(context); ... &#125;@Overrideprotected void attachBaseContext(Context newBase) &#123; super.attachBaseContext(newBase); ...&#125;//在 ContextWrapper 中 protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base;&#125; 通过 ContextImpl 和 Activity 的相互关联，Activity Context 的创建也就完成了，以后 Activity 的任务大多就是通过 ContextImpl 实现。 流程如图： 3.Service ContextService 的Context 的创建和 Activity 的十分相似.123456789101112131415161718private void handleCreateService(CreateServiceData data) &#123; LoadedApk loadedApk = getLoadedApkNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = loadedApk.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; ... &#125; ContextImpl context = ContextImpl.createAppContext(this, loadedApk); context.setOuterContext(service); ... service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); 整个流程没有大的变化，只是 Service 会先实例在去创建 ContextImpl ，而且这里的 ContextImpl 和 Activity 是不一样的。 流程如图： 三.Context 的使用前面说过 Context 的实现就是 Activity ，Service 和 Application ,因此如果对 Context 使用不当的话很容易发生内存泄漏，比如下面这两段代码 123456789public class A&#123; private static Context mContext; public static void setContext(Context context)&#123; mContext = context; &#125;&#125; 123456789101112131415161718192021public class B&#123; private static B sInstance; private Context mContext; private B(Context context) &#123; this.mContext = context; &#125; public static synchronized B getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new B(context); &#125; return sInstance; &#125; &#125; 在第一段代码中有一个静态的 Context ,在第二段是一个单例模式，一个静态实例拥有一个 Context 变量。在这两种情况下，Context 的周期就和应用程序一样，这是如果赋值时 Activity 或者 Service 就会使得 Activity 和 Service 在退出后不能正常被回收，因为还有 Context 引用。因此建议尽量 Application Context ，因为 Application Context 的周期就是整个应用程序，所以不用担心内存泄漏。但是在某些情况比如创建 Dialog, 或者启动组建的时候就只能使用 Activity Context 或者 Service Context ,这个时候就要注意内存泄漏问题了。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----IPC机制（Binder）]]></title>
    <url>%2F2018%2F07%2F25%2FAndroid-IPC%E6%9C%BA%E5%88%B6%EF%BC%88Binder%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一.简介IPC (Inter-Process Communication),意为进程间的通信。一个操作系统不同的进程，有自己的进程内存空间，其中的数据不共享，因此进程间的通信就需要采用一定的机制，传统的进程通信的方式有 Socket，管道，内存共享，消息队列等，在 Linux 系统中同样存在这些方式。Android 系统是基于 Linux 系统的，但是 Android 系统却采用了另一种进程通信机制 Binder ，主要有以下两点原因： 性能，传统的通信的方式，要么开销大且效率里，比如 Socket ,或者数据需要进行多次拷贝，性能较低。 安全，在 Android 系统中，获取系统操作很简单比如连接无线网络，访问文件等，如果不对进程进行标识，一些程序就很容易进行频繁地进行底层操作。传统 IPC 没有任何安全措施，不能识别用户进程，比如 Socket ，用户完全可以指定自己的端口。 而使用 Binder 可以做到只对数据进行一次拷贝，并在每次通信的时候问每个用户进程添加标识。因此相对传统的 IPC 机制性能和安全性都相对较高。 二.基础概念1.Parcel/Serializable/Parcelable Serializable ：[sɪərɪrlaɪ’zəbl] 1.Parcel 是一个容器，可以包含数据或者是对象引用，支持序列化以及跨进程之后进行反序列化，里面有很多 native 方法，在底层实现中都是用于将数据写入内存，和从内存中。 2.Serializable 和 Parcelable 都是实现序列化的接口，Parcelable 是在内存中直接进行读写,中间结合需要 Parcel 类去做一些低层的工作 （C/C++ 实现）而 Serializable 是通过使用 IO 流的形式将数据读写入在硬盘上， Parcelable 的性能要强于 Serializable, 但是 Parcelable 无法将数据进行持久化。 2.IBinder/Binder1.IBinder 是 Binder 的接口，。这个接口定义了与远程对象交互的协议。不仅用于远程调用，也用于进程内调用 2.Binder 实现了 Binder 接口，这是 Binder 机制的通信的媒介，进程 A 调用进程 B 的方法，具体就是由这个 Binder 实现。 3.Binder 驱动(1).运行空间（内核空间/用户空间）在 Android 系统中负责调用系统一切资源的是 Linux 的内核空间，而用户程序运行的空间是用户空间，每个进程有属于自己的用户空间，当用户空间需要调用系统资源的时候，只能通过内核空间提供的 System call ,系统调用，去访问内核空间。 (2).Binder 驱动传统的 IPC 机制是 Linux 内核支持的，但是 Binder 并不是 Linux 支持的，但是 Linux 可以动态添加内核模块，这个模块在内核中有自己的内核空间，因此 Android 就在系统中添加一个模块，这个模块就叫 Binder 驱动。Binder 驱动会自动完成进程 A 和 进程 B 的 Binder 对象的转换；而相应的方法参数就会在用户空间通过 mmap ,ioctl ，open 等 方法就可以调用 Binder 驱动里的方法，然后这样两个不同进程的用户空间就可以通过这个 Binder 驱动的内核空间进行通信。 4.Binder 框架1.Client，客户进程，这是相对的说法，只要是发起进程请求的一方都可以为客户进程 2.Server，服务进程，这也是相对的说法，被请求执行某种服务的进程都可以称为服务端进程 3.ServiceManager，SM，对服务进程的管理，每个服务进程都要在这里注册所拥有的跨进程的 Binder, 并保存对应的 Binder 的引用，Client 可以通过名字在这里查询想要的服务的名字，最后 SM 就会返回该 Server 的一个 Binder 的引用。SM 也是一个进程，但是每个需要和 SM 通信的进程都知道 SM 的引用，这是提前就固定的。 4.Binder 驱动，在具体的通信过程中做中转，比如需要传递的数据，Binder 对象在两个进程间的转换等. 5.Java 层的 Binder1.AIDLAIDL (Android 接口定义语言),用于跨进程通信，通过定义 ADIL ,AS 会自动生成 Binder 类。比如，定义一个如下的接口12345678import com.example.asus.testdemo.Book;//即使在一个包下也要 importinterface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; aidl 支持的数据类型有如下 基本数据类型 String 和 CharSequence List，只支持 ArrayList，每个元素都支持 AIDL Map，只支持 Map,每个key，value,都支持 AIDL Parcelable,所有实现 Parcelable 接口 AIDL,所有定义为 AIDL 的接口，比如上面的 IBookManager ，也可以作为一个接口对象 生成的 aidl 文件为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public interface IBookManager extends android.os.IInterface &#123; public interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.example.asus.testdemo.IBookManager &#123; private static final java.lang.String DESCRIPTOR = &quot;com.example.asus.testdemo.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.asus.testdemo.IBookManager interface, * generating a proxy if needed. */ public static com.example.asus.testdemo.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.asus.testdemo.IBookManager))) &#123; return ((com.example.asus.testdemo.IBookManager) iin); &#125; return new com.example.asus.testdemo.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.example.asus.testdemo.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.example.asus.testdemo.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.example.asus.testdemo.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.asus.testdemo.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException; &#125; 这个接口的内部结构就是有一个 Stub 的内部类，这 Stub 内部类还有一个内部类 Proxy。先看 Stub 类，Binder 的 java 层采用的是代理模式，其中 Stub 类代表是 Binder 的本地对象，而 Proxy 则是 Binder 在另一个进程的代理对象。先看 Stub 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static abstract class Stub extends android.os.Binder implements com.example.asus.testdemo.IBookManager &#123; private static final java.lang.String DESCRIPTOR = &quot;com.example.asus.testdemo.IBookManager&quot;; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.example.asus.testdemo.IBookManager interface, * generating a proxy if needed. */ public static com.example.asus.testdemo.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.asus.testdemo.IBookManager))) &#123; return ((com.example.asus.testdemo.IBookManager) iin); &#125; return new com.example.asus.testdemo.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; ... &#125; case TRANSACTION_getBookList: &#123; ... &#125; case TRANSACTION_addBook: &#123; ... &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; DESCRIPTOR，Binder 的唯一标识 asInterface，用于 Binder 到转换，如果客户服务端都在同一进程，就会返回一个 Binder 对象本身，如果是在不同进程就返回其代理 Proxy. asBinder,返回当前的Binder 对象 onTransact，这个方法在服务端的线程池中，通过标识判断客户端调用的是什么方法，data 就是方法的参数。 这是一个抽象类，因此具体的是实现就在 Service 中,通过onBinder 方法返回具体的实现。接着看 Proxy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static class Proxy implements com.example.asus.testdemo.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public java.util.List&lt;com.example.asus.testdemo.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.example.asus.testdemo.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.example.asus.testdemo.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.example.asus.testdemo.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; 客户进程得到的对象通常为这个类的实例，_data 就是参数，_reply 就是相应的返回值，而在这里封装了具体的数据写入的底层实现，而这对客户进程是透明的。 三.工作流程1.大致流程1.当有一个应用进程提供一个可跨进程访问的的服务的时候，就会通过默认的通信地址向 ServiceManager 注册服务相应的线程就进入等待，这时 ServiceManager 就会通过 ioctl 方法让 Binder 驱动在内核空间保存相应的信息，然后 ServiceManager 就会唤醒线程通知应用进程注册成功。 2.客户进程查询服务，SM 会通过和 Binder 驱动交互，查询已注册的服务，查询到就返回相应的对象，这时就会返回一个代理对象。 3.通过调用代理对象的方法这时客户进程的这个线程进入等待状态，按之前的 Proxy 的方法的实现可以知道，在客户进程只是对一些数据进行包装，然后写入Binder 驱动和 SM 的共享内存，这是一次拷贝也是唯一的一次， 而服务进程的用户空间的地址和这个内存已经做了映射，所以 服务进程可以直接获取内存中的数据， 对于Binder Proxy 对象，就又转化为 Binder 的 Stub 的具体实现，等执行完后就返回，这同样也是一次通信，最后客户的进程的线程就会被唤醒。 2.跨进程的接口同样的通过定义一个接口，让客户进程实现相应的方法，可以做到在服务进程回调所有客户进程的方法。 123interface IOnNewBookListenerArrivedListener &#123; void onNewBookArrvied(in Book newBook);&#125; 123456789101112131415interface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookListenerArrivedListener listener); void unregisterListener(IOnNewBookListenerArrivedListener listener);&#125; 在服务进程有一个用于对所有接口保存的类，RemoteCallbackList 是系统用于跨进程接口通信的，内部有一个 HasMap ,key 是 IBinder ，value 是 listener, 因此可以根据 Binder 找到客户端，因为每个客户端的 Proxy 都是不一样的。1private RemoteCallbackList&lt;IOnNewBookListenerArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); 在重写的方法中12345678910@Override public void registerListener(IOnNewBookListenerArrivedListener listener) throws RemoteException &#123; mListeners.register(listener); &#125; @Override public void unregisterListener(IOnNewBookListenerArrivedListener listener) throws RemoteException &#123; mListeners.unregister(listener); &#125; 回调的具体使用可以看以下例子1234567private void onNewBookArrived(Book book) throws RemoteException&#123; for (int i=0;i&lt;mListeners.beginBroadcast();i++)&#123; IOnNewBookListenerArrivedListener listenerArrivedListener = mListeners.getBroadcastItem(i); listenerArrivedListener.onNewBookArrvied(book); &#125; mListeners.finishBroadcast(); &#125; 在客户端只要这样使用就可以 12345678private IOnNewBookListenerArrivedListener mListener = new IOnNewBookListenerArrivedListener.Stub() &#123; @Override public void onNewBookArrvied(Book newBook) throws RemoteException &#123; Log.e(TAG, &quot;onNewBookArrvied: &quot;+newBook.toString()); &#125; &#125;; ....mBookManager.registerListener(mListener); 四.其他方式1.Intent/BundleIntent 和 Bundle 都实现了 Parcelable 接口，因为 Intent 常常用于组件的通信，因此在跨进程中，这也只是适合于组件间的跨进程通信，低层也是 Binder 机制。 2.文件共享两个应用进程使用同一个共享文件并结合序列化可实现对数据的传递，但是在 Linux 系统中对文件的读写并没有处理并发情况，因此在高并发访问的情况可能会产生一些问题。 3.Messenger和 Messege 共同使用，但是服务对 Messege 的处理时串行的，因此也不适合高并发情况，且不能获取返回的结果,不适合 Remote Procedure Call （RPC 跨进程调用）。这是对 AIDL 封装后的是使用，也就是内部是 Binder 机制。 4.ContentProvider用于一对多的进程间的数据共享，支持并发操作，因为内部的数据库实际上是可以做到同步的，在底层仍然是 Binder 机制 5.Socket常用于不同网络的进程间的通信，因此不适合 RPC 。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Handler消息机制]]></title>
    <url>%2F2018%2F07%2F23%2FAndroid-Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.简单介绍Android 中的消息机制主要是指 Handler 的运行机制和在 MessageQueue 和 Looper 的配合下 将一个线程中的任务切换到 Hanlder 所在的线程去执行。在 Android 中常常用来在子线程切换到 UI 线程从而在 UI 线程更新 UI 。 Android 的 UI 控件不是线程安全的，如果多个线程并发访问控件会导致控件的状态不可预期，这和多线程访问同一的变量是一个道理，但是控件却不能像简单的变量一样加上锁机制就可以实现线程同步，因为这会降低 UI 的访问效率。所以采用单线程的模式通过 Handler 切换可以实现 UI 的更新。 二.涉及的几个类1.MessageQueue 和 MessageMessageQueue 是一个消息队列，内部是以一个单链表的数据结构维护数据。Message 就是消息队列中存储的对象。 2.Looper在消息机制中 Looper 会不断地从 MessageQueue 中查看是否有新的 Message 需要处理，没有就阻塞等待，这是一个无限循环的模式。MessageQueue 会在 Looper 的构造器中初始化，也就是说一个 Looper 对应一个 MessageQueue . 3.Handler消息的发送者和处理者，内部有一个 Looper 和一个 MessageQueue 。通过 dispatchMessage 方法对消息进行分派，决定最后的回调方式。有一个抽象方法 handleMessage 用与处理消息。在 dispatchMessage 方法中，如果消息是 handler.post 方式发送则会调用 post 里的 Runnable 接口，如果是 sendMessage 方式发送就会调用 handleMessage 方法。 4.ThreadLocal这是 Thread Local Variable 线程局部变量的意思，支持泛型，这个类的功能就是为每个线程提供一个变量（ 用泛型指定 类型）的副本，使得每个线程都可以独立地改变自己的副本而不会和其他线程产生冲突。可以隔离多个线程对共享资源的冲突。在 Handler 中 ThreadLocal 存放着 Looper ，因此只要在 UI 线程中都可以实例化 Handler 就可以得到主线程的 Looper。 三.工作过程在实际开发中，Handler 的使用通常在主线程中，然后在子线程中发送消息，最后在运行在主线程的 handleMessage 处理消息，或者以 Handler.post 方法中处理消息。 1.主线程的消息循环主线程的消息循环的开始是在 ActivityThread 的 main 方法中 123456789public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ... ActivityThread thread = new ActivityThread(); ... Looper.loop(); &#125; 这里先看第一个方法 prepareMainLooper ，这是独有的。123public static void prepareMainLooper() &#123; prepare(false); ... 12345678private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; //一个线程只能有一个 Looper throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; //创建主线程的 Looper sThreadLocal.set(new Looper(quitAllowed)); &#125; 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 在 ActivityThread 的 main 方法中会创建主线程的 Looper ,并且在实例化 Looper 时候就创建消息队列 MessageQueue ，并将当前线程和 Looper 关联起来。接着创建完 UI 线程后就会执行 loop 方法。 1234567891011121314151617public static void loop() &#123; final Looper me = myLooper(); ... //无限循环 for (;;) &#123; Message msg = queue.next(); // might block ... try &#123; ... //这里的 target就是 Handler msg.target.dispatchMessage(msg); ... &#125; // 释放资源 msg.recycleUnchecked(); &#125;&#125; 在 loop 方法中会无限循环对消息队列进行查看，如果有消息就取出消息，并找到消息对应的执行者进行分派，最后释放资源。 2.Handler 的创建12345678public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); ... mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 通常如果使用 Handler 更新 UI 控件的话，那么 Hanlder 的实例化就要在主线程中，因为这样才能在构造方法中获取主线程的 looper 和对应的 MessageQueue 。 3.sendMessage 和 post(1).sendMessage( Message )1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 12345public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; ... return enqueueMessage(queue, msg, uptimeMillis);&#125; 12345678private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //在这里 msg 的 target 就被赋值，这里指向就是 handler msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 从上面的方法一步步执行下来，在 enqueueMessage 方法中将 msg 的 target 指向 调用的 handler ，最后就会将消息添加到消息队列中。 (2)post( Runnable )1234public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; 123456private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); //将 Runnable 赋给 Message 的 callback m.callback = r; return m; &#125; post 方式中参数是一个 Runnable 对象，在 Hanlder 会被封装为一个 Message ,最后同样调用 sendMessageDelayed 方法，后续的操作就是一样的。 4.处理消息通过 3 中两种方式都可以发送一个消息，往消息队列中添加 Message ,而接着 looper 循环就会取出这个消息，对其进行分配也就是在之前讲过的 msg.target.dispatchMessage 方法。这里的 msg.target 在 3 中可以看到其实就是 Handler ，接着就看 dispatchMessage . 1234567891011121314public void dispatchMessage(Message msg) &#123; //这对应 post 方式 if (msg.callback != null) &#123; handleCallback(msg); //这对应 sendMessage 方式 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 可以看到最后就会根据之前的发送消息的方式从而选择不同的方法，如果是 post 方式就会执行 post 里面的 run 方法，如果是 sendMessage 方式就会执行 handleMessage .大致流程如图： 点击查看大图 四.HandlerThread 和 IntentService在上面的讲述过程中，都是以主线程的存在情况，因为主线程在程序运行开始阶段系统就会创建被初始化 looper 和 MessageQueue ,不用自己手动创建。这是 Handler 消息机制的在主线程的运用情况，下面就介绍如何在子线程运用 Handler 。 1.HandlerThreadHandlerThread 继承了 Thread ,内部有自己的 Looper 。这个类是对在子线程使用 Handler 和 Looper 的一个简单的封装，从而实现子线程有自己的消息循环。 12345678910111213141516171819202122public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; .... @Override public void run() &#123; mTid = Process.myTid(); //创建自己的 Looper Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); //消息循环 Looper.loop(); mTid = -1; &#125;&#125; 12345678910public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 在子线程中创建一个 Looper ,需要通过 prepare() 方法，后续的步骤也和之前在主线程创建一样，只不过这里的 Looper 是属于 HanlderThread 这个线程的。 2.IntentService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; //因为这里的 handleMessage 是在 HanldeThread 中的 //所以 onHandleIntent 也就运行在子线程中。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; @Override public void onCreate() &#123; super.onCreate(); //创建 HanlderThread 对象 HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); //获取线程中的 Looper mServiceLooper = thread.getLooper(); //绑定自己的 Handler ,注意这里的 Looper 是子线程的， //所以 Handler 中的方法会运行在子线程中 mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; //将 Intent 包装在 Message 中发送 mServiceHandler.sendMessage(msg); &#125; 上面方法是 IntentService 的源码，IntentService 有一个特殊的方法就是 onHandleIntent ，这个方法是一个运行在子线程中方法，所以可以进行一些耗时的操作。IntentService 实现的原理实际上就是运用了 HandlerThread 。在 onCreate 方法中会启动这个线程，并将 ServiceHandler 和 HandlerThread 线程的 Looper 进行绑定，因此 Hanlder 发送的消息就会到这个子线程中去处理。在 handleMessage 调用 onHandleIntent ，从而实现在子线程获取 Intent,并处理操作。]]></content>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----View事件分发和绘制机制]]></title>
    <url>%2F2018%2F07%2F21%2FAndroid-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%92%8C%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.View 的事件分发(一).概念1.事件分发View 的事件分发其实就是点击事件（ MotionEvent ）从产生后系统开始分发，到传递给一个具体的 View （ 或者Activity ）的过程，View (或 Activity )会选择是否对事件进行消耗。 2.事件的类型和事件序列(1)事件类型 MotionEvent.ACTION_DOWN 按下时产生的事件 MotionEvent.ACTION_MOVE 滑动时产生的事件 MotionEvent.ACTION_UP 抬起时产生的事件 MotionEvent.ACTION_CANCEL 发生异常时产生的事件 (2)事件序列同一个事件序列指的是从按下时候到抬起时产生的一系列事件，通常以 DOWN 开始，中间有不定数个 MOVE ,最后以 UP 或者 CANCLE 结束。 3.分发对象和对应的方法对事件的分发主要涉及三个对象，Activity , ViewGroup ,具体的 View，这三个对象按分发的层次依次是Activity -&gt; ViewGroup -&gt; 具体的 View 。而涉及分发的方法同样主要有三个： dispatchTouchEvent 对一个事件进行分发，可能是分发给下一层处理，或者分发给自己。 onInterceptTouchEvent 这个方法只有 ViewGroup 有，用来判断对事件是否进行拦截，如果拦截就不会分发给下一层. onTouchEvent 对事件进行处理，消耗或者不消耗，不消耗就会返回给上层。对于 ViewGroup 和 View 这个方法还受到 OnTouchListener 和 enable 属性 的影响，具体的后面会阐述。 (二).事件分发1.Activity 对事件的分发12345678public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; Activity 的事件的处理其实并不负责，即如果下层（不管是 ViewGroup 还是 View ）消耗了这个事件，那么 if 语句就为 true , 则 dispatchTouchEvent 就返回 true 。如果没有消耗就自己对事件进行处理，即调用 onTouchEvent 方法。12345678public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false;&#125; 12345678910/** @hide */public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; final boolean isOutside = event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) || event.getAction() == MotionEvent.ACTION_OUTSIDE; if (mCloseOnTouchOutside &amp;&amp; peekDecorView() != null &amp;&amp; isOutside) &#123; return true; &#125; return false;&#125; Activity 的 onTouchEvent 会对这个事件进行判断，如果事件在窗口边界外就返回 true，dispatchTouchEvent 就返回 true ;如果在边界内就 返回 false ,最后 dispatchTouchEvent 也会返回 false 。这部分流程如图 （这是截自整体流程图的一部分） 2.View 对事件的分发这里先说 View 对事件的分发是因为 ViewGroup 继承自 View ,ViewGroup 对事件的分发会调用到父类（也就是View ）的方法，因此先理清 View 的分发有助于理解。 123456789101112131415public boolean dispatchTouchEvent(MotionEvent event) &#123; ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... return result; &#125; 可以看到 View 的事件的处理是先判断 mOnTouchListener !=null 和 View 设置 ENABLED 这两个条件成不成立，不过成立则 调用 onTouch 方法，且如果 onTouch 返回了 true ,那个事件就被消耗 ，View 的 dispatchTouchEvent 就返回 true ; 相反，如果条件不成立或者 onTouch 返回 false ,那么就会执行 View 的 onTouchEvent 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142public boolean onTouchEvent(MotionEvent event) &#123; ... final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // 若可点击，包括LONG_CLICKABLE 或者 CLICKABLE if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ... // 执行performClick() performClick(); break; case MotionEvent.ACTION_DOWN: ... break; case MotionEvent.ACTION_CANCEL: ... break; case MotionEvent.ACTION_MOVE: ... break; &#125; //&gt;&gt; 若可点击，就返回true return true; &#125; //&gt;&gt; 若不可点击，就返回false return false; &#125; 123456789public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false; &#125; 在 onTouchEvent 方法中，如果 View 是可点击的，比如设置了 onClick 或者 onLongClick ,就会执行 onClick 方法，并且 onTouchEvent 返回 true ，如果是不可点击的就返回 false 。需要注意的是这里的 onTouchEvent 是可以被重写的。如果 onTouchEvent 返回 true 那么 View 的 dispatchTouchEvent 就返回 true ,事件就被消耗，如果 onTouchEvent 返回 false , 那么 dispatchTouchEvent 也返回 false ,这时 事件就交由上层处理，也就是 ViewGroup 。这部分流程如图 3.ViewGroup 对事件的分发ViewGroup 对事件的分发也是从 dispatchTouchEvent 方法开始的，不同的是 ViewGroup 对了一个对事件进行拦截的方方法 onInterceptTouchEvent 。1234567891011121314151617181920212223242526272829public boolean dispatchTouchEvent(MotionEvent ev) &#123; final boolean intercepted; ... if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; ... //不拦截，分发给下一层 if (!canceled &amp;&amp; !intercepted) &#123; ... if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. ... &#125; ... // 子View 不处理，分发给自己 if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; ...&#125; 123456789101112131415private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; ... final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; //没有 子View 就自己处理 handled = super.dispatchTouchEvent(event); &#125; else &#123; //有就分发给下一层 handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ViewGroup 首先会判断 onInterceptTouchEvent 表示要不要拦截，这个方法也可以重写设置是否拦截，如果返回 false 就表示不拦截，这个事件就会分发给下一层，如果拦截就会分发给自己，当然如果子 View 不处理这个事件，还是会传到 ViewGroup ，ViewGroup 会调用父类也就是 View 的方法，后面的过程就和 View 对事件的处理是一样的 onTouch ,onTouchEvent , onClock …这部分的流程如图： ViewGroup 对事件的拦截 onInterceptTouchEvent 并不是每一次都会调用123456789101112131415if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState();//重置标志 &#125;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; 可以看到这里有三个条件：ACTION_DOWN 事件，mFirstTouchTarget 变量，FLAG_DISALLOW_INTERCEPT 这个标志。 1.对于 ACTION_DOWN 事件在判断之前都会调用 resetTouchState 这个方法重新给 FLAG_DISALLOW_INTERCEPT 置位,因此只要是 DOWN 事件，onInterceptTouchEvent 就会调用。 2.对于 mFirstTouchTarget 这个变量只要有 View 对事件进行处理，那么这个事件的后续事件就会直接交给这个 View ,mFirstTouchTarget 就直接指向 View , 正常情况下不会再询问 ViewGroup 是否拦截。而特殊情况就是下面这个。 3.对于 FLAG_DISALLOW_INTERCEPT子 View 可以重置这个标志，使得 disallowIntercept 的值改变从而可能会重新 onInterceptTouchEvent 对事件进行拦截。 到这里View 的事件分发的各个流程就已经讲完，最后是一个整体的流程： 二.View 的绘制(一).概念1.绘制机制View 的绘制机制实际上指的是 View 的三大流程 测量流程，测量 View 的大小，对应 measure 方法。 布局流程，有了 View 的大小后确定 View 的位置，对应 layout 方法。 绘制流程，对 View 的颜色，内容等进行绘制，对应 draw 方法。 View 的绘制从 ViewRootImpl 的 performTraversals 开始，首先会调用 performMeasure 方法，在这个方法中会一个 View 会调用 measure 去测量自己的大小，在此之前会调用 onMeasure 去测量子 View 的大小，这样层层调用，最后就会完成整个测量过程，后面的 layout 和 draw 的过程也是大致如此。流程如图 2.MeasureSpecMeasureSpec 是一个测量规格，在测量一个 View 的时候 从父类计算出来的 MeasureSpec 会传给这个 View ，同时会根据 View 自身的 LayoutParams 属性，也就是指定的一些 MATCH_PARENT, WRAP_CONTENT,xxdp 等属性最终一起决定 View 的大小。 MeasureSpec 是一个 int 值，有32位，高2位代表 Mode ,后30 位Size .之所以将两个值包装在在一个 int 是因为这样可以减少减少对象的分配。而 Mode 表示测量模式，有三种测量模式分为别 UPSPECIFIED ，未指定，父 View 对子 View 不做任何限制 EXACTLY，精确，父 View 给子 View 的大小是一个确定的值，为 Size AT_MOST，最大，父 View 给子 View 的大小 是一个不确定的值,最大为 Size 具体的计算就在下面的方法中 12345678910111213141516171819protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //这里的第一个参数就是 父View 的 MeasureSpec //第二个参数就是父 View 对子View 的位置限制 padding //和 子View 对自己的位置限制 margin 和 已使用的宽度 widthUsed //第三参数就是 xml 指定的子 View 宽度 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 在父 View 的 MeasureSpec 确定后，会传递给子 View ,子View 就会根据这个 MeasureSpec 和自己的 LayoutParams 属性，计算出自己的 MeasureSpec 和 大小(即 Size)，然后就会将这个 MeasureSpec 传递给子View 的 子View, 从而遍历测量完所有的 View。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //父 View 减去一个 宽度/高度位置限制 就是 父View 给 子View 的 大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us //父 View 是 EXACTLY case MeasureSpec.EXACTLY: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.EXACTLY; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us //父 View 是 AT_MOST case MeasureSpec.AT_MOST: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //使用父 View 给的 resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be //父 View 是 UNSPECIFIED case MeasureSpec.UNSPECIFIED: // 子View 是 xxdp if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; //使用 子View 指定的 resultMode = MeasureSpec.EXACTLY; // 子 View 是 MATCH_PARENT &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; 默认为 0 resultMode = MeasureSpec.UNSPECIFIED; //子 View 是 WRAP_CONTENT &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; 默认为 0 resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType //将 Mode 和 Size 包装成 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 子View 的 MeasureSpec 确定就是上述过程，这个过程可用下图表示理解这个图只需要注意下面几点 只要子 View 是 xxdp 的，不管父View 是什么模式，子 View 都是使用自己的指定的大小 childDimension. 如果父 View 是 确定的 (EXACTLY)，那么 子View 是 MATCH_PARENT 也就是充满父 View 的话，子View 也是确定的 EXACTLY ；如果子 View 是 WRAP_CONTENT，那么子 View 就是不确定的，但是不能超过父 View 的大小，因此子View 就是 AT_MOST 。 如果父 View 是不确定的 (AT_MOST )，那么不管子View 是 MATCH_PARENT 还是 WRAP_CONTENT ，子 View 都是不确定的。 如果父 View 是未指定的 (UNSPECIFIED)，那么子 View 也是未指定的，size 也就没意义，即为 0 。 (二).三个流程View 的三个流程都都是从 ViewRootImpl 的 performTraversals 开始的，而且都是从 DecorView 开始的，这里就不对具体的情况进行梳理，而是从宏观的角度却分析，三个流程是如果在 ViewGroup 到其中的子View 中进行工作的。 1.measure123456789private void performTraversals() &#123;...int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);...performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);... &#125; 12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; 在上述过程中,因为第一个 measureSpec 的产生总是布满全屏的, 即 measureSpec 是确定的 EXACTLY, size 就为屏幕大小.在 performMeasure 就会开始对 DecorView (也就是一个 ViewGroup ) 进行测量. 123456789101112private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try &#123; //对 DecorView 开始测量 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 因为 ViewGroup 继承自 View ,首先看 View 的 measure12345678910public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... &#125; 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;//测量自己的大小,一旦完成,View 的测量也就结束,这是 View 默认的方法,具体不同的 View 会有不同的测量方式. setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 在 View 中 measure 是一个 final 方法,因此不能被重写,在里面会调用 onMeasure 方法,这个方法就可以被重写,接下看 具体的某一个的 ViewGroup ( FrameLayout )中的这个方法. 123456789101112131415161718@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); ... for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); ... &#125; &#125; ... setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); ...&#125; 在 FrameLayout 中的 onMeasure 首先会对去调用 measureChildWithMargins 去计算自己的 MeasureSpec 然后就去测量子 View 的大小,等所有的子 View 测量好了,就会测量自己的的大小.而子 View 会重复这个两个方法,最后完成所有 View 的 测量.这个流程如图所示: 2.layout12345678910111213private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125; 在 performLayout 会直接 调用 host 的 layout ,这个 host 实际上就是 DecorView ,DecorView 是一个 ViewGroup ,首先看 ViewGroup 的 layout 方法.123456@Override public final void layout(int l, int t, int r, int b) &#123; ... super.layout(l, t, r, b); ... &#125; 1234@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 在 ViewGroup 中 layout 是一个 final 的方法,在里面会调用父类的layout 方法,也就是 View 的 layout 方法.这里先说明 onLayout 方法,在这里是一个抽象方法,因为不同的 ViewGroup 对子 View 的位置安排是不一样的,因此具体的 onLayout 需要具体的继承类去实现.先看 View 中的 layout 方法123456789101112131415161718@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;) public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame 确定自己的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); .... if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //调用 onLayout onLayout(changed, l, t, r, b); ... &#125; 首先在 layout 方法中会确定自己的位置,即 left,top,bottom,right 这个四个属性,接着就会调用 onLayout ,如果这是一个 View,那么 onLayout 就是一个空方法,如果这是一个 ViewGroup ,那么在这方法内就会去确定 子View 的位置.比如 FrameLayout 中.1234567891011121314@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125;void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); ... ... child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; 这部分的流程如图: 3.drawdraw 的绘制基本就包含五个步骤: 绘制背景 绘制自己的内容 绘制子 View 绘制foreground，比如滚动条 绘制一些高光 这个过程对于 View 和 ViewGroup 是一样的,只不过 View 中 不会绘制自己的子 View ,因此是个 dispatchDraw(canvas) 在这里是个空方法.具体的流程如图:]]></content>
      <tags>
        <tag>Android View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android----Window 窗口机制]]></title>
    <url>%2F2018%2F07%2F18%2FAndroid-Window%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一.前言Window 在 Android 有两种含义，一种是狭义的，一种是广义的。狭义的 Window 指的是 Window 这个抽象类，它的唯一的实现是 PhoneWindow 。广义的 Window 指的是 Android 中表示的窗口的概念，所谓的 Window 窗口机制实际上说的是广义的 Window ，在 Android 中窗口具体可以划分为 三种： 应用程序窗口：对应 Activity 显示的视图 子窗口：对应 Dialog ,PopupWindow ，Menu 等 系统窗口：对应 StatusBar ，Toast ,输入法键盘等 在 Window 窗口机制中，这三种类型就统称为 Window ，因为它们的作用就是显示某种视图，因此一般说的 Window 没有说明都指的是广义的 Window。 二.Window 的管理 Window 的管理涉及到应用进程和系统服务进程之间的通信，这里分为两个方面进行说明。 (一).在应用进程涉及的几个类1.ViewManager 这是一个接口，里面只有三个方法，定义了对 View ( 也就是所说的视图 )的基本操作，添加，刷新和移除 123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 2.WindowManager这也是一个接口，继承 ViewManager，负责对 Window 进行管理，和操作。每一个 Window 都持有这个对象，用于对自己窗口内部的 View 进行操作。这里还有一个静态的内部类 LayoutParams, 这个类定义 Window 的一些属性，窗口的类别和显示顺序。属性指的是窗口大小，位置，状态等信息，而窗口的类别就是前言中说的三种，这是通过设置 type 值显示的，每个类别有一个范围的 type 值，而显示顺序也是根据 type 值来确定的， type 值越高就越前，也就是越靠近用户。 应用程序窗口的 type ：1 ~ 99 子窗口的 type : 1000 ~ 1999 系统窗口 type : 2000 ~ 2999 123456789101112131415161718192021222324252627282930313233@SystemService(Context.WINDOW_SERVICE)public interface WindowManager extends ViewManager &#123; ... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; ... // 应用程序窗口 public static final int FIRST_APPLICATION_WINDOW = 1; public static final int TYPE_BASE_APPLICATION = 1; public static final int TYPE_APPLICATION = 2; public static final int TYPE_APPLICATION_STARTING = 3; public static final int TYPE_DRAWN_APPLICATION = 4; public static final int LAST_APPLICATION_WINDOW = 99; //子窗口 public static final int FIRST_SUB_WINDOW = 1000; public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1; public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2; public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3; public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5; public static final int LAST_SUB_WINDOW = 1999; //系统窗口 public static final int FIRST_SYSTEM_WINDOW = 2000; public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW; public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1; public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2; ... public static final int LAST_SYSTEM_WINDOW = 2999; &#125;&#125; 3.WindowManagerImplWindowManager 的实现类，持有 Window 类型的变量，因而对 Window 的操作会在这里调用，但是对 View 的三个操作并没有在这里实现，而是由成员变量 WindowManagerGlobal 类型的 mGlobal 去执行。1234567891011121314@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ... mGlobal.updateViewLayout(view, params);&#125;@Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; 4.WindowManagerGlobal 这个类虽然没有实现 ViewManager ，但是它在这里同样定义了这三种操作，同时它还有几个重要的变量。而对于具体的 View 的操作，这里也没有实现而是交由 ViewRootImpl 去实现。12345678910111213141516171819202122public final class WindowManagerGlobal &#123; ... private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;(); 所有 Window 对应的 View private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;(); //所有 Window 对应的 ViewRootImpl 。 private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 所有 Window 的属性参数 private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); //已经执行 remove 方法但是还未真正完成删除的 View 。 ... public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... &#125; public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; ... &#125; public void removeView(View view, boolean immediate) &#123; ... &#125;&#125; 5.ViewRootImplViewRootImpl 是连接 Window 和 View 关系的桥梁。有三个方面的作用： 一是管理 View 树，并完成 View 的绘制三大流程 二是管理 Surface 并对输入事件的的转发。 三是与 WMS ( WindowManagerServer )进行进程间的通信。它有两个重要的变量： IWindowSession mWindowSession ： Binder 对象，服进程在 应用程序进程中的代理对象，用于调用服务进程中的方法。在 WMS 中的是是实现为 Session 。 W mWindow ： Binder 对象，用于服务进程的调用应用进程的方法。主要是 WMS 添加Window 成功后在 Window 进行显示或者其他操作。 6.DecorView ，mNextView，mDecor 等DecorView 对于大家可能比较熟悉，这是 Activity 视图中的“根视图”，而其他两个则是 Toast 和 Dialog 的根视图。这看起来好像每种窗口类型都有自己的“根视图”，事实上的确是这样的，我们都知道 Window 实际上就是为了显示各种各样的视图，因此一个 Window 中就可能会有多个 View, 而使用“根视图”则提供了结构上方便，所有的 View 都是以“根视图”来进行添加删除等的，因此便于 WindowManager 对窗口进行管理。在 Activity 中 DecorView 是PhoneWindow 的一个变量，但是并不是所有的窗口都会使用 PhoneWindow 和 抽象接口 Window。整体的体系如图： 点击查看大图 (二).创建 Window ( 在应用进程 )在了解了上面几个概念后，下面就以实际的例子进行说明，虽然不同类型的窗口在创建 Window 的时候整体机制是一样的，即通过 WindowManager 进行管理，但是在一些具体的方面还有有差别的。 1.Activity 的窗口创建和 setContentView在 Activity 启动过程中的最后一步 Activity 实例创建完后会需要调用 attach 方法关联上下文，在这里会创建 Window 对象。123456789final void attach(...)&#123; ... mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ...&#125; 在创建完 Window 后就需要往这个 Window 添加一个最低层的 View 用于管理以后的所有的 View,没错这个 View 就是 DecorView。DecorView 实际上是一个 FrameLayout ，它里面有一个 LinearLayout , LinearLayout 有两个子元素，一个是 的 actionbar ， 一个就是 FrameLayout 的 content 。setContentView 就是在这个 FrameLayout 里添加我们的 LayoutView.在这之前需要先创建 DecorView 。 1234567@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; 首先这里 mContentParent 就是 FrameLayout 的 content 。因为是第一次创建为 null, 就要初始化 DecorView12345678910111213private void installDecor() &#123; ... if (mDecor == null) &#123; mDecor = generateDecor(-1); ... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); &#125; ...&#125; 123456protected ViewGroup generateLayout(DecorView decor) &#123; ... ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); ... return contentParent;&#125; 在初始化DecorView 后就会加载 Content View ,并添加到 DecorView .这里的 ID_ANDROID_CONTENT 实际上就是 com.android.internal.R.id.content，在 layout 文件中可以看到 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 在上述步骤中只是创建了 Window 实例， 只是将 View 添加到 DecorView ，但是真正的 Window 的添加还未实现，而具体的实现在之前说过是由 WindowManager 进行操作的，这一步在 hanldeResumeActivity 中。12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 在 WindowManager 的 addView 方法中就会见到之前说的几个对象的层层调用，一直到 ViewRootImpl， 这个过程如图所示：在 ViewRootImpl 会先调用 requestLayout 对View 进行绘制，然后调用 addToDisplay 添加到 Window 中。这两个方法都涉及与 WMS 的通信，具体则是由 WindowSession 实现，下面就介绍 Window 创建过程中和 WMS 的通信的部分。 (三).在 SystemServer 进程涉及的几个类1.WindowManagerServerWindowManagerServer 是 Android 系统中负责处理 Window 和 View 相关的 系统服务，主要有如下几个职责： 对所有的 Window 进行添加，删除等管理。这部分主要涉及 DisplayContent，WindowToken 和 WindowState 这几个对象。 对View 进行绘制，这里需要为每个窗口分配 Surface 一个 Surface 就是一个对象，该对象持有一群像素（pixels），这些像素是要被组合到一起显示到屏幕上的。每一个 window 都有唯一一个自己的 surface，window 将自己的内容绘制到该 surface 中。 Surface Flinger 根据各个 surface 在 Z 轴上的顺序 （Z-order） 将它们渲染到最终的显示屏上,z 轴就是以屏幕为平面，由里到外的一个轴向，而屏幕就是 x 和 y 轴组成的平面。 对从输入系统 InputManagerService 传过来的触摸事件寻找合适的窗口进行处理。 对 Window 的动画效果的管理，这主要是由 WindowAnimator 对象进行管理。 2.WindowState用于保存窗口的信息，窗口的信息是可以随时改变的，比如窗口的位置，大小等变化，通常窗口信息的改变，就会进行相应的 View 的改变。WindowState 是保持在一个 Map 里面，这个 Map 保存着系统所有的窗口。 3.AppWindowToken/WindowTokenAppWindowToken 是 WindowToken 的 子类，可以译为令牌，一个 Activity 对应一个 WindowToken, 当应用进程向 WMS 发出创建 Window 的申请的时候需要出示正确的令牌。这里需要注意子窗口通常需要依赖于父窗口才能添加，比如在 Activity 上显示 Dialog 或者 Menu ,因此子窗口通常使用的是父窗口的 WindowToken ，这就是为什么创建 Dialog 的时候关联的上下文不能使用 ApplicationContext ,因为 application 没有 WindowToken. (四).创建 Window ( 在 Server 进程 )在了解了服务端几个类后，下面就是 Window 的创建在 Server 端的过程，首先回到之前的在 ViewRootImpl 的两个方法，requestLayout 方法调用后在 SystemServer 会进行一个 Surface 的创建和绘制，之后就会 view 的绘制。这里属于 Surface 的创建过程，这里就不进行展开，在绘制完成后就会执行 addWindow 方法.addWindow 的源码很长，主要是做一下几个部分：1.对窗口的参数进行检查，比如窗口的类型，窗口的 WindowToken.输入法这种没有 WindowToken 的系统自己会创建一个 windowToken。2.创建 WindowState 对象，将 WindowToken 和 WindowState 关联起来并添加到 HashMap。3.将窗口按照 z 轴的位置添加到 DisPlayContent 的合适的位置。.最后就是窗口的位置，动画等信息保存下来。这样一个窗口创建成功。 (五).Dialog 的 Window 创建Dialog 是一个子窗口，需要依赖于父窗口才能显示。12345678910Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; ... mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; ... w.setWindowManager(mWindowManager, null, null); &#125; 123456789@Override public Object getSystemService(@ServiceName @NonNull String name) &#123; if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; &#125; return super.getSystemService(name); &#125; Dialog 会创建自己的 Window 对象，然后就会在 Activity 的 getSystemService 方法中可以拿到 Activity 的 mWindowManager 对象,这样 Dialog 就会和 Activity 有一样的 Token 。接着看 show 方法。 1234567public void show() &#123; ... mDecor = mWindow.getDecorView(); ... mWindowManager.addView(mDecor, l);&#125; 之前说过所有的 Window 都有一个“根视图”用于对 所有的View 进行管理，在 Dialog 中就对应 mDecor，可以看到同样的，mWindowManager 会调用 addView 执行窗口的添加工作。 后面的过程基本和上述的 setContentView 的过程相似。 (六).Toast 的 Window 创建Toast 是一个系统级的窗口，因此在创建的过程中就有些不同。这里涉及到了几个新的对象 (1)涉及的几个对象1.NotificationManagerService ( NMS )这是一个系统服务，用于管理系统通知，因此也负责 Toast 的管理，其中有几个重要的成员 ArrayList mToastQueue ，这是保存系统中所有 Toast 的队列，每个非系统应用的 Toast 在这个队列的数量不能超过 50 个，这样做是避免网络攻击。 拒绝服务攻击 简称：DoS，也叫洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 WorkerHandler 用于处理 Toast 的显示时间，即在 Toast 显示过后发送一个 延迟的消息进行取消。 1. TN这是 Toast 的内部类，继承自 ITransientNotification.Stub ,因此可以跨进程通信，用于处理 Toast 窗口的创建和 View 的添加。 (2)Toast 的 Window 创建过程首先看 makeText 方法 123456789101112131415public static Toast makeText(@NonNull Context context, @Nullable Looper looper, @NonNull CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context, looper); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result;&#125; 这里的 mNextView 就是 Toast “根视图”，可以看到这个 mNextView 有一个 TextView 用于显示 Toast 的文本信息。 接着看 show 方法 12345678910111213public void show() &#123; ... INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 在 Toast 方法中会调用 NMS 的 enqueueToast ，这就到 NMS 服务中。在 NMS 服务中会将 Toast 封装为 ToastRecord ,并添加到 mToastQueue 队列中。一直到 从队列中取出进行显示的时候就会调用 TN 的 show 方法，并发送一个延迟的消息。12345678@GuardedBy(&quot;mToastQueue&quot;) private void scheduleTimeoutLocked(ToastRecord r) &#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); &#125; SHORT_DELAY = 2 s LONG_DELAY = 3.5 s接着先看 TN 的 show 方法 12345 @Override public void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(SHOW, windowToken).sendToTarget();&#125; 1234567891011mHandler = new Handler(looper, null) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SHOW: &#123; IBinder token = (IBinder) msg.obj; handleShow(token); break; &#125;... 1234567891011 public void handleShow(IBinder windowToken) &#123; ... mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); ... mWM.addView(mView, mParams); ... &#125; catch (WindowManager.BadTokenException e) &#123; /* ignore */ &#125; &#125;&#125; 依次从三个方法看下来就可以知道 TN 的 show 最后会调用 WindowManager 的 addView 方法，这里可以看到 为了调用 handleShow 方法这里使用了 Handler 。这是因为 NMS 调用 TN 的方法是一种跨跨进程的方式，show 方法就运行在 Binder 线程池中，因此需要使用 Handler 回到 Toast 的线程去调用 addView 方法。现在回到 NMS 中，之前发送了个延迟的消息，然后过了相应的时间后就会对这个消息进行处理，也就是将 Toast 窗口删除。 12345678910@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_TIMEOUT: handleTimeout((ToastRecord)msg.obj); //跳到下面 ... &#125; &#125; 12345678910private void handleTimeout(ToastRecord record)&#123; if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) &#123; int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) &#123; cancelToastLocked(index);//跳到下面 &#125; &#125;&#125; 123456789101112131415161718@GuardedBy(&quot;mToastQueue&quot;) void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide(); // 执行 hide &#125; catch (RemoteException e) &#123; ... &#125; ToastRecord lastToast = mToastQueue.remove(index);//移除队列 mWindowManagerInternal.removeWindowToken(lastToast.token, true, DEFAULT_DISPLAY);//删除对应 窗口 keepProcessAliveIfNeededLocked(record.pid); if (mToastQueue.size() &gt; 0) &#123; ... showNextToastLocked(); // 如果队列中还有就继续执行 &#125; &#125; 在延迟的消息到达后就会执行 hide 方法，这个过程和添加实际上是相似的，这里就不再说明。接着将 Toast 从队列中删除，并进行窗口的删除，接着判断队列中是否还有 Toast ，如果就继续执行。具体的过程可看下图：点击查看大图最后再补充一点，前面提到过 为了使 TN 的 show 方法切换到 对应的线程而使用了 Hanler ,而其中 Handler 的 Looper 是这样的12345678if (looper == null) &#123; // Use Looper.myLooper() if looper is not specified. looper = Looper.myLooper(); if (looper == null) &#123; throw new RuntimeException( &quot;Can&apos;t toast on a thread that has not called Looper.prepare()&quot;); &#125; &#125; 这就说明当不指定 looper 的时候，默认的是主线程 Looper 。但是如果在 子线程中指定该线程的 Looper ，并调用 Looper.prepare() 方法，就可以在子线程中调用 Toast 的 show 方法。参考《Android 开发艺术探索》 Android解析WindowManager Android解析WindowManagerService]]></content>
      <tags>
        <tag>Android Framework</tag>
      </tags>
  </entry>
</search>
