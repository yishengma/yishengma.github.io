<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="Android 框架," />










<meta name="description" content="一.前言在 Android 中，网络请求是一个必不可少的功能，因此就有许多代表网络请求客户端的组件库，具有代表性的有下面三种：  Apache 的 HTTP 客户端组件 HttpClient。 Java  JDK 自带的 HttpURLConnection  标准库。 重写应用层代码的 HTTP 组件库。  HttpClient这是 Android 6.0 之前经常会使用的 API ,但是因为不支">
<meta name="keywords" content="Android 框架">
<meta property="og:type" content="article">
<meta property="og:title" content="网络请求框架----OkHttp原理">
<meta property="og:url" content="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/index.html">
<meta property="og:site_name" content="海盗的帽子的博客">
<meta property="og:description" content="一.前言在 Android 中，网络请求是一个必不可少的功能，因此就有许多代表网络请求客户端的组件库，具有代表性的有下面三种：  Apache 的 HTTP 客户端组件 HttpClient。 Java  JDK 自带的 HttpURLConnection  标准库。 重写应用层代码的 HTTP 组件库。  HttpClient这是 Android 6.0 之前经常会使用的 API ,但是因为不支">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/1.png">
<meta property="og:image" content="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/2.png">
<meta property="og:image" content="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/3.png">
<meta property="og:updated_time" content="2018-12-25T13:21:12.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络请求框架----OkHttp原理">
<meta name="twitter:description" content="一.前言在 Android 中，网络请求是一个必不可少的功能，因此就有许多代表网络请求客户端的组件库，具有代表性的有下面三种：  Apache 的 HTTP 客户端组件 HttpClient。 Java  JDK 自带的 HttpURLConnection  标准库。 重写应用层代码的 HTTP 组件库。  HttpClient这是 Android 6.0 之前经常会使用的 API ,但是因为不支">
<meta name="twitter:image" content="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/"/>





  <title>网络请求框架----OkHttp原理 | 海盗的帽子的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">海盗的帽子的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yishengma.github.io/2018/10/02/网络请求框架-OkHttp原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海盗的帽子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/d.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海盗的帽子的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络请求框架----OkHttp原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T17:23:19+08:00">
                2018-10-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-12-25T21:21:12+08:00">
                2018-12-25
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2018/10/02/网络请求框架-OkHttp原理/" class="leancloud_visitors" data-flag-title="网络请求框架----OkHttp原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>在 Android 中，网络请求是一个必不可少的功能，因此就有许多代表网络请求客户端的组件库，具有代表性的有下面三种：</p>
<ul>
<li>Apache 的 HTTP 客户端组件 HttpClient。</li>
<li>Java  JDK 自带的 HttpURLConnection  标准库。</li>
<li>重写应用层代码的 HTTP 组件库。</li>
</ul>
<h6 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h6><p>这是 Android 6.0 之前经常会使用的 API ,但是因为不支持 HTTP/2，支持 HTTP/2 的版本还处于 beta 阶段，不适合用于 Android APP 中使用，所以 Google  在 6.0 版本里面删除了 HttpClient 相关 API。</p>
<h6 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h6><p>这是 Java 自带的一个组件，不需要引入依赖就可以使用，同样这个组件库也无法支持 HTTP/2, 支持的版本也要到 Java 9 后才行。同时这个标准库 封装层次太低，并且支持特性太少，缺乏连接池管理，域名机制控制等特性，因此在 Android 中使用就会相当繁琐。</p>
<h6 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h6><p>上述两个组件都是不支持 HTTP/ 2 ,但是 HTTP/2 对于移动客户端而言，<br>无论是从握手延迟、响应延迟，<br>还是资源开销看都有相当吸引力，而且 OkHttp 在弱网和无网环境下有自动检测和恢复机制,这使得 OkHttp 成为 Android 最常见的网络请求库。</p>
<h2 id="二-简介"><a href="#二-简介" class="headerlink" title="二.简介"></a>二.简介</h2><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a> 是一个支持 HTTP 和 HTTP/2  的封装的网络请求客户端，适用于 Android 和 java 应用程序。OkHttp 有如下优点：</p>
<ul>
<li>支持 HTTPS/HTTP2/WebSocket</li>
<li>内部维护任务队列线程池，支持 HTTP/2 的并发访问</li>
<li>内部维护连接池，支持 HTTP/1.x 的 keep-Alive 机制，也支持 HTTP/2 的多路复用， 减少连接创建开销。</li>
<li>通过缓存避免重复的请求</li>
<li>请求失败时自动重试主机的其他ip，自动重定向。</li>
</ul>
<h2 id="三-原理"><a href="#三-原理" class="headerlink" title="三.原理"></a>三.原理</h2><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>OkHttp 的使用初始化有两种方式。</p>
<ul>
<li>默认方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient mOkHttpClient = new OkHttpClient();</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义配置方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout()</span><br><span class="line">                .writeTimeout()</span><br><span class="line">                .readTimeout()</span><br><span class="line">                .cache()</span><br><span class="line">                .addInterceptor()</span><br><span class="line">                .connectionPool()</span><br><span class="line">                .dns()</span><br><span class="line">                ...</span><br><span class="line">                ;</span><br><span class="line">                </span><br><span class="line">  OkHttpClient   mOkHttpClient = builder.build();</span><br></pre></td></tr></table></figure>
<p>不管是哪种方式，对于 OkHttp 来说都是初始化一些配置，因为这里的参数十分多，所以这里使用的 Builder 设计模式进行简化。Builder 初始化的对象主要有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public OkHttpClient() &#123;</span><br><span class="line">    this(new Builder());</span><br><span class="line">  &#125;</span><br><span class="line">public Builder newBuilder() &#123;</span><br><span class="line">    return new Builder(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">public static final class Builder &#123;</span><br><span class="line">    public Builder() &#123;</span><br><span class="line">      dispatcher = new Dispatcher(); //请求的调度器</span><br><span class="line">      protocols = DEFAULT_PROTOCOLS; // 默认支持的协议</span><br><span class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS; // 默认连接配置</span><br><span class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE); // 对于请求和回调的监听</span><br><span class="line">      proxySelector = ProxySelector.getDefault(); // 代理服务器的选择</span><br><span class="line">      cookieJar = CookieJar.NO_COOKIES; // 默认没有 Cookie </span><br><span class="line">      socketFactory = SocketFactory.getDefault(); // Socket 的工厂</span><br><span class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE; //主机名认证</span><br><span class="line">      certificatePinner = CertificatePinner.DEFAULT; // 安全认证相关的配置</span><br><span class="line">      proxyAuthenticator = Authenticator.NONE; // 安全认证相关的配置</span><br><span class="line">      authenticator = Authenticator.NONE; // 安全认证相关的配置</span><br><span class="line">      connectionPool = new ConnectionPool();  //连接池</span><br><span class="line">      dns = Dns.SYSTEM;   // DNS 域名解析系统</span><br><span class="line">      followSslRedirects = true; // 允许SSL重定向</span><br><span class="line">      followRedirects = true; //  允许重定向</span><br><span class="line">      retryOnConnectionFailure = true;  // 允许失败重连</span><br><span class="line">      connectTimeout = 10_000;   // 连接超时 ， 10 s</span><br><span class="line">      readTimeout = 10_000;   //  读取 超时 ，10 s </span><br><span class="line">      writeTimeout = 10_000;  // 写入超时，10s</span><br><span class="line">      pingInterval = 0; //ping  间隔时间，这是 WebSocket 长连接的活性检测的间隔时间 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面这些配置都是 OkHttpClient  的默认属性，当然也可以使用自己自定义的属性。而且可以看到每一次初始化都会创建新的的 Builder ，因此也会重新创建一个连接池，调度器等耗资源的类，因此在使用 OkHttpClient 通常使用的单例模式，使得整个系统只有一个 请求调度器和连接池，减少资源的消耗。</p>
<h4 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2.发起请求"></a>2.发起请求</h4><p>先看一个请求的创建的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request.Builder requestBuilder = new Request.Builder().url(url);</span><br><span class="line"> requestBuilder.method(&quot;GET&quot;, null);</span><br><span class="line">  Request request = requestBuilder.build();</span><br></pre></td></tr></table></figure>
<p>可以看到这里同样的是使用 Builder 的模式来创建一个 Request 请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class Request &#123;</span><br><span class="line">  final HttpUrl url;</span><br><span class="line">  final String method;</span><br><span class="line">  final Headers headers;</span><br><span class="line">  final RequestBody body;</span><br><span class="line">  final Object tag;</span><br><span class="line"></span><br><span class="line">  private volatile CacheControl cacheControl; // Lazily initialized.</span><br><span class="line"></span><br><span class="line">  Request(Builder builder) &#123;</span><br><span class="line">    this.url = builder.url;</span><br><span class="line">    this.method = builder.method;</span><br><span class="line">    this.headers = builder.headers.build();</span><br><span class="line">    this.body = builder.body;</span><br><span class="line">    this.tag = builder.tag != null ? builder.tag : this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>Request 主要是对请求的 Url ,请求方法，请求头，请求体，以及缓存首部字段的一个封装而已。对于一个网络请求的， OkHttp 有两种执行的方式：</p>
<ul>
<li>同步的：executed，这种方式不能在 主线程中调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<ul>
<li>异步的 enqueue(responseCallback)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">okHttpClient.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-处理请求"><a href="#3-处理请求" class="headerlink" title="3.处理请求"></a>3.处理请求</h4><p>在 OkHttp 中一个请求的处理主要是由 dispatcher 分发器负责,先看 Dispatcher 类主要有什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Dispatcher &#123;</span><br><span class="line">  private int maxRequests = 64;  //最大并发的请求数 为 64 </span><br><span class="line">  private int maxRequestsPerHost = 5;  //每个主机最大请求数为 默认为 5 </span><br><span class="line">  private Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  /** Executes calls. Created lazily. */</span><br><span class="line">  private ExecutorService executorService;  //请求处理的线程池</span><br><span class="line"></span><br><span class="line">  /** Ready async calls in the order they&apos;ll be run. */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();   //异步处理的准备队列</span><br><span class="line"></span><br><span class="line">  /** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line">  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //异步处理的执行队列</span><br><span class="line"></span><br><span class="line">  /** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</span><br><span class="line">  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();  //同步处理的执行队列</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是对于同步请求，使用一个 队列进行保存。对于异步的请求，有一个准备的队列和一个正在执行的队列进行保存。因为同步的方式还是在 主线程中运行，因此没有使用到线程池，而对于异步的方式，OkHttp 使用了线程池对异步请求进行管理。</p>
<p>在一个请求发起之后就是对请求的处理，因为处理请求的方式有同步和异步两种，所以具体的实现也有所不同，下面先看 同步的方式：</p>
<h5 id="1-同步请求的方式"><a href="#1-同步请求的方式" class="headerlink" title="(1)同步请求的方式"></a>(1)同步请求的方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // okHttpClient 类中</span><br><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">   return new RealCall(this, request, false /* for web socket */);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   // RealCall 类中，实现 Call 接口</span><br><span class="line">  final class RealCall implements Call &#123;</span><br><span class="line">   ...</span><br><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">      executed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    try &#123;</span><br><span class="line">      client.dispatcher().executed(this);  //添加到请求队列中</span><br><span class="line">      Response result = getResponseWithInterceptorChain();  //拦截链，对应的一系列方法调用包括请求，得到响应后返回</span><br><span class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      client.dispatcher().finished(this); //结束这个请求</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  //Call 接口</span><br><span class="line">public interface Call extends Cloneable &#123;</span><br><span class="line"></span><br><span class="line">  Request request();</span><br><span class="line"></span><br><span class="line">  Response execute() throws IOException;</span><br><span class="line">  </span><br><span class="line">  void enqueue(Callback responseCallback);</span><br><span class="line">  </span><br><span class="line">  boolean isExecuted();</span><br><span class="line"></span><br><span class="line">  boolean isCanceled();</span><br><span class="line"></span><br><span class="line">  Call clone();</span><br><span class="line"></span><br><span class="line">  interface Factory &#123;</span><br><span class="line">    Call newCall(Request request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将 Request 封装为一个 RealCall, 这个 RealCall 实现了 Call 接口，在 Call 接口中可以看到里面既有 Request 也有 Response ，显然 Call 接口定义的就是一次 网络请求和其对应的响应的抽象。</p>
<p>在 RealCall 类中一个请求的处理步骤主要是分为三步：</p>
<ul>
<li>client.dispatcher().executed(this); 添加到队列。</li>
<li>getResponseWithInterceptorChain(),发起拦截链，同时得到响应后返回。</li>
<li>client.dispatcher().finished(this);结束这个请求。</li>
</ul>
<h6 id="dispatcher-executed-this-client-dispatcher-finished-this"><a href="#dispatcher-executed-this-client-dispatcher-finished-this" class="headerlink" title="dispatcher().executed(this) / client.dispatcher().finished(this)"></a>dispatcher().executed(this) / client.dispatcher().finished(this)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */</span><br><span class="line">  synchronized void executed(RealCall call) &#123;</span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/** Used by &#123;@code Call#execute&#125; to signal completion. */</span><br><span class="line"> void finished(RealCall call) &#123;</span><br><span class="line">   finished(runningSyncCalls, call, false);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">   int runningCallsCount;</span><br><span class="line">   Runnable idleCallback;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">     if (promoteCalls) promoteCalls(); //对于 executed 方式，这里为false 所以不执行 promoteCalls</span><br><span class="line">     runningCallsCount = runningCallsCount();</span><br><span class="line">     idleCallback = this.idleCallback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">     idleCallback.run();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对于同步方式，添加队列就是将请求添加到同步执行的队列，然后就调用拦截器链得到请求后就结束这个 Call 。结束的时候就直接从队列中移除。</p>
<h5 id="1-异步请求的方式"><a href="#1-异步请求的方式" class="headerlink" title="(1)异步请求的方式"></a>(1)异步请求的方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override public void enqueue(Callback responseCallback) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">     executed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   captureCallStackTrace();</span><br><span class="line">   client.dispatcher().enqueue(new AsyncCall(responseCallback));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里将回调的接口封装在 AsyncCall 类里面,这个类继承了 NamedRunnable 抽象类，然后就执行 调度器的分发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NamedRunnable implements Runnable &#123;</span><br><span class="line">  protected final String name;</span><br><span class="line"></span><br><span class="line">  public NamedRunnable(String format, Object... args) &#123;</span><br><span class="line">    this.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public final void run() &#123;</span><br><span class="line">    String oldName = Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    try &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NamedRunnable 实现了 Runnable 接口，并在 run 方法中调用了抽象方法 execute ，那么也就是说 AsyncCall 的 execute 方法最终会在子线程中执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> // 实现 Runnable 接口</span><br><span class="line">final class AsyncCall extends NamedRunnable &#123;</span><br><span class="line">    private final Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">      this.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected void execute() &#123;</span><br><span class="line">      boolean signalledCallback = false;</span><br><span class="line">      try &#123;</span><br><span class="line">        Response response = getResponseWithInterceptorChain();  //拦截器链</span><br><span class="line">        if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));  //失败的回调</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          signalledCallback = true;</span><br><span class="line">          responseCallback.onResponse(RealCall.this, response);  //成功的回调</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          // Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher().finished(this);  //结束这个 Call </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 AsyncCall 的 方法中，首先就是通过拦截器链得到响应，然后对响应进行判断，如果成功就调用  responseCallback.onResponse ，失败就调用就  responseCallback.onFailure 。</p>
<p>在 RealCall 类中一个异步请求的处理步骤主要是分为三步：</p>
<ul>
<li>在主线程，client.dispatcher().executed(new AsyncCall(responseCallback)); 将 回调接口封装为 AsyncCall 后添加到队列中。</li>
<li>在run 方法中 getResponseWithInterceptorChain(),发起拦截链，同时得到响应后返回。</li>
<li>在run 方法中 ，client.dispatcher().finished(this);结束这个请求。</li>
</ul>
<h6 id="dispatcher-enqueue-new-AsyncCall-responseCallback"><a href="#dispatcher-enqueue-new-AsyncCall-responseCallback" class="headerlink" title="dispatcher.enqueue(new AsyncCall(responseCallback))"></a>dispatcher.enqueue(new AsyncCall(responseCallback))</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      runningAsyncCalls.add(call);</span><br><span class="line">      executorService().execute(call);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Returns the number of running calls that share a host with &#123;@code call&#125;. */</span><br><span class="line">  private int runningCallsForHost(AsyncCall call) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (AsyncCall c : runningAsyncCalls) &#123;</span><br><span class="line">      if (c.host().equals(call.host())) result++;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>判断 runningAsyncCalls 正在执行的队列的大小是否小于最大请求数量（最大线程数量、<br>并发数量）并且 所有的 AsyncCall 请求加起来是否小于最大主机请求限制。</p>
<ul>
<li>如否</li>
</ul>
<p>将 AsyncCalls 加入到 readyAsyncCalls，的准备队列</p>
<ul>
<li>如是</li>
</ul>
<p>加入到 runningAsyncCalls，正在执行的队列中 ，并加入线程池执行。</p>
<h6 id="最后-client-dispatcher-finished"><a href="#最后-client-dispatcher-finished" class="headerlink" title="最后 client.dispatcher().finished"></a>最后 client.dispatcher().finished</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */</span><br><span class="line"> void finished(AsyncCall call) &#123;</span><br><span class="line">   finished(runningAsyncCalls, call, true);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">   int runningCallsCount;</span><br><span class="line">   Runnable idleCallback;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">     if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">     if (promoteCalls) promoteCalls();  因为 为 true 所以还要执行 promoteCalls </span><br><span class="line">     runningCallsCount = runningCallsCount();</span><br><span class="line">     idleCallback = this.idleCallback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">     idleCallback.run();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">private void promoteCalls() &#123;</span><br><span class="line">   if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">   if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">   for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">     AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">     if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">       i.remove();</span><br><span class="line">       runningAsyncCalls.add(call);</span><br><span class="line">       executorService().execute(call);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对于异步请求的结束，首先 判断正在执行的队列 runningAsyncCalls 是否还有请求，有则返回继续请求，没有就判断准备队列 readyAsyncCalls 是否还有请求，没有则返回，有则添加到正在执行的队列,然后执行线程.</p>
<p><img src="/2018/10/02/网络请求框架-OkHttp原理/1.png" alt="image.png"></p>
<h4 id="4-拦截器链"><a href="#4-拦截器链" class="headerlink" title="4.拦截器链"></a>4.拦截器链</h4><p>OkHttp 基本上所有的核心功能都是由拦截器链完成的，包括缓存，网络请求获取响应等。在前面的代码中可以看到对于请求的响应的获取都是通过下面这行代码实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response response = getResponseWithInterceptorChain();</span><br></pre></td></tr></table></figure>
<p>下面就看拦截器链的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">   // Build a full stack of interceptors.</span><br><span class="line">   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">   interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">   interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = new RealInterceptorChain(</span><br><span class="line">       interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">   return chain.proceed(originalRequest);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其逻辑大致分为两部分：</p>
<ul>
<li>创建一系列拦截器，包括用户自定义的拦截器，并将其放入一个拦截器List中。</li>
<li>创建一个拦截器链 RealInterceptorChain, 并执行拦截器链的 proceed 方法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">    ....</span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    // 获取下一个拦截器，并调用其 intercept 方法。</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">   ....</span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拦截器的 intercept 方法里，以 RetryAndFollowUpInterceptor  为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">     // 对请求前的处理</span><br><span class="line">    streamAllocation = new StreamAllocation(</span><br><span class="line">        client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line"></span><br><span class="line">    int followUpCount = 0;</span><br><span class="line">    Response priorResponse = null;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response = null;</span><br><span class="line">      boolean releaseConnection = true;</span><br><span class="line">      try &#123;</span><br><span class="line">      //这里再去调用拦截器链的 proceed ，</span><br><span class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">     </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     // 下面就是对 得到响应后的处理，这里就省略。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 RealInterceptorChain 里会去执行拦截器链的 proceed 方法。而在拦截器链中又会执行下一个拦截器的 intercept 方法，在下一个拦截器的 intercept 中又会去执行拦截器链的 proceed ，此时 index + 1 。所以整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。这也是 OkHttp 拦截器的链式执行逻辑。而一个拦截器的 intercept 方法所执行的逻辑大致分为三部分：</p>
<ul>
<li>在发起请求前对request进行处理</li>
<li>调用下一个拦截器，获取response</li>
<li>对response进行处理，返回给上一个拦截器</li>
</ul>
<p>这就是 OkHttp 拦截器机制的核心逻辑。所以一个网络请求实际上就是一个个拦截器执行其intercept 方法的过程。而这其中除了用户自定义的拦截器外还有几个核心拦截器完成了网络访问的核心逻辑，按照先后顺序依次是：</p>
<ul>
<li>RetryAndFollowUpInterceptor</li>
<li>BridgeInterceptor</li>
<li>CacheInterceptor</li>
<li>ConnectIntercetor</li>
<li>CallServerInterceptor</li>
</ul>
<h5 id="1-RetryAndFollowUpInterceptor"><a href="#1-RetryAndFollowUpInterceptor" class="headerlink" title="(1)RetryAndFollowUpInterceptor"></a>(1)RetryAndFollowUpInterceptor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This interceptor recovers from failures and follows redirects as necessary. It may throw an</span><br><span class="line"> * &#123;@link IOException&#125; if the call was canceled.</span><br><span class="line"> */</span><br><span class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</span><br><span class="line">  /**</span><br></pre></td></tr></table></figure>
<p>从英文解释就连可以看出这个拦截器主要负责失败重传和在必要的时候进行重定向，当一个请求由于各种原因失败了，处理以得到新的Request，沿着拦截器链继续新的Request。</p>
<h5 id="2-BridgeInterceptor"><a href="#2-BridgeInterceptor" class="headerlink" title="(2)BridgeInterceptor"></a>(2)BridgeInterceptor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Bridges from application code to network code. First it builds a network request from a user</span><br><span class="line"> * request. Then it proceeds to call the network. Finally it builds a user response from the network</span><br><span class="line"> * response.</span><br><span class="line"> */</span><br><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br></pre></td></tr></table></figure>
<p>这个拦截器作为应用程序模块代码和网络请求模块代码的桥梁，首先会从使用者的 request 构建一个真正的网络请求，然后将这个请求提交给网络请求模块，最后就从网络请求模块返回的数据构建一个 response 给使用者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">   </span><br><span class="line">   Request userRequest = chain.request();</span><br><span class="line">   Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">   RequestBody body = userRequest.body();</span><br><span class="line">   if (body != null) &#123;</span><br><span class="line">     MediaType contentType = body.contentType();</span><br><span class="line">     if (contentType != null) &#123;</span><br><span class="line">       requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     long contentLength = body.contentLength();</span><br><span class="line">     if (contentLength != -1) &#123;</span><br><span class="line">       requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">       requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">       requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">   // the transfer stream.</span><br><span class="line">   boolean transparentGzip = false;</span><br><span class="line">   if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">     transparentGzip = true;</span><br><span class="line">     requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">   if (!cookies.isEmpty()) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //到这里网络请求前拦截的动作就已经完成，主要有：</span><br><span class="line">   // 设置内容长度，内容编码</span><br><span class="line">    // 设置gzip压缩</span><br><span class="line">    //添加cookie</span><br><span class="line">     //设置其他请求头首部，如 User-Agent,Host,Keep-alive 等。其中 Keep-Alive 是实现多路复用的必要步骤</span><br><span class="line">     //下面就到下一个拦截器去获取真正的网络响应。</span><br><span class="line">   </span><br><span class="line">   Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   // 获取网络的响应后，在这里也进行拦截，做一些处理，比如压缩，添加响应头等。</span><br><span class="line">   HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">   Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">       .request(userRequest);</span><br><span class="line"></span><br><span class="line">   if (transparentGzip</span><br><span class="line">       &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">       &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">     GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">     Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">         .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">         .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">         .build();</span><br><span class="line">     responseBuilder.headers(strippedHeaders);</span><br><span class="line">     responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return responseBuilder.build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>BridgeInterceptor 作为客户端和网络请求的桥梁，在这里将 Request  和 Response 做一个处理。主要有：</p>
<h6 id="1-在请求前拦截："><a href="#1-在请求前拦截：" class="headerlink" title="1.在请求前拦截："></a>1.在请求前拦截：</h6><ul>
<li>设置内容长度，内容编码</li>
<li>设置gzip压缩</li>
<li>添加cookie</li>
<li>设置其他请求头首部，如 User-Agent,Host,Keep-alive 等。其中 Keep-Alive 是实现多路复用的必要步骤</li>
</ul>
<h6 id="2-调用下一个拦截器去获取响应"><a href="#2-调用下一个拦截器去获取响应" class="headerlink" title="2.调用下一个拦截器去获取响应"></a>2.调用下一个拦截器去获取响应</h6><h6 id="3-获取响应后再次拦截"><a href="#3-获取响应后再次拦截" class="headerlink" title="3.获取响应后再次拦截"></a>3.获取响应后再次拦截</h6><ul>
<li>压缩</li>
<li>添加/删除响应首部字段</li>
</ul>
<h5 id="3-CacheInterceptor"><a href="#3-CacheInterceptor" class="headerlink" title="(3)CacheInterceptor"></a>(3)CacheInterceptor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Serves requests from the cache and writes responses to the cache. */</span><br><span class="line">public final class CacheInterceptor implements Interceptor &#123;</span><br></pre></td></tr></table></figure>
<p>CacheInterceptor 主要是负责读取缓存和更新缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Response cacheCandidate = cache != null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line"></span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">     </span><br><span class="line">     // 获取定义响应读取的策略，分为仅从网络获取响应，仅从缓存获取响应，或者网络和缓存配合。</span><br><span class="line">    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">      cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">    //如果指定仅从缓存获取但是缓存没有就返回一个  504 </span><br><span class="line">    if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">      return new Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(504)</span><br><span class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-1L)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">    //如果没有指定从网络获取并且缓存不为空，那么就将缓存返回。</span><br><span class="line">    if (networkRequest == null) &#123;</span><br><span class="line">      return cacheResponse.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //去网络获取响应</span><br><span class="line">    Response networkResponse = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">      if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">    //必要的时候更新缓存，并返回</span><br><span class="line">    if (cacheResponse != null) &#123;</span><br><span class="line">      if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">        networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">        // Update the cache after combining headers but before stripping the</span><br><span class="line">        // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">        cache.trackConditionalCacheHit();</span><br><span class="line">        cache.update(cacheResponse, response);</span><br><span class="line">        return response;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     //如果没有缓存就将这个响应写入缓存。</span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    if (cache != null) &#123;</span><br><span class="line">      if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        // Offer this request to the cache.</span><br><span class="line">        CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">          // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存的主要总结步骤如下：</p>
<ul>
<li>如果指定仅从缓存获取但是缓存没有就返回一个  504 </li>
<li>如果没有指定从网络获取并且缓存不为空，那么就将缓存返回。</li>
<li>去网络获取响应</li>
<li>已经有缓存并且缓存需要更新的时， 更新缓存，并返回</li>
<li>如果没有缓存就将这个响应写入缓存。</li>
</ul>
<p>缓存使用的是策略模式，将缓存的策略封装在 CacheStrategy ，这个类告诉 CacheInterceptor 是使用缓存还是使用网络请求 。<br>缓存操作的定义是 接口  InternalCache ，主要操作有 put, get, 和 更新等。而具体的实现类说就是 Cache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public final class Cache implements Closeable, Flushable &#123;</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">  final InternalCache internalCache = new InternalCache() &#123;</span><br><span class="line">    @Override public Response get(Request request) throws IOException &#123;</span><br><span class="line">      return Cache.this.get(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public CacheRequest put(Response response) throws IOException &#123;</span><br><span class="line">      return Cache.this.put(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void remove(Request request) throws IOException &#123;</span><br><span class="line">      Cache.this.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void update(Response cached, Response network) &#123;</span><br><span class="line">      Cache.this.update(cached, network);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void trackConditionalCacheHit() &#123;</span><br><span class="line">      Cache.this.trackConditionalCacheHit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void trackResponse(CacheStrategy cacheStrategy) &#123;</span><br><span class="line">      Cache.this.trackResponse(cacheStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">// 缓存的核心类</span><br><span class="line">  final DiskLruCache cache;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以缓存这里的核心类是 DiskLruCache ，Cache 虽然没有实现 InternalCache 接口吗，当时基本上左右的具体的功能，都是由 Cache 结合  InternalCache 完成。</p>
<h5 id="4-ConnectIntercetor"><a href="#4-ConnectIntercetor" class="headerlink" title="(4)ConnectIntercetor"></a>(4)ConnectIntercetor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Opens a connection to the target server and proceeds to the next interceptor. */</span><br><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br></pre></td></tr></table></figure>
<p>这个拦截器即打开一个连接到目标服务器，并将这个链接提交到下一个拦截器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">  // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">  HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">  RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">  return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个只有这么点代码，但是实际上关于连接池的复用等功能都被上面的类封装起来了。之所以采用复用的原因是<br>客户端和服务器建立 socket 连接需要经历 TCP 的三次握手和四次挥手，是一种比较消耗资源的动作。Http 中有一种 keepAlive connections 的机制，在和客户端通信结束以后可以保持连接指定的时间。OkHttp3 支持 5 个并发 socket 连接，默认的 keepAlive 时间为 5 分钟。这种复用的模式就是 设计模式中的享元模式。</p>
<h6 id="1-StreamAllocation"><a href="#1-StreamAllocation" class="headerlink" title="1.StreamAllocation"></a>1.StreamAllocation</h6><p>这个类协调三个实体之间的关系。</p>
<ul>
<li>Connections：连接远程服务器的物理 Socket  连接</li>
<li>Streams : 基于 Connection 的逻辑 Http 请求/响应对<br>一个请求/响应 对应一个 Streams . 在 Http1.x，一个 Streams 对应一个 Connections。在 Http2.0，多个 Streams 可对应一个 Connections，进行并发请求。</li>
<li>Calls : 逻辑 Stream 序列，也就是请求/响应 队列</li>
</ul>
<p><img src="/2018/10/02/网络请求框架-OkHttp原理/2.png" alt="image.png"></p>
<p>StreamAllocation 会通过 ConnectPool 获取或者新生成一个 RealConnection 来得到一个连接到 Server 的 Connection 连接，<br>同时会生成一个 HttpCodec 用于下一个 CallServerInterceptor ，以完成最终的请求.在 newStream 方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">  </span><br><span class="line">    try &#123;</span><br><span class="line">    找到一个合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      HttpCodec resultCodec = resultConnection.newCodec(client, this);</span><br><span class="line">     ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="2-ConnectionPool"><a href="#2-ConnectionPool" class="headerlink" title="2.ConnectionPool"></a>2.ConnectionPool</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectionPool &#123;</span><br><span class="line">  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,</span><br><span class="line">      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,</span><br><span class="line">      new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true));</span><br><span class="line"></span><br><span class="line">  /** The maximum number of idle connections for each address. */</span><br><span class="line">  private final int maxIdleConnections;</span><br><span class="line">  private final long keepAliveDurationNs;</span><br><span class="line">  private final Runnable cleanupRunnable = new Runnable() &#123;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();</span><br><span class="line">  final RouteDatabase routeDatabase = new RouteDatabase();</span><br><span class="line">  boolean cleanupRunning;</span><br><span class="line">  ......</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    *返回符合要求的可重用连接，如果没有返回NULL</span><br><span class="line">   */</span><br><span class="line">  RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  * 去除重复连接。主要针对多路复用场景下，一个 address 只需要一个连接</span><br><span class="line">  */</span><br><span class="line">  Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  * 将连接加入连接池</span><br><span class="line">  */</span><br><span class="line">  void put(RealConnection connection) &#123;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">  * 当有连接空闲时唤起cleanup线程清洗连接池</span><br><span class="line">  */</span><br><span class="line">  boolean connectionBecameIdle(RealConnection connection) &#123;</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 扫描连接池，清除空闲连接</span><br><span class="line">  */</span><br><span class="line">  long cleanup(long now) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * 标记泄露连接</span><br><span class="line">  */</span><br><span class="line">  private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConnectionPool 内部通过一个双端队列 dequeue) 来维护当前所有连接，主要涉及到的操作包括：</p>
<ul>
<li>put：放入新连接</li>
<li>get：从连接池中获取连接</li>
<li>evictAll：关闭所有连接</li>
<li>connectionBecameIdle：连接变空闲后调用清理线程</li>
<li>deduplicate：清除重复的多路复用线程</li>
</ul>
<p>下面就看看一个是如何找到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</span><br><span class="line">     int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)</span><br><span class="line">     throws IOException &#123;</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">         connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">     // If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">     synchronized (connectionPool) &#123;</span><br><span class="line">       if (candidate.successCount == 0) &#123;</span><br><span class="line">         return candidate;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">     // isn&apos;t, take it out of the pool and start again.</span><br><span class="line">     if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">       noNewStreams();</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return candidate;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span><br><span class="line">  * then the pool, finally building a new connection.</span><br><span class="line">  */</span><br><span class="line"> private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</span><br><span class="line">     boolean connectionRetryEnabled) throws IOException &#123;</span><br><span class="line">   Route selectedRoute;</span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     if (released) throw new IllegalStateException(&quot;released&quot;);</span><br><span class="line">     if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</span><br><span class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">     // Attempt to use an already-allocated connection.</span><br><span class="line">     RealConnection allocatedConnection = this.connection;</span><br><span class="line">     if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123;</span><br><span class="line">       return allocatedConnection;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     // Attempt to get a connection from the pool.</span><br><span class="line">     Internal.instance.get(connectionPool, address, this, null);</span><br><span class="line">     if (connection != null) &#123;</span><br><span class="line">       return connection;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     selectedRoute = route;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If we need a route, make one. This is a blocking operation.</span><br><span class="line">   if (selectedRoute == null) &#123;</span><br><span class="line">     selectedRoute = routeSelector.next();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   RealConnection result;</span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">     // Now that we have an IP address, make another attempt at getting a connection from the pool.</span><br><span class="line">     // This could match due to connection coalescing.</span><br><span class="line">     Internal.instance.get(connectionPool, address, this, selectedRoute);</span><br><span class="line">     if (connection != null) return connection;</span><br><span class="line"></span><br><span class="line">     // Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">     // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.</span><br><span class="line">     route = selectedRoute;</span><br><span class="line">     refusedStreamCount = 0;</span><br><span class="line">     result = new RealConnection(connectionPool, selectedRoute);</span><br><span class="line">     acquire(result);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">   result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br><span class="line">   routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">   Socket socket = null;</span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     // Pool the connection.</span><br><span class="line">     Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">     // If another multiplexed connection to the same address was created concurrently, then</span><br><span class="line">     // release this connection and acquire that one.</span><br><span class="line">     if (result.isMultiplexed()) &#123;</span><br><span class="line">       socket = Internal.instance.deduplicate(connectionPool, address, this);</span><br><span class="line">       result = connection;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面找连接的步骤可以总结为：</p>
<ul>
<li>查看当前 streamAllocation 是否有之前已经分配过的连接，有则直接使用</li>
<li>从连接池中查找可复用的连接，有则返回该连接</li>
<li>配置路由，配置后再次从连接池中查找是否有可复用连接，有则直接返回</li>
<li>新建一个连接，并修改其 StreamAllocation 标记计数，将其放入连接池中</li>
<li>查看连接池是否有重复的多路复用连接，有则清除，一个地址只需要一个连接。</li>
</ul>
<p>而在连接池中判断一个连接是否可以复用的条件为:</p>
<ul>
<li>连接没有达到共享上限</li>
<li>非host域必须完全一样</li>
<li>如果此时host域也相同，则符合条件，可以被复用</li>
<li>如果host不相同，在HTTP/2的域名切片场景下一样可以复用.</li>
</ul>
<p>对于连接的清除，ConnectPool 有一个独立的线程进行清理的工作：</p>
<ul>
<li>遍历连接池中所有连接，标记泄露连接（即空闲时间即将达到5分钟）</li>
<li>如果被标记的连接满足(空闲 socket 连接超过5个&amp;&amp; keepalive 时间大于5分钟)，就将此 连接从 Deque 中移除，并关闭连接，返回 0，也就是将要执行 wait(0)，提醒立刻再次扫描</li>
<li>如果(目前还可以塞得下5个连接，但是有可能泄漏的连接(即空闲时间即将达到5分钟))，就返回此连接即将到期的剩余时间，供下次清理</li>
<li>如果(全部都是活跃的连接)，就返回默认的keep-alive时间，也就是5分钟后再执行清理。</li>
</ul>
<h6 id="3-RealConnection"><a href="#3-RealConnection" class="headerlink" title="3.RealConnection"></a>3.RealConnection</h6><p>描述一个物理 Socket 连接，连接池中维护多个 RealConnection 实例。由于Http/2支持多路复用，<br>一个 RealConnection 可以支持多个网络访问请求，所以 OkHttp 又引入了 StreamAllocation 来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个 Stream 对应一次请求，而一个 Call 对应一组有逻辑关联的 Stream ），一个 RealConnection 对应一个或多个 StreamAllocation ,所以 StreamAllocation 可以看做是 RealConenction 的计数器，当 RealConnection 的引用计数变为 0，且长时间没有被其他请求重新占用就将被释放.</p>
<blockquote>
<p>多路复用:<br>报头压缩：HTTP/2 使用 HPACK 压缩格式压缩请求和响应报头数据，减少不必要流量开销.<br>请求与响应复用：HTTP/2 通过引入新的二进制分帧层实现了完整的请求和响应复用，客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端将其重新组装<br>指定数据流优先级：将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，<br>客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系<br>流控制：HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制.</p>
</blockquote>
<h6 id="4-HttpCodec"><a href="#4-HttpCodec" class="headerlink" title="4.HttpCodec"></a>4.HttpCodec</h6><p>针对不同的版本，OkHttp 为我们提供了 HttpCodec1（Http1.x）和 HttpCodec2(Http2).他们就是协议的具体实现类。</p>
<h5 id="5-CallServerInterceptor-forWebSocket"><a href="#5-CallServerInterceptor-forWebSocket" class="headerlink" title="(5)CallServerInterceptor(forWebSocket)"></a>(5)CallServerInterceptor(forWebSocket)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** This is the last interceptor in the chain. It makes a network call to the server. */</span><br><span class="line">public final class CallServerInterceptor implements Interceptor &#123;</span><br></pre></td></tr></table></figure>
<p>这是整个拦截链的最后一个拦截器，负责和服务器发送请求和从服务器读取响应，<br>利用 HttpCodec 完成最终请求的发送。</p>
<p>到这里整个拦截链的分析就到这里，大致流程如图，责任链模式在这里就体现得十分清楚：</p>
<p><img src="/2018/10/02/网络请求框架-OkHttp原理/3.png" alt="image.png"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-框架/" rel="tag"># Android 框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/29/网络请求框架-理解HTTPS/" rel="next" title="网络请求框架----理解HTTPS">
                <i class="fa fa-chevron-left"></i> 网络请求框架----理解HTTPS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/13/java集合-Map/" rel="prev" title="java集合----Map">
                java集合----Map <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
 <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/d.jpg"
                alt="海盗的帽子" />
            
              <p class="site-author-name" itemprop="name">海盗的帽子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yishengma" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/m0_38089373" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-前言"><span class="nav-text">一.前言</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HttpClient"><span class="nav-text">HttpClient</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HttpURLConnection"><span class="nav-text">HttpURLConnection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#OkHttp"><span class="nav-text">OkHttp</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-简介"><span class="nav-text">二.简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-原理"><span class="nav-text">三.原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-初始化"><span class="nav-text">1.初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-发起请求"><span class="nav-text">2.发起请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-处理请求"><span class="nav-text">3.处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-同步请求的方式"><span class="nav-text">(1)同步请求的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dispatcher-executed-this-client-dispatcher-finished-this"><span class="nav-text">dispatcher().executed(this) / client.dispatcher().finished(this)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-异步请求的方式"><span class="nav-text">(1)异步请求的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#dispatcher-enqueue-new-AsyncCall-responseCallback"><span class="nav-text">dispatcher.enqueue(new AsyncCall(responseCallback))</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最后-client-dispatcher-finished"><span class="nav-text">最后 client.dispatcher().finished</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-拦截器链"><span class="nav-text">4.拦截器链</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-RetryAndFollowUpInterceptor"><span class="nav-text">(1)RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-BridgeInterceptor"><span class="nav-text">(2)BridgeInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-在请求前拦截："><span class="nav-text">1.在请求前拦截：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-调用下一个拦截器去获取响应"><span class="nav-text">2.调用下一个拦截器去获取响应</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-获取响应后再次拦截"><span class="nav-text">3.获取响应后再次拦截</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-CacheInterceptor"><span class="nav-text">(3)CacheInterceptor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-ConnectIntercetor"><span class="nav-text">(4)ConnectIntercetor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-StreamAllocation"><span class="nav-text">1.StreamAllocation</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-ConnectionPool"><span class="nav-text">2.ConnectionPool</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-RealConnection"><span class="nav-text">3.RealConnection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-HttpCodec"><span class="nav-text">4.HttpCodec</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-CallServerInterceptor-forWebSocket"><span class="nav-text">(5)CallServerInterceptor(forWebSocket)</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">海盗的帽子</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v="></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v="></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://rawgit.com/yishengma/147d4f60feb7cdc79c355ad2da83d513/raw/d624cffa8a67b4da07048d59ba0031e2860b1b2b/md5.min.js"></script>
    <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '15e7b5ecca662534768c',
          clientSecret: '26dc23d2d7a013bbcce94772f42f2e434247c6ba',
          repo: 'yishengma.github.io',
          owner: 'yishengma',
          admin: ['yishengma'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')
    </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2LveBulvcfzvQ6MBGz9b3URY-gzGzoHsz", "7mcKtxSVSDUSpSxFfdxBmyaP");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
